[
    {
        "test_id": 0,
        "prompt_en": "Smooth the array [1, 4, 5, 6, 5, 7, 8] using a one-dimensional Gaussian filter with a standard deviation of 2, and treat the boundary as extended mode during the convolution calculation. Return the array after processing.",
        "prompt_zh": "使用标准差为2的一维高斯滤波器对数组[1, 4, 5, 6, 5, 7, 8]进行平滑处理，并在卷积计算时将边界视为扩展模式，返回处理后的数组。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.convolution import Gaussian1DKernel, convolve\n  gauss = Gaussian1DKernel(stddev=2)\n  return convolve([1, 4, 5, 6, 5, 7, 8], gauss, boundary='extend')\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 1,
        "prompt_en": "Apply a Gaussian smoothing kernel with a standard deviation of 2 to the sequence [1, 2, 3, 4, 5, 6, 7, 8], and return the result after convolution.",
        "prompt_zh": "对序列[1, 2, 3, 4, 5, 6, 7, 8]应用标准差为2的高斯平滑核，并返回卷积后的结果。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.convolution import Gaussian1DKernel\n  from astropy.convolution import convolve\n  gauss = Gaussian1DKernel(stddev=2)\n  result = convolve([1, 2, 3, 4, 5, 6, 7, 8], gauss)\n  return result\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 2,
        "prompt_en": "Conduct convolution on the one-dimensional array [1, 4, 5, 6, 5, 7, 8] using the kernel [0.2, 0.6, 0.2], and return the convolution result.",
        "prompt_zh": "对一维数组[1, 4, 5, 6, 5, 7, 8]应用[0.2, 0.6, 0.2]作为核的卷积，并返回卷积结果。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.convolution import convolve\n  result = convolve([1, 4, 5, 6, 5, 7, 8], [0.2, 0.6, 0.2])\n  return result\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 3,
        "prompt_en": "Perform convolution on the list [1, 4, 5, 6, 5, 7, 8] using the convolution kernel `[0.2, 0.6, 0.2]`, and set the boundary extension mode to `extend`.",
        "prompt_zh": "使用卷积核 `[0.2, 0.6, 0.2]` 对列表 `[1, 4, 5, 6, 5, 7, 8]` 进行卷积处理，并设置边界扩展模式为 `extend`。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.convolution import convolve\n  result = convolve([1, 4, 5, 6, 5, 7, 8], [0.2, 0.6, 0.2], boundary='extend')\n  return result\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 4,
        "prompt_en": "Perform convolution on the list [1, 2, 3, 4, 5] using a one-dimensional Gaussian kernel with a standard deviation of 2, and return the result after convolution.",
        "prompt_zh": "使用标准差为2的一维高斯核对列表[1, 2, 3, 4, 5]进行卷积处理，并返回卷积后的结果。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.convolution import Gaussian1DKernel, convolve\n  gauss = Gaussian1DKernel(stddev=2)\n  result = convolve([1, 2, 3, 4, 5], gauss.array)\n  return result\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 5,
        "prompt_en": "Query the numerical value of the speed of light constant expressed in the CGS unit system (centimeters per second).",
        "prompt_zh": "查询以CGS单位系统（厘米/秒）表示的光速常数的数值。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.constants import c\n    return c.cgs  # Returns the speed of light in CGS units\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 6,
        "prompt_en": "Calculate the charge of an electron amplified by a factor of 100, and convert it to electrostatic units (esu).",
        "prompt_zh": "计算100倍电子的电荷量，并将其转换为静电单位（esu）。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.constants import e\n    return 100 * e.esu  # Computes 100 times the charge of an electron in electrostatic units\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 7,
        "prompt_en": "Calculate the gravitational force between an object with a mass of 3 solar masses and another object weighing 100 kilograms at a distance of 2.2 astronomical units, and convert the result into Newton units.",
        "prompt_zh": "计算一个质量为3太阳质量和100公斤物体之间，在距离为2.2天文单位时的引力，并将结果转换为牛顿单位。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy import constants as const\n  from astropy import units as u\n  F = (const.G * 3. * const.M_sun * 100 * u.kg) / (2.2 * u.au) ** 2\n  return F.to(u.N)\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 8,
        "prompt_en": "Retrieve the value of the elementary charge defined in the current version of Astropy.",
        "prompt_zh": "获取当前Astropy版本中定义的电子电荷的数值。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.constants import astropyconst20 as const\n  return const.e.value\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查两个浮点数是否近似相等\n    return np.isclose(data1, data2, atol=1e-8)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 9,
        "prompt_en": "Retrieve the numerical value of the gravitational constant.",
        "prompt_zh": "获取万有引力常数的数值。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.constants import G\n    return G.value\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查两个浮点数是否近似相等\n    return np.isclose(data1, data2, atol=1e-8)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 10,
        "prompt_en": "Convert the speed of light from meters per second to kilometers per second.",
        "prompt_zh": "将光速从米每秒转换为千米每秒。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.constants import c\n    return c.to('km/s')\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 11,
        "prompt_en": "Retrieve the numerical value of the Planck constant as recommended by CODATA in 2014.",
        "prompt_zh": "获取2014年CODATA推荐的普朗克常数的数值。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.constants import codata2014 as const\n    return const.h.value\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查两个浮点数是否近似相等\n    return np.isclose(data1, data2, atol=1e-8)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 12,
        "prompt_en": "Retrieve the luminosity value of the Sun using the standard constants defined by the International Astronomical Union (IAU) in 2015.",
        "prompt_zh": "获取太阳的光度数值（Luminosity of the Sun）使用2015年国际天文学联合会（IAU）定义的标准常数。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.constants import iau2015 as const\n    return const.L_sun.value\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查两个浮点数是否近似相等\n    return np.isclose(data1, data2, atol=1e-8)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 13,
        "prompt_en": "Calculate the energy equivalence of the rest mass of an electron and convert it into Mega electron-volts (MeV) units.",
        "prompt_zh": "计算电子的静止质量的能量等价并将其转换成兆电子伏特(MeV)单位。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.constants import m_e, c\n    m = m_e\n    E = m * c**2\n    return E.to('MeV')\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 14,
        "prompt_en": "Use a one-dimensional Gaussian kernel with a standard deviation of 1 to repair the one-dimensional array containing NaNs [1, NaN, 3, 4, NaN, 6, NaN], and then return the repaired array result.",
        "prompt_zh": "使用一维高斯核修复包含NaN的一维数组 [1, NaN, 3, 4, NaN, 6, NaN]，核的标准差为1，然后返回修复后的数组结果。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.convolution import interpolate_replace_nans, Gaussian1DKernel\n    import numpy as np\n    image = np.array([1, np.nan, 3, 4, np.nan, 6, np.nan])\n    kernel = Gaussian1DKernel(1)\n    result = interpolate_replace_nans(image, kernel)\n    return result\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 15,
        "prompt_en": " Perform Gaussian smoothing on the one-dimensional data list [1, 4, 5, 6, 5, 7, 8] using a Gaussian convolution kernel with a standard deviation of 2, and return the smoothed result.",
        "prompt_zh": "对一维数据列表[1, 4, 5, 6, 5, 7, 8]进行高斯平滑处理，使用标准差为2的高斯卷积核，并返回平滑后的结果。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.convolution import Gaussian1DKernel, convolve\n  gauss = Gaussian1DKernel(stddev=2)\n  result = convolve([1, 4, 5, 6, 5, 7, 8], gauss.array)\n  return result\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 16,
        "prompt_en": "Apply a one-dimensional Gaussian kernel with a standard deviation of 2 to convolve the array [1, 2, 3, 4, 5, 6, 7, 8, 9], and return the resultant array after processing.",
        "prompt_zh": "对数组[1, 2, 3, 4, 5, 6, 7, 8, 9]应用一个标准差为2的一维高斯核进行卷积，返回处理后的结果数组。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.convolution import Gaussian1DKernel, convolve\n  import numpy as np\n  gauss = Gaussian1DKernel(stddev=2)\n  result = convolve(np.array([1, 2, 3, 4, 5, 6, 7, 8, 9]), gauss.array)\n  return result\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 17,
        "prompt_en": "Replace the NaN values in the one-dimensional array [1, NaN, 3, 4, NaN, 6, 7] using a Gaussian kernel with a standard deviation of 2.",
        "prompt_zh": "使用高斯核替换一维数组[1, NaN, 3, 4, NaN, 6, 7]中的NaN值。高斯核的标准差应设为2。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.convolution import interpolate_replace_nans, Gaussian1DKernel\n  import numpy as np\n  gauss_kernel = Gaussian1DKernel(2)\n  with_nan = np.array([1, np.nan, 3, 4, np.nan, 6, 7])\n  result = interpolate_replace_nans(with_nan, gauss_kernel)\n  return result\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 18,
        "prompt_en": "Apply a simple moving average convolution kernel `[0.2, 0.6, 0.2]` to the one-dimensional data array `[1, 4, 5, 6, 5, 7, 8]` to perform convolution operations, and return the result after convolution.",
        "prompt_zh": "对一维数据数组`[1, 4, 5, 6, 5, 7, 8]`应用一个简单的移动平均卷积核`[0.2, 0.6, 0.2]`来执行卷积运算，并返回卷积后的结果。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.convolution import convolve\n    return convolve([1, 4, 5, 6, 5, 7, 8], [0.2, 0.6, 0.2])\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 19,
        "prompt_en": "Perform a convolution operation on the one-dimensional array [1, 4, 5, 6, 5, 7, 8] with the convolution kernel [0.2, 0.6, 0.2], and set the convolution boundary as 'extend'. Return the array after the convolution.",
        "prompt_zh": "对一维数组[1, 4, 5, 6, 5, 7, 8]执行卷积操作，使用卷积核[0.2, 0.6, 0.2]，并且将卷积边界设定为'extend'，返回卷积后的数组。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.convolution import convolve\n    return convolve([1, 4, 5, 6, 5, 7, 8], [0.2, 0.6, 0.2], boundary='extend')\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 20,
        "prompt_en": "Apply Gaussian smoothing with a standard deviation of 2 to the one-dimensional data list [1, 2, 3, 4, 5] and return the smoothed result.",
        "prompt_zh": "对一维数据列表[1, 2, 3, 4, 5]应用标准差为2的高斯平滑，并返回平滑后的结果。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.convolution import convolve, Gaussian1DKernel\n    gauss = Gaussian1DKernel(stddev=2)\n    return convolve([1, 2, 3, 4, 5], gauss)\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 21,
        "prompt_en": " Create a two-dimensional Gaussian distribution model with an amplitude of 1, standard deviations of 3, centered at (0, 0), and generate a grid array of size 201x201. Add a layer of random noise to this Gaussian distribution, where the noise level is 0.1*(random number between 0 and 1 - 0.5). Then, smooth the data using a Gaussian kernel with a standard deviation of 2, and return the processed image data.",
        "prompt_zh": "创建一个幅值为1、标准差都为3、中心位于(0, 0)的二维高斯分布模型，生成一个尺寸为201x201的网格数组。在这个高斯分布上添加一层随机噪音，噪声大小为0.1*(0-1的随机数-0.5)。然后，使用标准差为2的高斯核对数据进行平滑处理，并返回处理后的图像数据。",
        "canonical_solution": "def canonical_solution():\n    import numpy as np\n    from astropy.convolution import convolve, Gaussian2DKernel\n    from astropy.modeling.models import Gaussian2D\n    # Create a 2D Gaussian profile with added noise\n    gauss = Gaussian2D(1, 0, 0, 3, 3)\n    rng = np.random.default_rng()\n    x = np.arange(-100, 101)\n    y = np.arange(-100, 101)\n    x, y = np.meshgrid(x, y)\n    data_2D = gauss(x, y) + 0.1 * (rng.random((201, 201)) - 0.5)\n    # Create a Gaussian kernel and smooth the data\n    gauss_kernel = Gaussian2DKernel(2)\n    smoothed_data_gauss = convolve(data_2D, gauss_kernel)\n    \n    return smoothed_data_gauss\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 22,
        "prompt_en": "Create a one-dimensional Lorentz distribution model with a peak value of 1, a central position at 0, and a full width at half maximum of 1. Then, generate 100 equally spaced points in the interval from -5 to 5 and compute the corresponding Lorentz distribution values. Add noise to these data points, generated by taking uniform random numbers from 0 to 1, subtracting 0.5, and then multiplying by 0.1. Finally, convolve the noisy data with a Gaussian kernel with a standard deviation of 2 and return the smoothed data afterward.",
        "prompt_zh": "创建一个具有峰值为1、中心位置在0，全宽半最大值为1的一维洛伦兹分布模型，然后在-5到5的区间内生成100个等间距点，并计算其对应的洛伦兹分布。为这些数据添加由随机数生成的噪声，噪声是将0到1的均匀随机数减去0.5后乘以0.1产生。最后，用一个标准差为2的高斯核对噪声数据进行卷积平滑，并返回平滑后的数据。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.modeling.models import Lorentz1D\n    from astropy.convolution import convolve, Gaussian1DKernel\n    import numpy as np\n    \n    rng = np.random.default_rng()\n    lorentz = Lorentz1D(1, 0, 1)\n    x = np.linspace(-5, 5, 100)\n    data_1D = lorentz(x) + 0.1 * (rng.random(100) - 0.5)\n    \n    gauss_kernel = Gaussian1DKernel(2)\n    smoothed_data_gauss = convolve(data_1D, gauss_kernel)\n    \n    return smoothed_data_gauss\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 23,
        "prompt_en": "Create a one-dimensional Lorentzian distribution model with an amplitude of 1, center at 0, and FWHM (Full Width at Half Maximum) of 1. Then generate 100 equally spaced points ranging from -5 to 5. Add noise to the generated data, where the noise is simulated as random numbers between 0 to 1 subtracted by 0.5, and then multiplied by 0.1. Afterwards, smooth the data using a one-dimensional boxcar convolution kernel with a width of 5, and return the smoothed result.",
        "prompt_zh": "创建一个一维的洛伦兹分布模型，参数设置为幅度1、中心0和FWHM为1，然后在-5到5的范围内生成100个等间隔的点。对生成的数据添加噪声，噪声模拟为0到1之间的随机数减去0.5，再乘以0.1。之后，使用宽度为5的一维盒形卷积核对数据进行平滑处理，并返回平滑后的结果。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.modeling.models import Lorentz1D\n    from astropy.convolution import convolve, Box1DKernel\n    import numpy as np\n    \n    rng = np.random.default_rng()\n    lorentz = Lorentz1D(1, 0, 1)\n    x = np.linspace(-5, 5, 100)\n    data_1D = lorentz(x) + 0.1 * (rng.random(100) - 0.5)\n    \n    box_kernel = Box1DKernel(5)\n    smoothed_data_box = convolve(data_1D, box_kernel)\n    \n    return smoothed_data_box\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 24,
        "prompt_en": "Generate one-dimensional Lorentzian distribution data with an amplitude of 1, a center at 0, and an FWHM of 1. Evaluate on 100 equally spaced points ranging from -5 to 5. Add random noise to the data (noise range from -0.05 to 0.05), then smooth using a one-dimensional Gaussian function with a standard deviation of 2. Return the processed smooth data after completion.",
        "prompt_zh": "生成一维洛伦兹分布数据（振幅为1，中心为0， FWHM为1），并在从-5到5范围内的100个等距的点上评估。在此数据上加入随机噪声（噪声范围从-0.05到0.05），再采用标准差为2的一维高斯函数进行平滑，最终返回处理后的平滑数据。\n",
        "canonical_solution": "def canonical_solution():\n  import numpy as np\n  from astropy.modeling.models import Lorentz1D\n  from astropy.convolution import convolve, Gaussian1DKernel\n  \n  lorentz = Lorentz1D(1, 0, 1)\n  x = np.linspace(-5, 5, 100)\n  rng = np.random.default_rng()\n  data_1D = lorentz(x) + 0.1 * (rng.random(100) - 0.5)\n  gauss_kernel = Gaussian1DKernel(2)\n  smoothed_data_gauss = convolve(data_1D, gauss_kernel)\n  return smoothed_data_gauss\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 25,
        "prompt_en": "Create a two-dimensional Gaussian distribution model with a peak height of 1, centered at (0, 0), and set the standard deviations in both x and y directions to 3. Construct a two-dimensional spatial grid ranging from -100 to 100, and generate the corresponding Gaussian data on this grid. Then add some noise by generating random numbers from a uniform distribution within the range of -0.05 to 0.05. Next, construct a two-dimensional Gaussian kernel with a standard deviation of 2 and use this kernel to convolve the noisy data in order to smooth the data. Finally, return the smoothed two-dimensional data after processing.",
        "prompt_zh": "创建一个具有高度为1的二维高斯分布模型，中心位于(0, 0)处，x 和 y 方向的标准差均设置为3。构造一个从-100至100的二维空间网格，并在这个网格上生成对应的高斯数据，然后添加一些噪声（通过从均匀分布中生成的随机数，范围在-0.05至0.05之间）。接下来，构造一个标准差为2的二维高斯核，并使用该核对含噪声的数据进行卷积处理以平滑数据。最后返回平滑后的二维数据。\n",
        "canonical_solution": "def canonical_solution():\n  import numpy as np\n  from astropy.modeling.models import Gaussian2D\n  from astropy.convolution import convolve, Gaussian2DKernel\n  \n  gauss = Gaussian2D(1, 0, 0, 3, 3)\n  x = np.arange(-100, 101)\n  y = np.arange(-100, 101)\n  x, y = np.meshgrid(x, y)\n  rng = np.random.default_rng()\n  data_2D = gauss(x, y) + 0.1 * (rng.random((201, 201)) - 0.5)\n  gauss_kernel = Gaussian2DKernel(2)\n  smoothed_data_gauss = convolve(data_2D, gauss_kernel)\n  return smoothed_data_gauss\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 26,
        "prompt_en": "Smooth the Lorentzian one-dimensional distribution data with a noise level of 0.1, centered at 0, a peak value of 1, and a full width at half maximum (FWHM) of 1. Evaluate it at 100 equidistant points in the range from -5 to 5. Add random noise to this data (with noise ranging from -0.05 to 0.05), smooth the data using a boxcar kernel with a width of 5 points, and finally return the smoothed data.",
        "prompt_zh": "生成一个噪声水平为0.1，中心位于0，峰值为1，半高宽为1的洛伦兹一维分布数据，并在从-5到5范围内的100个等距的点上评估。在此数据上加入随机噪声（噪声范围从-0.05到0.05），采用5点宽的盒型卷积核对数据进行平滑处理，最后返回平滑处理后的数据。",
        "canonical_solution": "def canonical_solution():\n  import numpy as np\n  from astropy.modeling.models import Lorentz1D\n  from astropy.convolution import convolve, Box1DKernel\n  rng = np.random.default_rng()\n  lorentz = Lorentz1D(1, 0, 1)\n  x = np.linspace(-5, 5, 100)\n  data_1D = lorentz(x) + 0.1 * (rng.random(100) - 0.5)\n  box_kernel = Box1DKernel(5)\n  smoothed_data_box = convolve(data_1D, box_kernel)\n  return smoothed_data_box\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 27,
        "prompt_en": "Generate a 201x201 pixel two-dimensional Gaussian image with a standard deviation of 3 and centered at (0, 0). Add uniformly distributed random noise to this image, with a noise range of -0.05 to 0.05. Then smooth the noisy image using a Gaussian kernel with a standard deviation of 2. Finally, return the smoothed image data.",
        "prompt_zh": "生成一个标准差为3且中心位于(0, 0)的201x201像素的二维高斯图像，向该图像添加均匀分布的随机噪声，噪声范围为-0.05-0.05，然后使用标准差为2的高斯核对这个加噪图像进行平滑，最后返回平滑后的图像数据。",
        "canonical_solution": "def canonical_solution():\n  import numpy as np\n  from astropy.convolution import convolve, Gaussian2DKernel\n  from astropy.modeling.models import Gaussian2D\n  gauss = Gaussian2D(1, 0, 0, 3, 3)\n  rng = np.random.default_rng()\n  x = np.arange(-100, 101)\n  y = np.arange(-100, 101)\n  x, y = np.meshgrid(x, y)\n  data_2D = gauss(x, y) + 0.1 * (rng.random((201, 201)) - 0.5)\n  gauss_kernel = Gaussian2DKernel(2)\n  smoothed_data_gauss = convolve(data_2D, gauss_kernel)\n  return smoothed_data_gauss\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 28,
        "prompt_en": "Create a one-dimensional Lorentz model with a center at 0, a peak of 1, and a full-width at half-maximum (FWHM) of 1. Generate a dataset of 100 points ranging from -5 to 5. Apply this model to the generated point set and add random noise to the results. The noise size should be 0.1*(random numbers from 0 to 1 - 0.5). Then, perform a convolution operation on the data with added noise using a Gaussian kernel with a standard deviation of 2 to smooth the data. Return the smoothed results.",
        "prompt_zh": "创建一个一维洛伦兹模型，中心位于0，峰值为1，半高宽为1，并生成从-5到5共100个点的数据集，将这个模型应用于生成的点集，并在结果中添加随机噪声，噪声大小为0.1*(0-1的随机数-0.5)。然后，使用标准差为2的高斯核对添加噪声后的数据进行卷积操作，以平滑数据，并返回平滑后的结果。",
        "canonical_solution": "def canonical_solution():\n  import numpy as np\n  from astropy.modeling.models import Lorentz1D\n  from astropy.convolution import convolve, Gaussian1DKernel\n\n  rng = np.random.default_rng()\n  lorentz = Lorentz1D(1, 0, 1)\n  x = np.linspace(-5, 5, 100)\n  data_1D = lorentz(x) + 0.1 * (rng.random(100) - 0.5)\n  gauss_kernel = Gaussian1DKernel(2)\n  smoothed_data_gauss = convolve(data_1D, gauss_kernel)\n\n  return smoothed_data_gauss\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 29,
        "prompt_en": "Construct a two-dimensional Gaussian distribution with an amplitude of 1, centered at the coordinate origin (0, 0), and with a standard deviation of 3 in both the x and y directions. Apply this Gaussian distribution on a grid of size 201x201, centered at (0, 0) to generate the corresponding two-dimensional data. Add random noise to these data, where the noise for each element is generated by subtracting 0.5 from a randomly generated number between 0 and 1 and then multiplying by 0.1. Then, smooth these noisy data using a two-dimensional Gaussian convolution kernel with a standard deviation of 2, and return the smoothed dataset.",
        "prompt_zh": "构造一个具有幅值1、中心位于坐标原点(0, 0)、并且在x和y方向上标准差均为3的二维高斯分布。在一个大小为201x201、中心位于(0, 0)的网格上应用该高斯分布来生成对应的二维数据。将随机噪声添加到这些数据中，其中每个元素的噪声是由生成的0-1的随机数减去0.5并乘以0.1得到。然后，使用一个标准差为2的二维高斯卷积核以对这些含噪声的数据进行平滑处理，并返回平滑后的数据集。",
        "canonical_solution": "def canonical_solution():\n  import numpy as np\n  from astropy.convolution import convolve, Gaussian2DKernel, Tophat2DKernel\n  from astropy.modeling.models import Gaussian2D\n\n  gauss = Gaussian2D(1, 0, 0, 3, 3)\n  rng = np.random.default_rng()\n  x = np.arange(-100, 101)\n  y = np.arange(-100, 101)\n  x, y = np.meshgrid(x, y)\n  data_2D = gauss(x, y) + 0.1 * (rng.random((201, 201)) - 0.5)\n  gauss_kernel = Gaussian2DKernel(2)\n  smoothed_data_gauss = convolve(data_2D, gauss_kernel)\n\n  return smoothed_data_gauss\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 30,
        "prompt_en": "Load the FITS image data using `get_pkg_data_filename` from the location 'galactic_center/gc_msx_e.fits'. Apply a magnification factor of 1e5 to the partial region [50:90, 60:100]. Then, sharpen the image using a customized sharpening convolution kernel, which is `[[-1,-1,-1], [-1, 8, -1], [-1,-1,-1]]`. Perform the operation without normalizing the convolution kernel and treat NaN values as zeros. Return the processed image after performing these tasks.",
        "prompt_zh": "使用get_pkg_data_filename加载的FITS图像数据，地址为'galactic_center/gc_msx_e.fits'，对其部分区域[50:90, 60:100]的数据应用1e5的放大比例。然后使用一个自定义锐化卷积核对图像进行锐化处理，卷积核为[[-1,-1,-1], [-1, 8, -1], [-1,-1,-1]]，并在不归一化该卷积核的情况下进行操作，同时将NaN值视作0处理，将处理后的图像返回。",
        "canonical_solution": "def canonical_solution():\n    import numpy as np\n    import matplotlib.pyplot as plt\n    from astropy.io import fits\n    from astropy.utils.data import get_pkg_data_filename\n    from astropy.convolution import CustomKernel, convolve\n    # Load the data from data.astropy.org\n    filename = get_pkg_data_filename('galactic_center/gc_msx_e.fits')\n    hdu = fits.open(filename)[0]\n    # Scale the file and crop it for display\n    img = hdu.data[50:90, 60:100] * 1e5\n    \n    # Define a peak enhancing kernel\n    kernel = CustomKernel([[-1,-1,-1], [-1, 8, -1], [-1,-1,-1]])\n    \n    # Perform convolution without normalizing the kernel\n    astropy_conv = convolve(img, kernel, normalize_kernel=False, nan_treatment='fill')\n    return astropy_conv\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 31,
        "prompt_en": "Repair and enhance the details in the astronomical image by following these steps: 1. Use get_pkg_data_filename to read the file 'galactic_center/gc_msx_e.fits' and select a sub-region [50:90, 60:100] of the image data, scale it by 100000 times. 2. Randomly select 50 pixels in the image and set them as missing values. 3. Apply a Gaussian kernel with a standard deviation of 1 for interpolation calculations, restoring those missing pixels. 4. Use a custom sharpening kernel [[-1, -1, -1], [-1, 8, -1], [-1, -1, -1]] to enhance the edges and details of the image. 5. Return the processed image result.",
        "prompt_zh": "修复并增强天文图像中的细节，通过以下步骤：1. 使用get_pkg_data_filename读取'galactic_center/gc_msx_e.fits'文件，并选择图像数据的一个子区域[50:90, 60:100]，放大100000倍。2. 在图像中随机选取50个像素设为缺失值。3. 应用标准差为1的高斯核做插值运算、恢复那些缺失的像素。4. 使用一个自定义的锐化核[[-1, -1, -1], [-1, 8, -1], [-1, -1, -1]]增强图像的边缘和细节。5. 返回处理后的图像结果。",
        "canonical_solution": "def canonical_solution():\n    import numpy as np\n    from astropy.io import fits\n    from astropy.utils.data import get_pkg_data_filename\n    from astropy.convolution import CustomKernel, Gaussian2DKernel, convolve, interpolate_replace_nans\n    filename = get_pkg_data_filename('galactic_center/gc_msx_e.fits')\n    hdu = fits.open(filename)[0]\n    img = hdu.data[50:90, 60:100] * 1e5\n    \n    rng = np.random.default_rng(42)\n    yinds, xinds = np.indices(img.shape)\n    img[rng.choice(yinds.flat, 50), rng.choice(xinds.flat, 50)] = np.nan\n    \n    gaussian_kernel = Gaussian2DKernel(x_stddev=1)\n    reconstructed_image = interpolate_replace_nans(img, gaussian_kernel)\n    \n    peak_kernel = CustomKernel([[-1, -1, -1], [-1, 8, -1], [-1, -1, -1]])\n    peaked_image = convolve(reconstructed_image, peak_kernel, normalize_kernel=False, nan_treatment='fill')\n    return peaked_image\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 32,
        "prompt_en": "Read the FITS file located at 'galactic_center/gc_msx_e.fits', extract the data from the first primary data unit and magnify it by 100,000 times. Then, apply a convolution operation on the subregion of this data from row 50 to 90 and column 60 to 100. Use a custom 3x3 convolution kernel to perform the convolution. The kernel matrix is [[-1, -1, -1], [-1, 8, -1], [-1, -1, -1]], and do not normalize the kernel during the convolution process. Treat unknown values (NaN) as filled. Return the processed convolution image array.",
        "prompt_zh": "读取位于'galactic_center/gc_msx_e.fits'的FITS文件，提取第一主数据单元的数据并放大10万倍，然后对该数据的子区域（第50至90行，第60至100列）应用卷积操作。使用自定义的3x3卷积核进行卷积，核矩阵为[[-1, -1, -1], [-1, 8, -1], [-1, -1, -1]]，卷积过程中不进行核归一化，并将未知数值（NaN）处理为填充。返回处理后的卷积图像数组。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.io import fits\n  from astropy.utils.data import get_pkg_data_filename\n  from astropy.convolution import CustomKernel\n  from astropy.convolution import convolve\n\n  # Load the data from data.astropy.org\n  filename = get_pkg_data_filename('galactic_center/gc_msx_e.fits')\n  hdu = fits.open(filename)[0]\n\n  # Scale the file to have reasonable numbers\n  # (this is mostly so that colorbars don't have too many digits)\n  # Also, we crop it so you can see individual pixels\n  img = hdu.data[50:90, 60:100] * 1e5\n  \n  kernel = CustomKernel([[-1, -1, -1], [-1, 8, -1], [-1, -1, -1]])\n  \n  astropy_conv = convolve(img, kernel, normalize_kernel=False, nan_treatment='fill')\n  return astropy_conv\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 33,
        "prompt_en": "Smooth the array [1, 4, 5, 6, 5, 7, 8] using a one-dimensional Gaussian filter with a standard deviation of 2. Consider the boundary as an extended mode during convolution calculation. Return the smoothed array after processing.",
        "prompt_zh": "对一个2x2的图像数组进行卷积处理，图像假设为np.array([[1, 2], [3, 4]]) ，使用一个3x3的卷积核，其中中间的元素为2，与中间元素直接相邻的元素为1，其余元素为0。返回卷积处理后的结果。",
        "canonical_solution": "def canonical_solution():\n  from astropy.convolution import convolve\n  import numpy as np\n  kernel = [[0, 1, 0],\n            [1, 2, 1],\n            [0, 1, 0]]\n  image = np.array([[1, 2], [3, 4]])  # 示例中没有提供'image'数组的实际数值，这里仅假设为了展示格式\n  result = convolve(image, kernel)\n  return result\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 34,
        "prompt_en": "Apply a one-dimensional convolution to the array `[1, 4, 5, 6, 5, 7, 8]` using the convolution kernel `[0.2, 0.6, 0.2]`. Return the result after the convolution processing.",
        "prompt_zh": "对数组 `[1, 4, 5, 6, 5, 7, 8]` 应用一维卷积，使用的卷积核为 `[0.2, 0.6, 0.2]`，返回卷积处理后的结果。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.convolution import convolve\n    import numpy as np\n    return convolve([1, 4, 5, 6, 5, 7, 8], [0.2, 0.6, 0.2])\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 35,
        "prompt_en": " Apply convolution to the one-dimensional array [1, 4, 5, 6, 5, 7, 8] using [0.2, 0.6, 0.2] as the convolution kernel, and use the extended mode at the boundaries.",
        "prompt_zh": "对一维数组[1, 4, 5, 6, 5, 7, 8]应用[0.2, 0.6, 0.2]作为卷积核进行卷积处理，并在边界使用扩展模式。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.convolution import convolve\n    import numpy as np\n    return convolve([1, 4, 5, 6, 5, 7, 8], [0.2, 0.6, 0.2], boundary='extend')\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 36,
        "prompt_en": "Perform convolution on the one-dimensional data array [1, 4, 5, 6, np.nan, 7, 8] using [0.2, 0.6, 0.2] as the convolution kernel. Handle the boundaries by extending the array elements to the edge.",
        "prompt_zh": "对一维数据数组[1, 4, 5, 6, np.nan, 7, 8]采用[0.2, 0.6, 0.2]作为卷积核，执行卷积操作，处理边界时将数组元素扩展至边界。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.convolution import convolve\n    import numpy as np\n    return convolve([1, 4, 5, 6, np.nan, 7, 8], [0.2, 0.6, 0.2], boundary='extend')\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 37,
        "prompt_en": "Convolve the one-dimensional array [1, 2, 3, 4, 5] with the kernel [0, 1, 0] and return the result of the processed array.",
        "prompt_zh": "对一维数组[1, 2, 3, 4, 5]使用卷积核[0, 1, 0]进行卷积处理，并返回处理后的结果。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.convolution import convolve\n    import numpy as np\n    spectrum = [1, 2, 3, 4, 5]\n    kernel = [0, 1, 0]\n    return convolve(spectrum, kernel)\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 38,
        "prompt_en": "Convolve the given 3x3 numerical image matrix [[1, 2, 3], [4, 5, 6], [7, 8, 9]] with a convolution kernel where the middle element is 2, the top, bottom, left, and right elements are 1, and the corners are 0. Return the convolved result.",
        "prompt_zh": "对给定的3x3数字图像矩阵进行卷积处理，数字图像矩阵为[[1, 2, 3], \n[4, 5, 6], \n[7, 8, 9]]，使用的卷积核是中间元素为2，上下左右为1，角落为0的3x3矩阵。",
        "canonical_solution": "def canonical_solution():\n    from astropy.convolution import convolve\n    import numpy as np\n    image = [[1, 2, 3], \n             [4, 5, 6], \n             [7, 8, 9]]\n    kernel = [[0, 1, 0],\n              [1, 2, 1],\n              [0, 1, 0]]\n    return convolve(image, kernel)\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 39,
        "prompt_en": "Create an Angle object containing two angle values: 10.2345 degrees and -20 degrees.",
        "prompt_zh": "创建一个Angle对象，包含两个角度值10.2345度和-20度。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.coordinates import Angle\n  angle = Angle(['10.2345d', '-20d'])\n  return angle\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 40,
        "prompt_en": "Create an Angle object representing 1 hour, 2 minutes, and 0 seconds.",
        "prompt_zh": "创建一个表示1小时2分0秒角度的Angle对象。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.coordinates import Angle\n  angle = Angle('1 2 0 hours')\n  return angle\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 41,
        "prompt_en": "Create an `Angle` object containing a sequence of angle values from 1 to 7 degrees and return this object.",
        "prompt_zh": "创建一个包含从1到7度的角度值序列的`Angle`对象，并返回该对象。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy import units as u\n  from astropy.coordinates import Angle\n  import numpy as np\n  angle = Angle(np.arange(1., 8.), unit=u.deg)\n  return angle\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 42,
        "prompt_en": "Create an Astropy Angle object representing an angle of 1 degree, 2 arcminutes, and 3 arcseconds.",
        "prompt_zh": "创建一个表示1度2分3秒角度的Astropy Angle对象。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.coordinates import Angle\n  angle = Angle('1°2′3″')\n  return angle\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 43,
        "prompt_en": "Create an Angle object representing an angle of 1 degree, 2 arcminutes, and 3 arcseconds North.",
        "prompt_zh": "创建一个表示北纬1度2分3秒角度的Angle对象。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.coordinates import Angle\n  angle = Angle('1°2′3″N')\n  return angle\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 44,
        "prompt_en": "Create an Astropy Angle object representing an angle of 1 degree, 2 arcminutes, and 3.4 arcseconds.",
        "prompt_zh": "创建一个表示1度2弧分3.4弧秒的Astropy Angle对象。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.coordinates import Angle\n  angle = Angle('1d2m3.4s')\n  return angle\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 45,
        "prompt_en": "Create an Angle object representing 1 degree, 2 minutes, and 3.4 seconds south latitude.",
        "prompt_zh": "创建一个表示南纬1度2分3.4秒的Angle对象。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.coordinates import Angle\n  angle = Angle('1d2m3.4sS')\n  return angle\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 46,
        "prompt_en": "Create an Astropy Angle object representing the angle defined by the hour angle string '-1h2m3s'.",
        "prompt_zh": "创建一个表示由时角字符串'-1h2m3s'定义的角度的Astropy Angle对象。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.coordinates import Angle\n  angle = Angle('-1h2m3s')\n  return angle\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 47,
        "prompt_en": "Create an Angle object representing an angle of 10.2345 degrees.",
        "prompt_zh": "创建一个表示10.2345度角度的Angle对象。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.coordinates import Angle\n  a = Angle('10.2345d')\n  return a\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 48,
        "prompt_en": "Create an Angle object representing an angle of 1 degree, 2 minutes, and 30.43 seconds.",
        "prompt_zh": "创建一个表示角度为1度2分30.43秒的Angle对象。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.coordinates import Angle\n  a = Angle('1:2:30.43 degrees')\n  return a\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 49,
        "prompt_en": "Create an Angle object representing a westward angle of -1 hour, 2 minutes, and 3 seconds.",
        "prompt_zh": "创建一个表示西向角度为-1小时2分3秒的Angle对象。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.coordinates import Angle\n  a = Angle('-1h2m3sW')\n  return a\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 50,
        "prompt_en": "Calculate the position of an astronomical object in the Galactic coordinate system with longitude 10 degrees, latitude 45 degrees, at a distance of 100 parsecs. The proper motion in the longitude direction is 34 milliarcseconds per year, and in the latitude direction, it's -117 milliarcseconds per year. Determine the object's position 10 years after December 18, 1988.",
        "prompt_zh": "计算在银河坐标系中坐标为经度10度、纬度45度、距离100秒差距，经度方向自行为34毫角秒/年，纬度方向自行为-117毫角秒/年的天体，从1988年12月18日起10年后的位置。\n",
        "canonical_solution": "def canonical_solution():\n    import astropy.units as u\n    from astropy.time import Time\n    from astropy.coordinates import SkyCoord\n    c = SkyCoord(l=10*u.degree, b=45*u.degree, distance=100*u.pc,\n                 pm_l_cosb=34*u.mas/u.yr, pm_b=-117*u.mas/u.yr,\n                 frame='galactic',\n                 obstime=Time('1988-12-18 05:11:23.5'))\n    return c.apply_space_motion(dt=10. * u.year)\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 51,
        "prompt_en": "Calculate the change in space position of an object in the Galactic coordinate system between December 18, 1988, 05:11:23.5 and December 18, 2017, 01:12:07.3, with the following parameters: Galactic longitude 10 degrees, Galactic latitude 45 degrees, distance 100 parsecs, proper motion along longitude 34 milliarcseconds per year, and proper motion along latitude -117 milliarcseconds per year.",
        "prompt_zh": "计算银河坐标系中，具有以下参数的天体从1988年12月18日05:11:23.5到2017年12月18日01:12:07.3间空间位置的变化：银经10度，银纬45度，距离100秒差距，银经方向自行速度34毫角秒/年，银纬方向自行速度-117毫角秒/年。\n",
        "canonical_solution": "def canonical_solution():\n    import astropy.units as u\n    from astropy.time import Time\n    from astropy.coordinates import SkyCoord\n    c = SkyCoord(l=10*u.degree, b=45*u.degree, distance=100*u.pc,\n                 pm_l_cosb=34*u.mas/u.yr, pm_b=-117*u.mas/u.yr,\n                 frame='galactic',\n                 obstime=Time('1988-12-18 05:11:23.5'))\n    return c.apply_space_motion(new_obstime=Time('2017-12-18 01:12:07.3'))\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 52,
        "prompt_en": "Transform the location at longitude -1 degree, latitude 52 degrees, and height 10 km, to the horizontal coordinate system relative to another location with the same longitude and latitude but with height 0 km, at Julian year J2010, in the ITRS coordinate system. Return the altitude of this location.",
        "prompt_zh": "在2009年的儒略年（J2010）的时候，将位于经度-1度，纬度52度，高度10公里的一个地点，相对于同一经纬度但高度为0的另一个地点，在ITRS坐标系统下转换到地平坐标系中，并返回该位置的高度角。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.coordinates import EarthLocation, AltAz\n    from astropy.time import Time\n    from astropy import units as u\n    t = Time('J2010')\n    obj = EarthLocation(-1*u.deg, 52*u.deg, height=10.*u.km)\n    home = EarthLocation(-1*u.deg, 52*u.deg, height=0.*u.km)\n    aa = obj.get_itrs(t).transform_to(AltAz(obstime=t, location=home))\n    return aa.alt\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 53,
        "prompt_en": "Calculate the angular separation between a celestial object with coordinates (101.4°, 23.02°) in the ICRS reference frame and the Moon, which is in the GCRS reference frame with a coordinate of (104.29°, 23.51°, 359367.3 km) at the observation time of May 22, 2010, 00:00.",
        "prompt_zh": "计算视场参考框架为ICRS，坐标为(101.4°, 23.02°)的天体与视场参考框架为GCRS，观测时间为2010年5月22日00:00，坐标为(104.29°, 23.51°, 359367.3 km)的月亮天体之间的角距离。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n    from astropy.coordinates import SkyCoord, GCRS\n    from astropy.time import Time\n    t = Time(\"2010-05-22T00:00\")\n    moon = SkyCoord(104.29*u.deg, 23.51*u.deg, 359367.3*u.km, frame=GCRS(obstime=t))\n    star = SkyCoord(101.4*u.deg, 23.02*u.deg, frame='icrs')\n    return star.separation(moon)\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 54,
        "prompt_en": "Calculate the angular distance between the Moon, observed in the GCRS coordinate system with coordinates (longitude 104.29 degrees, latitude 23.51 degrees, and distance 359367.3 km) at 00:00 on May 22, 2010, and a star with coordinates (longitude 101.4 degrees, latitude 23.02 degrees) in the ICRS coordinate system.",
        "prompt_zh": "计算以GCRS坐标系观测的月球坐标（104.29度经度，23.51度纬度，359367.3公里距离）在2010年5月22日00:00与ICRS坐标系中一恒星坐标（101.4度经度，23.02度纬度）之间的角距离。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n    from astropy.coordinates import SkyCoord, GCRS\n    from astropy.time import Time\n    t = Time(\"2010-05-22T00:00\")\n    moon = SkyCoord(104.29*u.deg, 23.51*u.deg, 359367.3*u.km, frame=GCRS(obstime=t))\n    star = SkyCoord(101.4*u.deg, 23.02*u.deg, frame='icrs')\n    return moon.separation(star)\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 55,
        "prompt_en": "Create an ICRS object representing celestial coordinates with a right ascension (RA) of 187.70592 degrees and a declination (Dec) of 12.39112 degrees. Convert the right ascension to a string in hours format and the declination to a string in degrees format, including the sign. Generate a sentence that describes the location of the galaxy M87, mentioning its right ascension rounded to approximately two decimal places in hours, its declination rounded to approximately one decimal place in degrees, and including the keywords \"M87\", \"RA\", \"Dec\", and \"jet\". Return the right ascension, declination, and the sentence describing the position of the galaxy M87.",
        "prompt_zh": "创建一个表示天体坐标的ICRS对象，其赤经为187.70592度，赤纬为12.39112度。将赤经转换为小时制的字符串，将赤纬转换为度数制的字符串，并包含符号。生成一条描述M87星系位置的句子，提到其赤经为小时制约为两位小数，赤纬为度数制约为一位小数，并包含\"M87\"、\"赤经(RA)\"、\"赤纬(Dec)\"和\"喷流(jet)\"等关键词，'The galaxy M87, at an RA of ** hours and Dec of ** degrees, has an impressive jet.'，返回赤经、赤纬、描述M87星系位置的句子。",
        "canonical_solution": "def canonical_solution():\n  from astropy.coordinates import ICRS\n  from astropy import units as u\n  coo = ICRS(187.70592*u.degree, 12.39112*u.degree)\n  rahmsstr = coo.ra.to_string(u.hour)\n  decdmsstr = coo.dec.to_string(u.degree, alwayssign=True)\n  sentence = f'The galaxy M87, at an RA of {coo.ra.hour:.2f} hours and Dec of {coo.dec.deg:.1f} degrees, has an impressive jet.'\n  return rahmsstr, decdmsstr, sentence\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接使用比较运算符 == 来判断两个 numpy.str_ 是否相同\n    return data1 == data2\n\n",
            "\ndef test_code(data1, data2):\n    # 直接使用比较运算符 == 来判断两个 numpy.str_ 是否相同\n    return data1 == data2\n\n",
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 56,
        "prompt_en": "Create an ICRS (International Celestial Reference System) coordinate object with a right ascension of 187.70592 degrees and a declination of 12.39112 degrees. Return the string form of the coordinate's right ascension and declination separated by a space.",
        "prompt_zh": "创建一个ICRS（国际天球参考系统）坐标对象，赤经为187.70592度，赤纬为12.39112度，并返回该坐标的赤经和赤纬的字符串形式，以空格分隔。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.coordinates import ICRS\n  from astropy import units as u\n  coo = ICRS(187.70592*u.degree, 12.39112*u.degree)\n  return str(coo.ra) + ' ' + str(coo.dec)\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 57,
        "prompt_en": "Convert the celestial object's right ascension and declination coordinates (187.70592 degrees, 12.39112 degrees) into hour angle and signed degree format, and return the formatted result as a string.",
        "prompt_zh": "将天体的赤经赤纬坐标（187.70592度, 12.39112度）转换成小时角和带符号的弧度表示，并将转换结果格式化输出为字符串。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.coordinates import ICRS\n  from astropy import units as u\n  coo = ICRS(187.70592*u.degree, 12.39112*u.degree)\n  rahmsstr = coo.ra.to_string(u.hour)\n  decdmsstr = coo.dec.to_string(u.degree, alwayssign=True)\n  return f\"{rahmsstr} {decdmsstr}\"\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 58,
        "prompt_en": "Convert the ICRS coordinates of a celestial object, with right ascension of 187.70592 degrees and declination of 12.39112 degrees, into a string representation in the SDSS catalog format. The right ascension should be expressed in hour angle units with a precision of two decimal places, and the declination should include a sign. The final output should be in the format \"SDSS JRightAscensionDeclination\".",
        "prompt_zh": "将天体的ICRS坐标187.70592度赤经和12.39112度赤纬转换成SDSS目录格式的字符串表示，赤经用时角单位表示，保留两位小数精度，并确保赤纬包含正负号，最终以“SDSS J赤经赤纬”的格式输出。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.coordinates import ICRS\n  from astropy import units as u\n  coo = ICRS(187.70592*u.degree, 12.39112*u.degree)\n  formatted_string = (f\"SDSS J{coo.ra.to_string(unit=u.hourangle, sep='', precision=2, pad=True)}\"\n                     f\"{coo.dec.to_string(sep='', precision=2, alwayssign=True, pad=True)}\")\n  return formatted_string\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 59,
        "prompt_en": "Create an ICRS coordinate object representing the position of the galaxy M87, with a Right Ascension (RA) of 187.70592 degrees and a Declination (Dec) of 12.39112 degrees. Then generate and return a descriptive text that includes M87's RA in hours (rounded to two decimal places) and Dec in degrees (rounded to one decimal place), mentioning that it has an impressive jet, 'The galaxy M87, at an RA of ** hours and Dec of ** degrees, has an impressive jet.'",
        "prompt_zh": "创建一个表示银河M87位置的ICRS坐标对象，赤经187.70592度，赤纬12.39112度。然后生成并返回一段描述文本，内容包括M87的赤经小时数（保留两位小数）和赤纬度数（保留一位小数），以及提到它有一个令人印象深刻的喷流，'The galaxy M87, at an RA of ** hours and Dec of ** degrees, has an impressive jet.'",
        "canonical_solution": "def canonical_solution():\n  from astropy.coordinates import ICRS\n  from astropy import units as u\n  coo = ICRS(187.70592*u.degree, 12.39112*u.degree)\n  output_sentence = (f\"The galaxy M87, at an RA of {coo.ra.hour:.2f} hours and Dec of {coo.dec.deg:.1f} degrees, \"\n                     \"has an impressive jet.\")\n  return output_sentence\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 60,
        "prompt_en": "Create an ICRS coordinate object representing a position in Cartesian coordinates with x=1 kiloparsec, y=2 kiloparsecs, and z=3 kiloparsecs.",
        "prompt_zh": "创建一个表示位置为x=1千帕赛，y=2千帕赛，z=3千帕赛在笛卡尔坐标系中的ICRS坐标对象。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.coordinates import ICRS\n    from astropy import units as u\n    c = ICRS(x=1*u.kpc, y=2*u.kpc, z=3*u.kpc, representation_type='cartesian')\n    return c\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 61,
        "prompt_en": "Create an object representing spherical coordinates with a longitude of 1.1 degrees, a latitude of 2.2 degrees, and a distance of 3.3 kiloparsecs.",
        "prompt_zh": "创建一个表示球形坐标的对象，这个坐标的长经为1.1度，纬度为2.2度，距离为3.3千帕赛克。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.coordinates import SphericalRepresentation\n    from astropy import units as u\n    rep = SphericalRepresentation(lon=1.1*u.deg, lat=2.2*u.deg, distance=3.3*u.kpc)\n    return rep\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 62,
        "prompt_en": "Convert the ICRS (International Celestial Reference System) coordinates with right ascension of 1.1 degrees and declination of 2.2 degrees to the FK5 (Fifth Fundamental Catalog) coordinate system.",
        "prompt_zh": "将赤经为1.1度、赤纬为2.2度的ICRS（国际天球参考系统）坐标转换为FK5（第五基本星表）坐标系统下的坐标。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.coordinates import ICRS, FK5\n    from astropy import units as u\n    coo = ICRS(ra=1.1*u.deg, dec=2.2*u.deg)\n    return coo.transform_to(FK5())\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 63,
        "prompt_en": "Create an ICRS coordinate object containing two sets of right ascension and declination coordinates: the first set has a right ascension of 1.5 degrees and a declination of 3.5 degrees; the second set has a right ascension of 2.5 degrees and a declination of 4.5 degrees. Return this coordinate object.",
        "prompt_zh": "创建一个ICRS坐标对象，其中包含有两组赤经和赤纬坐标：第一组赤经是1.5度，赤纬是3.5度；第二组赤经是2.5度，赤纬是4.5度，并返回这个坐标对象。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.coordinates import ICRS\n    from astropy import units as u\n    coo = ICRS(ra=[1.5, 2.5]*u.deg, dec=[3.5, 4.5]*u.deg)  \n    return coo\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 64,
        "prompt_en": "Create an FK5 coordinate frame object based on the equinox of 1975.",
        "prompt_zh": "创建一个基于1975年春分点的FK5坐标框架对象。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.coordinates import FK5\n  frame = FK5(equinox='J1975')\n  return frame\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 65,
        "prompt_en": "Convert the ICRS astronomical coordinates with right ascension of 1.1 degrees and declination of 2.2 degrees to an hour representation of right ascension, and return its value.",
        "prompt_zh": "将赤经1.1度、赤纬2.2度的ICRS天文坐标转换为赤经的小时表示，并返回其值。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.coordinates import ICRS\n  from astropy import units as u\n  coo = ICRS(ra=1.1*u.deg, dec=2.2*u.deg)\n  return coo.ra.hour\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查两个浮点数是否近似相等\n    return np.isclose(data1, data2, atol=1e-8)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 66,
        "prompt_en": "Create an ICRS celestial coordinate object represented in the Cartesian coordinate system with coordinate values x=1 kiloparsec, y=2 kiloparsec, z=3 kiloparsec. Return the Cartesian representation of this coordinate object.",
        "prompt_zh": "创建一个以笛卡尔坐标系表示的ICRS天体坐标对象，坐标值为x=1千帕赛克，y=2千帕赛克，z=3千帕赛克，并返回这个坐标对象的笛卡尔表示。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.coordinates import CartesianRepresentation, ICRS\n  from astropy import units as u\n  icrs = ICRS(x=1*u.kpc, y=2*u.kpc, z=3*u.kpc, representation_type='cartesian')\n  return icrs.represent_as('cartesian')\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n  if not np.allclose(data1.xyz, data2.xyz, atol=1e-8):\n     return False\n  return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 67,
        "prompt_en": "Create a spherical coordinate representation with a longitude of 1.1 degrees, a latitude of 2.2 degrees, and a distance of 3.3 kiloparsecs. Represent this position in the FK5 coordinate frame with an equinox of J1975. Return the created FK5 coordinate frame object.",
        "prompt_zh": "创建一个球坐标表示，其中经度为1.1度，纬度为2.2度，距离为3.3千帕赛克，并以1975年的历元在FK5坐标框架下表示这个位置。返回创建的FK5坐标框架对象。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.coordinates import SphericalRepresentation, FK5\n  from astropy import units as u\n  rep = SphericalRepresentation(lon=1.1*u.deg, lat=2.2*u.deg, distance=3.3*u.kpc)\n  frame = FK5(rep, equinox='J1975')\n  return frame\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 68,
        "prompt_en": "Transform an astronomical coordinate represented in the ICRS frame (right ascension 1.5 degrees, declination 2.5 degrees) to the FK5 frame using the epoch of 1975.",
        "prompt_zh": "将一个以ICRS坐标系表示的天文坐标（右升交点1.5度、赤纬2.5度）转换到FK5坐标系下，使用的历元为1975年。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.coordinates import ICRS, FK5\n  from astropy import units as u\n  cooi = ICRS(1.5*u.deg, 2.5*u.deg)\n  fk5_frame = FK5(equinox='J1975')\n  return cooi.transform_to(fk5_frame)\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 69,
        "prompt_en": "Set the default version of the Galactocentric frame parameters in the Astropy library to the pre-version 4.0, and create a Galactocentric coordinate object with a galactic center distance of 8.0 kiloparsecs.",
        "prompt_zh": "在Astropy库中设置Galactocentric坐标系参数的默认版本为4.0之前的版本，并创建一个银河系中心坐标系对象，设置银心距离为8.0千帕赛克。\n",
        "canonical_solution": "def canonical_solution():\n  import astropy.units as u\n  from astropy.coordinates import Galactocentric, galactocentric_frame_defaults\n  with galactocentric_frame_defaults.set('pre-v4.0'):\n    return Galactocentric(galcen_distance=8.0*u.kpc)\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 70,
        "prompt_en": "Create a Galactocentric object representing the coordinate system centered at the Milky Way's center.",
        "prompt_zh": "创建一个代表银河系中心坐标系的Galactocentric对象。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.coordinates import Galactocentric\n    return Galactocentric()\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 71,
        "prompt_en": "Create a Galactocentric coordinate frame using version 4.0 default parameters in the Astropy library.",
        "prompt_zh": "创建一个使用Astropy库的v4.0版本默认参数的Galactocentric坐标框架。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.coordinates import Galactocentric, galactocentric_frame_defaults\n    _ = galactocentric_frame_defaults.set('v4.0')\n    return Galactocentric() \n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 72,
        "prompt_en": "Get the celestial coordinates of an object in the ICRS coordinate system with a right ascension of 10.625 degrees and a declination of 41.2 degrees. Return the right ascension in hours, the right ascension in hours-minutes-seconds, and the declination in degrees and radians.",
        "prompt_zh": "获取一个在ICRS坐标系中，赤经为10.625度、赤纬为41.2度的天体坐标，返回赤经的小时表示、赤经的时分秒表示以及赤纬的度和弧度表示。",
        "canonical_solution": "def canonical_solution():\n  from astropy.coordinates import SkyCoord\n  from astropy import units as u\n  c = SkyCoord(ra=10.625*u.degree, dec=41.2*u.degree, frame='icrs')\n  return c.ra.hour, c.ra.hms, c.dec.degree, c.dec.radian\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查两个浮点数是否近似相等\n    return np.isclose(data1, data2, atol=1e-8)\n\n",
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n",
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查两个浮点数是否近似相等\n    return np.isclose(data1, data2, atol=1e-8)\n\n",
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查两个浮点数是否近似相等\n    return np.isclose(data1, data2, atol=1e-8)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 73,
        "prompt_en": "Translate the celestial coordinates with a right ascension of 10.68458 degrees and a declination of 41.26917 degrees into the format of hours, minutes, seconds for right ascension and degrees, minutes, seconds for declination. Return the formatted result.",
        "prompt_zh": "将赤经10.68458度和赤纬41.26917度的天体坐标转换为小时、分、秒和度、分、秒的格式。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.coordinates import SkyCoord\n  from astropy import units as u\n  c = SkyCoord(ra=10.68458*u.degree, dec=41.26917*u.degree)\n  return c.to_string('hmsdms')\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 74,
        "prompt_en": "Transform the celestial coordinates 1h12m43.2s, +1d12m43s from the FK5 coordinate system at the J2000 epoch to the FK5 coordinate system at the J2005.2 epoch and output the result as a string in hours, minutes, and seconds format.",
        "prompt_zh": "将天体坐标1时12分43.2秒，+1度12分43秒从J2000历元的FK5坐标系转换到J2005.2历元的FK5坐标系，并输出为时分秒格式的字符串。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.coordinates import SkyCoord, FK5\n  from astropy.time import Time\n  from astropy import units as u\n  coord = SkyCoord('1h12m43.2s +1d12m43s', frame=FK5, equinox=Time('J2000'))\n  new_coord = coord.transform_to(FK5(equinox=Time('J2005.2')))\n  return new_coord.to_string('hmsdms')\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 75,
        "prompt_en": "Convert the right ascension of a celestial coordinate with a right ascension of 10.625 degrees and declination of 41.2 degrees in the ICRS coordinate system to an hour unit and return the result.",
        "prompt_zh": "将icrs坐标系下赤经为10.625度，赤纬为41.2度的天体坐标转换为小时单位的赤经值并返回。",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n    from astropy.coordinates import SkyCoord\n    c = SkyCoord(ra=10.625*u.degree, dec=41.2*u.degree, frame='icrs')\n    return c.ra.hour\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查两个浮点数是否近似相等\n    return np.isclose(data1, data2, atol=1e-8)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 76,
        "prompt_en": "Create an astronomical coordinate object with right ascension of 10.625 degrees and declination of 41.2 degrees in the International Celestial Reference System (ICRS) and convert the coordinates to a string in decimal form.",
        "prompt_zh": "创建一个赤经为10.625度，赤纬为41.2度，在国际天体参考框架（ICRS）下的天体坐标对象，并将该坐标转换为十进制形式的字符串。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n    from astropy.coordinates import SkyCoord\n    c = SkyCoord(ra=10.625*u.degree, dec=41.2*u.degree, frame='icrs')\n    return c.to_string('decimal')\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 77,
        "prompt_en": "Create a SkyCoord object containing four celestial coordinates with right ascensions of [10, 11, 12, 13] degrees and declinations of [41, -5, 42, 0] degrees. Then, rotate all the coordinates forward by one position and return the updated list of coordinates.",
        "prompt_zh": "创建一个包含四个天体坐标的SkyCoord对象，天体赤经为[10, 11, 12, 13]度，赤纬为[41, -5, 42, 0]度，然后循环向前移动各个坐标一位，并返回更新后的坐标列表。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n    from astropy.coordinates import SkyCoord\n    import numpy as np\n    c = SkyCoord(ra=[10, 11, 12, 13]*u.degree, dec=[41, -5, 42, 0]*u.degree)\n    np.roll(c, 1)\n    return c\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 78,
        "prompt_en": "Calculate the angular separation distance between a celestial object with right ascension of 10 degrees and declination of 9 degrees in the ICRS coordinate system and a celestial object with right ascension of 11 degrees and declination of 10 degrees in the FK5 coordinate system. Return the separation distance.",
        "prompt_zh": "计算在ICRS坐标系下赤经为10度、赤纬为9度的天体与在FK5坐标系下赤经为11度、赤纬为10度的天体之间的角分离距离。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n    from astropy.coordinates import SkyCoord\n    c1 = SkyCoord(ra=10*u.degree, dec=9*u.degree, frame='icrs')\n    c2 = SkyCoord(ra=11*u.degree, dec=10*u.degree, frame='fk5')\n    return c1.separation(c2)\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 79,
        "prompt_en": "Create a SkyCoord object representing the celestial position in the ICRS coordinate system with a right ascension of 10.68458 degrees and a declination of 41.26917 degrees. Return the right ascension part of this position expressed in hours.",
        "prompt_zh": "创建一个表示ICRS坐标系下赤经为10.68458度、赤纬为41.26917度的天体位置的SkyCoord对象，并返回该位置的赤经以小时表示的部分。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n    from astropy.coordinates import SkyCoord\n    c = SkyCoord(ra=10.68458*u.degree, dec=41.26917*u.degree, frame='icrs')\n    return c.ra.hms\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查两个浮点数是否近似相等\n    return np.isclose(data1, data2, atol=1e-8)\n\n",
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查两个浮点数是否近似相等\n    return np.isclose(data1, data2, atol=1e-8)\n\n",
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查两个浮点数是否近似相等\n    return np.isclose(data1, data2, atol=1e-8)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 80,
        "prompt_en": "Update a set of celestial coordinates: change the longitude of the original coordinates [1 degree, 3 degrees] and [2 degrees, 4 degrees] to [10 degrees, 20 degrees] and change the latitude of the second coordinate point to 40 degrees. Then return the updated set of coordinates.",
        "prompt_zh": "更新一组天球坐标的值：将原本坐标【1度, 3度】和【2度, 4度】的经纬度，更改经度为【10度, 20度】并将第二个坐标点的纬度更改为40度，然后返回更新后的坐标集合。\n",
        "canonical_solution": "def canonical_solution():\n    import astropy.units as u\n    from astropy.coordinates import SkyCoord\n    sc = SkyCoord([1,2],[3,4], unit='deg')\n    sc.data.lon[()] = [10, 20] * u.deg\n    sc.data.lat[1] = 40 * u.deg\n    sc.cache.clear()\n    return sc\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 81,
        "prompt_en": "Calculate and return the spherical offsets in right ascension and declination, in arcseconds, for an astronomical object from the coordinates '8h50m59.75s', '+11d39m22.15s' to the coordinates '8h50m47.92s', '+11d39m32.74s'.",
        "prompt_zh": "计算并返回一个天体从坐标'8h50m59.75s', '+11d39m22.15s'到坐标'8h50m47.92s', '+11d39m32.74s'的赤经和赤纬球面偏移量，单位为角秒。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.coordinates import SkyCoord\n  import astropy.units as u\n  c = SkyCoord('8h50m59.75s', '+11d39m22.15s', frame='icrs')\n  catalog = SkyCoord('8h50m47.92s', '+11d39m32.74s', frame='icrs')\n  dra, ddec = c.spherical_offsets_to(catalog)\n  return dra.arcsec, ddec.arcsec\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查两个浮点数是否近似相等\n    return np.isclose(data1, data2, atol=1e-8)\n\n",
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查两个浮点数是否近似相等\n    return np.isclose(data1, data2, atol=1e-8)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 82,
        "prompt_en": "Calculate the spherical offsets between two coordinate positions and return the results in arcseconds. The first coordinate is a bright star located at right ascension '8h50m59.75s' and declination '+11d39m22.15s'. The second coordinate is a faint galaxy located at right ascension '8h50m47.92s' and declination '+11d39m32.74s'. Both are defined in the International Celestial Reference System (ICRS).",
        "prompt_zh": "计算两个坐标位置之间的球面偏移量，并以角秒为单位返回结果。第一个坐标是明亮的恒星，位于赤经'8h50m59.75s'、赤纬'+11d39m22.15s'，第二个坐标是暗淡的星系，位于赤经'8h50m47.92s'、赤纬'+11d39m32.74s'。两者都在国际天文参考框架(ICRS)下定义。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.coordinates import SkyCoord\n    import astropy.units as u\n    bright_star = SkyCoord('8h50m59.75s', '+11d39m22.15s', frame='icrs')\n    faint_galaxy = SkyCoord('8h50m47.92s', '+11d39m32.74s', frame='icrs')\n    dra, ddec = bright_star.spherical_offsets_to(faint_galaxy)\n    return dra.to(u.arcsec), ddec.to(u.arcsec)\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n",
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 83,
        "prompt_en": "Calculate the three-dimensional spatial distance between the celestial coordinate points (5h23m34.5s, -69d45m22s, distance of 70 kiloparsecs) and (0h52m44.8s, -72d49m43s, distance of 80 kiloparsecs) in the International Celestial Reference System (ICRS). Return the result in kiloparsecs.",
        "prompt_zh": "计算天体坐标点(5小时23分34.5秒,-69度45分22秒, 距离70千帕赛克)和(0小时52分44.8秒,-72度49分43秒, 距离80千帕赛克)在国际天文参考坐标系中的三维空间距离，并以千帕赛克为单位。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.coordinates import SkyCoord\n    import astropy.units as u\n    c1 = SkyCoord('5h23m34.5s', '-69d45m22s', distance=70*u.kpc, frame='icrs')\n    c2 = SkyCoord('0h52m44.8s', '-72d49m43s', distance=80*u.kpc, frame='icrs')\n    sep = c1.separation_3d(c2)\n    return sep.kpc  # assuming we want the 3d separation in kiloparsecs\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查两个浮点数是否近似相等\n    return np.isclose(data1, data2, atol=1e-8)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 84,
        "prompt_en": "Calculate the position angle between two points with coordinates (1 degree, 1 degree) and (2 degrees, 2 degrees) in the ICRS reference frame. Return the result in degrees.",
        "prompt_zh": "计算处于ICRS参考框架中坐标(1度, 1度)与坐标(2度, 2度)两点的位置角，并将结果以度为单位返回。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.coordinates import SkyCoord\n    import astropy.units as u\n    c1 = SkyCoord(1*u.deg, 1*u.deg, frame='icrs')\n    c2 = SkyCoord(2*u.deg, 2*u.deg, frame='icrs')\n    position_angle = c1.position_angle(c2).to(u.deg)\n    return position_angle.value  # assuming we want the position angle in degrees\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查两个浮点数是否近似相等\n    return np.isclose(data1, data2, atol=1e-8)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 85,
        "prompt_en": "Calculate the angular separation distance between a celestial object at RA '5h23m34.5s', Dec '-69d45m22s' in the ICRS coordinate system, and another celestial object at RA '0h52m44.8s', Dec '-72d49m43s' in the FK5 coordinate system.",
        "prompt_zh": "计算ICRS坐标系下位置为'5h23m34.5s'赤经，'-69d45m22s'赤纬的天体与FK5坐标系下位置为'0h52m44.8s'赤经，'-72d49m43s'赤纬的天体之间的角分离距离。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.coordinates import SkyCoord\n    import astropy.units as u\n    c1 = SkyCoord('5h23m34.5s', '-69d45m22s', frame='icrs')\n    c2 = SkyCoord('0h52m44.8s', '-72d49m43s', frame='fk5')\n    sep = c1.separation(c2)\n    return sep\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 86,
        "prompt_en": "Calculate the position angle between two coordinates in the ICRS frame from (1 degree, 1 degree) to (2 degrees, 2 degrees), and output the result in degrees.",
        "prompt_zh": "计算两个坐标在ICRS框架中从(1度, 1度)到(2度, 2度)的位置角，并将结果输出为度单位。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.coordinates import SkyCoord\n    import astropy.units as u\n    c1 = SkyCoord(1*u.deg, 1*u.deg, frame='icrs')\n    c2 = SkyCoord(2*u.deg, 2*u.deg, frame='icrs')\n    pa = c1.position_angle(c2).to(u.deg)\n    return pa\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 87,
        "prompt_en": "Calculate the new celestial coordinates after moving 1.414 degrees angular distance along a position angle of 45 degrees, starting from 1 degree Right Ascension and 1 degree Declination (ICRS coordinate system).",
        "prompt_zh": "计算从赤经1度、赤纬1度（ICRS坐标系）出发，沿着45度位置角，移动1.414度角距离的新天球坐标。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.coordinates import SkyCoord\n    import astropy.units as u\n    c1 = SkyCoord(1*u.deg, 1*u.deg, frame='icrs')\n    position_angle = 45 * u.deg\n    separation = 1.414 * u.deg\n    new_coord = c1.directional_offset_by(position_angle, separation)\n    return new_coord\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 88,
        "prompt_en": "Calculate the midpoint coordinates between two celestial objects located at (0°, 0°) and (1°, 1°) in the ICRS coordinate system.",
        "prompt_zh": "计算坐标为ICRS系统下(0°, 0°)和(1°, 1°)的两个天体之间的中点坐标。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.coordinates import SkyCoord\n    import astropy.units as u\n    coord1 = SkyCoord(0*u.deg, 0*u.deg, frame='icrs')\n    coord2 = SkyCoord(1*u.deg, 1*u.deg, frame='icrs')\n    pa = coord1.position_angle(coord2)\n    sep = coord1.separation(coord2)\n    midpoint = coord1.directional_offset_by(pa, sep/2)\n    return midpoint\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 89,
        "prompt_en": "Retrieve the spatial coordinates of the pulsar PSR J1012+5307.",
        "prompt_zh": "获取脉冲星PSR J1012+5307的空间坐标。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.coordinates import SkyCoord\n    return SkyCoord.from_name(\"PSR J1012+5307\")\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 90,
        "prompt_en": "Retrieve the Earth geographic location of the Apache Point Observatory astronomical station.",
        "prompt_zh": "获取Apache Point Observatory天文观测站的地球地理位置。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.coordinates import EarthLocation\n    return EarthLocation.of_site('Apache Point Observatory')\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    return data1==data2"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 91,
        "prompt_en": "Retrieve the geographical location coordinates of the Kitt Peak astronomical observation site.",
        "prompt_zh": "获取Kitt Peak天文观测站点的地理位置坐标。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.coordinates import EarthLocation\n    loc = EarthLocation.of_site('Kitt Peak')\n    return loc\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    return data1==data2"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 92,
        "prompt_en": "Create an EarthLocation object with the geocentric Cartesian coordinates set to X: -1994502.6043061386 meters, Y: -5037538.54232911 meters, Z: 3358104.9969029757 meters.",
        "prompt_zh": "创建一个EarthLocation对象，将地心笛卡尔坐标设置为X: -1994502.6043061386米，Y: -5037538.54232911米，Z: 3358104.9969029757米。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.coordinates import EarthLocation\n    return EarthLocation(-1994502.6043061386, -5037538.54232911, 3358104.9969029757, unit='m')\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    return data1==data2"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 93,
        "prompt_en": "Create a Cartesian representation with the position set to x=1 kiloparsec (kpc), y=2 kiloparsecs (kpc), and z=3 kiloparsecs (kpc), and assign a velocity differential to this point, with the velocity vector being 1 kilometer/second, 2 kilometers/second, and 3 kilometers/second. Output the final Cartesian representation result.",
        "prompt_zh": "创建一个笛卡尔坐标表示，位置设定为x=1千帕色克(kpc)，y=2千帕色克(kpc)，z=3千帕色克(kpc)，同时为该点配置速度差分，其速度向量为1千米/秒、2千米/秒、3千米/秒，并输出最终的笛卡尔表示结果。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n    from astropy.coordinates import CartesianRepresentation\n    from astropy.coordinates import CartesianDifferential\n    car_rep = CartesianRepresentation(x=1 * u.kpc, y=2 * u.kpc, z=3 * u.kpc)\n    car_dif = CartesianDifferential(*[1, 2, 3] * u.km/u.s)\n    car_rep = car_rep.with_differentials(car_dif)\n    return car_rep\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n  if not np.allclose(data1.xyz, data2.xyz, atol=1e-8):\n     return False\n  return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 94,
        "prompt_en": "Create an object represented in Cartesian coordinates with coordinates (3 kiloparsecs, 5 kiloparsecs, 4 kiloparsecs).",
        "prompt_zh": "创建一个笛卡尔坐标表示的对象，其坐标为（3千帕赛克，5千帕赛克，4千帕赛克）。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n    from astropy.coordinates.representation import CartesianRepresentation\n    car = CartesianRepresentation(3 * u.kpc, 5 * u.kpc, 4 * u.kpc)\n    return car\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n  if not np.allclose(data1.xyz, data2.xyz, atol=1e-8):\n     return False\n  return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 95,
        "prompt_en": "Create an array of Cartesian coordinates with the x-axis ranging continuously from 0 meters to 5 meters at 6 points, the y-axis from 10 meters to 15 meters at 6 points, and the z-axis from 20 meters to 25 meters at 6 points. Then circularly shift the array by one position.",
        "prompt_zh": "创建一个笛卡尔坐标系数组，x轴从0米到5米连续6个点，y轴从10米到15米连续6个点，z轴从20米到25米连续6个点，并将这个数组循环移动一位。\n",
        "canonical_solution": "def canonical_solution():\n    import numpy as np\n    from astropy import units as u\n    from astropy.coordinates.representation import CartesianRepresentation\n    x = np.linspace(0., 5., 6)\n    y = np.linspace(10., 15., 6)\n    z = np.linspace(20., 25., 6)\n    car_array = CartesianRepresentation(x * u.m, y * u.m, z * u.m)\n    return np.roll(car_array, 1)\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n  if not np.allclose(data1.xyz, data2.xyz, atol=1e-8):\n     return False\n  return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 96,
        "prompt_en": "Add the coordinates of two points in 3D space, measured in meters, where the first point's coordinates are (1, 0, 0) and (3, 5, 3), the second point's coordinates are (0, 2, 0) and (4, 0, -4), and the third point's coordinates are (0, 0, 3) and (0, 12, -12). Return the Cartesian representation of the total sum.",
        "prompt_zh": "在3D空间中以米为单位将两个点的坐标相加，其中第一个点的坐标是(1, 0, 0)和(3, 5, 3)，第二个点的坐标是(0, 2, 0)和(4, 0, -4)，第三个点的坐标是(0, 0, 3)和(0, 12, -12)，并返回总和的笛卡尔表示。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy import units as u\n  from astropy.coordinates import CartesianRepresentation\n  car_array = CartesianRepresentation([[1., 0., 0.], [3., 5.,  3.]] * u.m,\n                                      [[0., 2., 0.], [4., 0., -4.]] * u.m,\n                                      [[0., 0., 3.], [0.,12.,-12.]] * u.m)\n  return car_array.sum()\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n  if not np.allclose(data1.xyz, data2.xyz, atol=1e-8):\n     return False\n  return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 97,
        "prompt_en": "Create a spherical coordinate with a longitude of 0 degrees, latitude of 0 degrees, and a distance of 1 kiloparsec. Then, calculate the new position after 1 year, assuming the longitude changes by 1 arcsecond per year, while latitude and distance remain constant.",
        "prompt_zh": "创建一个球面坐标，其经度为0度，纬度为0度，距离为1千帕斯卡。然后根据经度每年变化1角秒，纬度和距离不变的情况，计算1年后的新位置。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy import units as u\n  from astropy.coordinates import SphericalRepresentation, SphericalDifferential\n  sph_coo = SphericalRepresentation(lon=0.*u.deg, lat=0.*u.deg, distance=1.*u.kpc)\n  sph_derivative = SphericalDifferential(d_lon=1.*u.arcsec/u.yr,\n                                         d_lat=0.*u.arcsec/u.yr,\n                                         d_distance=0.*u.km/u.s)\n  new_pos = sph_coo + sph_derivative * 1. * u.yr\n  return new_pos\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 98,
        "prompt_en": "Convert the point (3 kpc, 5 kpc, 4 kpc) from Cartesian coordinates to spherical coordinates, and return the result.",
        "prompt_zh": "将笛卡尔坐标系下的点(3 kpc, 5 kpc, 4 kpc)转换为球面坐标系，并返回结果。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy import units as u\n  from astropy.coordinates.representation import CartesianRepresentation, SphericalRepresentation\n  car = CartesianRepresentation(3 * u.kpc, 5 * u.kpc, 4 * u.kpc)\n  sph = car.represent_as(SphericalRepresentation)\n  return sph\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 99,
        "prompt_en": "Convert a given set of Cartesian coordinates (in astronomical units) to unit vectors and return the results of the transformation. Specific coordinate points are [(1, 2, 3), (2, 3, 4), (3, 4, 5)] au.",
        "prompt_zh": "将一组给定的笛卡尔坐标（以天文单位为单位）转换为单位向量，并返回转换后的结果。具体坐标点为[(1, 2, 3), (2, 3, 4), (3, 4, 5)] au。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy import units as u\n  from astropy.coordinates.representation import CartesianRepresentation\n  x = [1, 2, 3] * u.au\n  y = [2, 3, 4] * u.au\n  z = [3, 4, 5] * u.au\n  car_array = CartesianRepresentation(x, y, z)\n  car_norm = car_array.norm()\n  car_normalized = car_array / car_norm\n  return car_normalized\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n  if not np.allclose(data1.xyz, data2.xyz, atol=1e-8):\n     return False\n  return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 100,
        "prompt_en": "Create a list of astronomical coordinates with initial coordinates at (1°, 3°) and (2°, 4°). Then update the first coordinate in the list to (10°, 20°). Return the updated list of coordinates.",
        "prompt_zh": "创建一个天文坐标列表，其初始坐标为(1°, 3°)和(2°, 4°)。然后将列表中的第一个坐标更新为(10°, 20°)。返回更新后的坐标列表。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n    from astropy.coordinates import SkyCoord\n    sc1 = SkyCoord([1, 2] * u.deg, [3, 4] * u.deg)\n    sc2 = SkyCoord(10 * u.deg, 20 * u.deg)\n    sc1[0] = sc2\n    return sc1\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 101,
        "prompt_en": "Create a set of 100 random right ascension and declination coordinates and convert them to radians suitable for Aitoff projection. The right ascension values should be between 0 and 360 degrees, and the declination values should be between -90 and 90 degrees. In the returned data, the right ascension values should be represented in Radian units, and wrap around at 180 degrees.",
        "prompt_zh": "创建一组100个随机赤经和赤纬坐标，并将其转换为适用于Aitoff投影的弧度形式。赤经的值应在0到360度之间，赤纬的值应在-90到90度之间。在返回的数据中，赤经值应该用Radian单位表示，并且在180度处折返。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.coordinates import SkyCoord\n    import astropy.units as u\n    import numpy as np\n    # Generate random data for RA and DEC\n    rng = np.random.default_rng()\n    ra_random = rng.uniform(0, 360, 100) * u.degree\n    dec_random = rng.uniform(-90, 90, 100) * u.degree\n    # Convert to SkyCoord object\n    c = SkyCoord(ra=ra_random, dec=dec_random, frame='icrs')\n    # Convert the coordinates to radians and wrap RA at 180 degrees for Aitoff projection\n    ra_rad = c.ra.wrap_at(180 * u.deg).radian\n    dec_rad = c.dec.radian\n    # Pack into a dictionary to return\n    return {'ra_rad': ra_rad, 'dec_rad': dec_rad}\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    # 检查两个字典的键是否完全相同\n    if data1.keys() != data2.keys():\n        return False\n\n    # 检查每个键对应的值是否相同\n    for key in data1:\n        # 可以这里添加递归比较的逻辑，如果值是复杂的数据结构\n        if not np.all(data1[key] == data2[key]):\n            return False\n    \n    # 如果所有检查都通过，则认为两个字典一致\n    return True\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 102,
        "prompt_en": "Generate random coordinates for a galaxy with disk and bulge distribution features, where the disk part contains 5000 sample points with mean values of 0 in x, y, z dimensions and covariances of 1, 1, 0.5 respectively, and the bulge part contains 500 sample points with mean values of 0 and covariances of 1 in x, y, z dimensions. Concatenate the data from the disk and the spherical cluster by the first dimension to form the simulated coordinates of the entire galaxy. Then, convert the model coordinates to celestial coordinates in the Galactic coordinate system and further convert them to the ICRS coordinate system. Finally, convert the Right Ascension (RA) in the ICRS coordinate system to radians with a boundary of 180 degrees, and also convert the Declination (Dec) to radians. Return the Right Ascension and Declination as a Python dictionary in the form {'ra_rad': ra_rad, 'dec_rad': dec_rad}.",
        "prompt_zh": "生成一个具有盘和核球分布特征的星系随机坐标，其中盘部分包含5000个样本点，x,y,z维度的均值均为0，协方差分别为1、1、0.5，核球部分包含500个样本点，x,y,z维度的均值均为0，协方差均为1，将盘面和球状星团的数据按第一维度拼接起来，形成整个星系的模拟坐标。随后，将模型坐标转换为银河坐标系的天球坐标，并将其进一步转换为ICRS坐标系。最后，将ICRS坐标系中的赤经（RA）转换为以180度为界限的弧度值，并将赤纬（Dec）也转换为弧度值，将赤经和赤纬以python dict的形式返回{'ra_rad': ra_rad, 'dec_rad': dec_rad}。",
        "canonical_solution": "def canonical_solution():\n    from astropy.coordinates import SkyCoord\n    import astropy.units as u\n    import numpy as np\n    # Generate random data for a galaxy with a disk and bulge\n    rng = np.random.default_rng()\n    disk = rng.multivariate_normal(mean=[0,0,0], cov=np.diag([1,1,0.5]), size=5000)\n    bulge = rng.multivariate_normal(mean=[0,0,0], cov=np.diag([1,1,1]), size=500)\n    galaxy = np.concatenate([disk, bulge])\n    \n    # Transform to SkyCoord with cartesian representation within the Galactic frame\n    c_gal = SkyCoord(galaxy, representation_type='cartesian', frame='galactic')\n    c_gal_icrs = c_gal.icrs\n    \n    # Convert the coordinates to radians for plotting\n    ra_rad = c_gal_icrs.ra.wrap_at(180 * u.deg).radian\n    dec_rad = c_gal_icrs.dec.radian\n    # Pack into a dictionary to return\n    return {'ra_rad': ra_rad, 'dec_rad': dec_rad}\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    # 检查两个字典的键是否完全相同\n    if data1.keys() != data2.keys():\n        return False\n\n    # 检查每个键对应的值是否相同\n    for key in data1:\n        # 可以这里添加递归比较的逻辑，如果值是复杂的数据结构\n        if not np.all(data1[key] == data2[key]):\n            return False\n    \n    # 如果所有检查都通过，则认为两个字典一致\n    return True\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 103,
        "prompt_en": "Retrieve the lunar coordinates on September 22, 2014, at 23:22, as observed from the Royal Observatory, Greenwich.",
        "prompt_zh": "获取2014年9月22日23时22分位于格林威治天文台的月球坐标位置。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.time import Time\n    from astropy.coordinates import EarthLocation, get_body\n    t = Time(\"2014-09-22 23:22\")\n    loc = EarthLocation.of_site('greenwich')\n    return get_body('moon', t, loc)\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 104,
        "prompt_en": " Set Astropy's solar_system_ephemeris to use the built-in solar system ephemeris data and return a list of all known objects in the solar system.",
        "prompt_zh": "设置Astropy的solar_system_ephemeris使用内建的太阳系星历数据，并返回太阳系中所有已知天体的列表。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.coordinates import solar_system_ephemeris\n    solar_system_ephemeris.set('builtin')\n    return solar_system_ephemeris.bodies\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n",
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n",
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n",
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n",
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n",
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n",
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n",
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n",
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n",
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n",
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 105,
        "prompt_en": "Retrieve the astronomical coordinates of Jupiter for the specified time \"2014-09-22 23:22\" and location \"greenwich\" (the Royal Observatory Greenwich).",
        "prompt_zh": "获取指定时间\"2014-09-22 23:22\"和地点\"greenwich\"（格林威治天文台）下木星的天文坐标。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.time import Time\n  from astropy.coordinates import solar_system_ephemeris, EarthLocation\n  from astropy.coordinates import get_body\n  t = Time(\"2014-09-22 23:22\")\n  loc = EarthLocation.of_site('greenwich')\n  with solar_system_ephemeris.set('builtin'):\n    jup = get_body('jupiter', t, loc)\n  return jup\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 106,
        "prompt_en": "Retrieve the position of the Moon in the solar system barycentric coordinate system at 23:22 on September 22, 2014.",
        "prompt_zh": "获取2014年9月22日23点22分月球在太阳系质心坐标系中的位置。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.time import Time\n  from astropy.coordinates import get_body_barycentric\n  t = Time(\"2014-09-22 23:22\")\n  moon_bary = get_body_barycentric('moon', t)\n  return moon_bary\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n  if not np.allclose(data1.xyz, data2.xyz, atol=1e-8):\n     return False\n  return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 107,
        "prompt_en": "Convert the frequency with a value of 34.2 GHz to terahertz units and return the conversion result.",
        "prompt_zh": "将数值为34.2 GHz的频率转换为太赫兹单位，并返回转换结果。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n    from astropy.coordinates import SpectralCoord\n    sc1 = SpectralCoord(34.2, unit='GHz')\n    sc1_rest = sc1.to(u.THz)\n    return sc1_rest\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n  if data1.unit!=data2.unit:\n     return False\n  if not np.allclose(data1.value, data2.value, atol=1e-8):\n     return False\n  return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 108,
        "prompt_en": "Convert the frequency of 343 GHz to a velocity unit (kilometers per second) using the doppler convention in radio astronomy, assuming a rest frequency of 342.91 GHz.",
        "prompt_zh": "将频率343 GHz使用射电天文中的都普勒常规（doppler_convention）转换为速度单位（千米/秒），其中静止频率设定为342.91 GHz。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n    from astropy.coordinates import SpectralCoord\n    sc4 = SpectralCoord(343 * u.GHz, doppler_convention='radio', doppler_rest=342.91 * u.GHz)\n    return sc4.to(u.km / u.s)\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n  if data1.unit!=data2.unit:\n     return False\n  if not np.allclose(data1.value, data2.value, atol=1e-8):\n     return False\n  return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 109,
        "prompt_en": "Create an array of 9 spectral coordinate values evenly spaced between 500 nm and 900 nm at redshift 0.5, and convert them to their corresponding values in the cosmic rest frame.",
        "prompt_zh": "创建一个在红移0.5下，介于500纳米和900纳米间等距排列的9个光谱坐标值的数组，并转换为它们在宇宙静止参考系下的对应值。\n",
        "canonical_solution": "def canonical_solution():\n    import numpy as np\n    from astropy import units as u\n    from astropy.coordinates import SpectralCoord\n    wavs = SpectralCoord(np.linspace(500, 900, 9) * u.nm, redshift=0.5)\n    wavs_rest = wavs.to_rest()\n    return wavs_rest\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n  if data1.unit!=data2.unit:\n     return False\n  if not np.allclose(data1.value, data2.value, atol=1e-8):\n     return False\n  return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 110,
        "prompt_en": "Create a `SpectralCoord` object with a frequency of 34.2 GHz.",
        "prompt_zh": "创建一个表示频率为34.2 GHz的SpectralCoord对象。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n    from astropy.coordinates import SpectralCoord\n    sc1 = SpectralCoord(34.2, unit='GHz')\n    return sc1\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n  if data1.unit!=data2.unit:\n     return False\n  if not np.allclose(data1.value, data2.value, atol=1e-8):\n     return False\n  return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 111,
        "prompt_en": "Convert the wavelength array [654.2, 654.4, 654.6] nanometers to micrometers.",
        "prompt_zh": "将波长数组[654.2, 654.4, 654.6]纳米转换为微米单位。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n    from astropy.coordinates import SpectralCoord\n    sc2 = SpectralCoord([654.2, 654.4, 654.6] * u.nm)\n    return sc2.to(u.micron)\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n  if data1.unit!=data2.unit:\n     return False\n  if not np.allclose(data1.value, data2.value, atol=1e-8):\n     return False\n  return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 112,
        "prompt_en": "Convert the spectral data with wavelengths of 654.2, 654.4, 654.6 nanometers into a velocity representation based on the optical Doppler effect, using 656.65 nanometers as the rest reference wavelength. Express the results in units of kilometers per second.",
        "prompt_zh": "将波长为654.2, 654.4, 654.6纳米的光谱数据转换为基于光学多普勒效应的速度表示，使用656.65纳米作为静止参考波长，并将结果单位换算为千米每秒。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n    from astropy.coordinates import SpectralCoord\n    sc3 = SpectralCoord([654.2, 654.4, 654.6] * u.nm,\n                        doppler_convention='optical',\n                        doppler_rest=656.65 * u.nm)\n    return sc3.to(u.km / u.s)\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n  if data1.unit!=data2.unit:\n     return False\n  if not np.allclose(data1.value, data2.value, atol=1e-8):\n     return False\n  return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 113,
        "prompt_en": "Convert the spectral coordinates of a frequency of 34.2 GHz to the corresponding wavelength in micrometers.",
        "prompt_zh": "将频率为34.2 GHz的频谱坐标转换为对应的微米单位波长。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.coordinates import SpectralCoord\n    from astropy import units as u\n    sc1 = SpectralCoord(34.2, unit='GHz')\n    return sc1.to(u.micron)\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n  if data1.unit!=data2.unit:\n     return False\n  if not np.allclose(data1.value, data2.value, atol=1e-8):\n     return False\n  return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 114,
        "prompt_en": "Convert the wavelength values of 654.2 nm, 654.4 nm, and 654.6 nm to the corresponding energy units in electron volts (eV).",
        "prompt_zh": "将波长值654.2纳米、654.4纳米以及654.6纳米转换为对应的能量单位电子伏特（eV）。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.coordinates import SpectralCoord\n    from astropy import units as u\n    sc2 = SpectralCoord([654.2, 654.4, 654.6] * u.nm)\n    return sc2.to(u.eV)\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n  if data1.unit!=data2.unit:\n     return False\n  if not np.allclose(data1.value, data2.value, atol=1e-8):\n     return False\n  return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 115,
        "prompt_en": "Create a StokesCoord object with Stokes parameters I, Q, U, and V values of 1, 2, 3, and 4, respectively, and return this object.",
        "prompt_zh": "创建一个含有Stokes参数I, Q, U, V分别为1, 2, 3, 4的StokesCoord对象，并返回此对象。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.coordinates import StokesCoord\n  return StokesCoord([1, 2, 3, 4])\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 116,
        "prompt_en": "Retrieve the Stokes parameter numbers and corresponding symbol list for the polarization states used in the FITS format file.",
        "prompt_zh": "获取FITS格式文件中使用的偏振状态的Stokes参数编号和对应的符号列表。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.coordinates.polarization import FITS_STOKES_VALUE_SYMBOL_MAP\n    return [(number, symbol.symbol) for number, symbol in FITS_STOKES_VALUE_SYMBOL_MAP.items()]\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 比较列表长度和元素内容\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 117,
        "prompt_en": "Create a Stokes coordinate object with the parameter value for I (total unpolarized radiation intensity) set to 1 and the parameter value for Q (one of the components of the linearly polarized radiation) set to 10.",
        "prompt_zh": "创建一个斯托克斯坐标对象，其I（完全未极化的辐射强度）参数值为1，Q（辐射的线性极化组分之一）参数值为10。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.coordinates import StokesCoord\n    return StokesCoord([1, 10])\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 118,
        "prompt_en": "Extract and return the mapping dictionary of Stokes parameter values and symbols built into Astropy's FITS module.",
        "prompt_zh": "提取并返回Astropy中内置的FITS斯托克斯参数值与符号的映射字典。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.coordinates import StokesCoord\n    from astropy.coordinates.polarization import FITS_STOKES_VALUE_SYMBOL_MAP\n    built_in_symbols = {number: symbol.symbol for number, symbol in FITS_STOKES_VALUE_SYMBOL_MAP.items()}\n    return built_in_symbols\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    # 检查两个字典的键是否完全相同\n    if data1.keys() != data2.keys():\n        return False\n\n    # 检查每个键对应的值是否相同\n    for key in data1:\n        # 可以这里添加递归比较的逻辑，如果值是复杂的数据结构\n        if not np.all(data1[key] == data2[key]):\n            return False\n    \n    # 如果所有检查都通过，则认为两个字典一致\n    return True\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 119,
        "prompt_en": "Create a StokesCoord object representing the Stokes I parameter in astronomical polarization.",
        "prompt_zh": "创建一个表示天文极化中的Stokes I参数的StokesCoord对象。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.coordinates import StokesCoord\n  return StokesCoord(\"I\")\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 120,
        "prompt_en": "Create a Stokes parameters object that contains a list of specific values, and check whether the sign attribute of that object equals \"?\".",
        "prompt_zh": "创建一个包含特定值列表的斯托克斯参数对象，并检查该对象的符号属性是否等于\"?\"。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.coordinates import StokesCoord\n  stokes = StokesCoord([1, 2, 3, 4, 5, 6])\n  return stokes.symbol == \"?\"\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 121,
        "prompt_en": "Convert the celestial coordinate point (longitude of 0 degrees, latitude of 45 degrees) from the Galactic coordinate system to the FK5 coordinate system.",
        "prompt_zh": "将一个银河坐标系(Galactic)中的天体坐标点(经度为0度、纬度为45度)转换到FK5坐标系中。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.coordinates import SkyCoord\n  import astropy.units as u\n  gc = SkyCoord(l=0*u.degree, b=45*u.degree, frame='galactic')\n  return gc.transform_to('fk5')\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 122,
        "prompt_en": "Convert the celestial coordinates of an object located at 0 degrees Galactic longitude and 45 degrees Galactic latitude to the FK5 coordinate system and align with right ascension 1.0 degrees, declination 2.0 degrees, and epoch 'J1980.0'.",
        "prompt_zh": "将一个位于银河坐标系下银经为0度、银纬为45度的天体坐标转换为FK5坐标系并与赤经1.0度、赤纬2.0度、历元'J1980.0'对齐。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.coordinates import SkyCoord, FK5\n  import astropy.units as u\n  sc = SkyCoord(ra=1.0*u.deg, dec=2.0*u.deg, frame=FK5, equinox='J1980.0')\n  gc = SkyCoord(l=0*u.degree, b=45*u.degree, frame='galactic')\n  return gc.transform_to(sc)\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 123,
        "prompt_en": "Translate the celestial position represented by right ascension '02h31m49.09s' and declination '+89d15m50.8s' from the default FK5 coordinate system to the FK5 coordinate system with the epoch 'J2005'.",
        "prompt_zh": "将赤经'02h31m49.09s'和赤纬'+89d15m50.8s'表示的天体位置从默认的FK5坐标系转换到历元为'J2005'的FK5坐标系中。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.coordinates import SkyCoord, FK5\n  fk5c = SkyCoord('02h31m49.09s', '+89d15m50.8s', frame=FK5)\n  fk5_2005 = FK5(equinox='J2005')\n  return fk5c.transform_to(fk5_2005)\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 124,
        "prompt_en": "Convert the celestial object's position from the FK5 coordinate system at epoch J1970 to epoch J2000. The right ascension of the object is '02h31m49.09s', and the declination is '+89d15m50.8s'.",
        "prompt_zh": "将天体的FK5坐标系位置从历元J1970转换至历元J2000。天体的赤经为'02h31m49.09s'，赤纬为'+89d15m50.8s'。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.time import Time\n  from astropy.coordinates import SkyCoord, FK5\n  fk5c = SkyCoord('02h31m49.09s', '+89d15m50.8s', frame=FK5(equinox=Time('J1970')))\n  fk5_2000 = FK5(equinox=Time(2000, format='jyear'))\n  return fk5c.transform_to(fk5_2000)\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 125,
        "prompt_en": "Create an astronomical coordinate object representing 1 degree of right ascension, 2 degrees of declination, and a radial velocity of 20 kilometers per second. Return the astronomical coordinate object and its radial velocity.",
        "prompt_zh": "创建一个表示赤经1度、赤纬2度且径向速度为20千米/秒的天体坐标对象，返回天体坐标对象及其径向速度。",
        "canonical_solution": "def canonical_solution():\n  from astropy.coordinates import SkyCoord\n  import astropy.units as u\n  sc = SkyCoord(1*u.deg, 2*u.deg, radial_velocity=20*u.km/u.s)\n  return sc, sc.radial_velocity\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return np.all(data1 == data2)\n\n",
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 126,
        "prompt_en": "Create an ICRS coordinate object with right ascension of 1 degree and declination of 2 degrees, then add a radial velocity component of 500 km/s to the coordinate, and return the updated coordinate object.",
        "prompt_zh": "创建一个ICRS坐标对象，其赤经为1度，赤纬为2度，然后为该坐标添加500公里/秒的径向速度分量，并返回更新后的坐标对象。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.coordinates import ICRS, RadialDifferential\n    import astropy.units as u\n    \n    icrs_no_distance = ICRS(1 * u.deg, 2 * u.deg)\n    rv_to_add = RadialDifferential(500 * u.km / u.s)\n    data_with_rv = icrs_no_distance.data.with_differentials({'s':rv_to_add})\n    return icrs_no_distance.realize_frame(data_with_rv)\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 127,
        "prompt_en": "Calculate the radial velocity correction for a celestial object on June 4, 2016, relative to the solar system barycenter with Keck Observatory as the reference position. Convert the result to kilometers per second. The observatory's location is at a latitude of 19.8283 degrees, a longitude of -155.4783 degrees, and an altitude of 4160 meters. The celestial object has a right ascension of 4.88375 degrees and declination of 35.0436389 degrees.",
        "prompt_zh": "计算2016年6月4日某天体相对于以Keck天文台为参考位置的太阳系质心的径向速度校正值，并将结果转换为千米/秒单位。天文台位置为纬度19.8283度、经度-155.4783度、海拔4160米，天体的赤经为4.88375度、赤纬为35.0436389度。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.coordinates import SkyCoord, EarthLocation\n    from astropy.time import Time\n    import astropy.units as u\n\n    # 假设没有互联网，因此手动输入Keck天文台位置\n    keck = EarthLocation.from_geodetic(lat=19.8283 * u.deg, lon=-155.4783 * u.deg, height=4160 * u.m)\n    sc = SkyCoord(ra=4.88375 * u.deg, dec=35.0436389 * u.deg)\n    barycorr = sc.radial_velocity_correction(obstime=Time('2016-6-4'), location=keck)\n    \n    return barycorr.to(u.km / u.s)\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 128,
        "prompt_en": "Create an astronomical coordinate object with a right ascension of 1 degree, a declination of 2 degrees, and a radial velocity of 20 kilometers per second. Return the radial velocity attribute of the object.",
        "prompt_zh": "创建一个赤经为1度、赤纬为2度和径向速度为20公里/秒的天文坐标对象，并返回该对象的径向速度属性。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.coordinates import SkyCoord\n  import astropy.units as u\n  sc = SkyCoord(1*u.deg, 2*u.deg, radial_velocity=20*u.km/u.s)\n  return sc.radial_velocity\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 129,
        "prompt_en": "Create a SkyCoord object with a right ascension of 1 degree and a declination of 2 degrees, including the proper motion of 0.2 milliarcseconds per year i  22178\n... MP_Mus XMM         0406030101\"\"\" and ensure that the data type of the observation ID (obsid) column is string. Return this table object.",
        "prompt_zh": "创建一个SkyCoord对象，设定其赤经为1度，赤纬为2度，并给出赤经方向的自行速度0.2毫角秒/年，赤纬方向的自行速度0.1毫角秒/年，然后将其转换为银河坐标系统并返回。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.coordinates import SkyCoord\n  import astropy.units as u\n  sc = SkyCoord(1*u.deg, 2*u.deg, pm_ra_cosdec=.2*u.mas/u.yr, pm_dec=.1*u.mas/u.yr)\n  return sc.galactic\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 130,
        "prompt_en": "Create an ICRS coordinate object and initialize its parameters: right ascension is 8.67 degrees, declination is 53.09 degrees, proper motion in right ascension multiplied by the cosine of declination is 4.8 milliarcseconds per year, and proper motion in declination is -15.16 milliarcseconds per year.",
        "prompt_zh": "创建一个ICRS坐标对象并初始化它的参数：赤经为8.67度，赤纬为53.09度，赤经的自行的余弦乘积为4.8毫角秒每年，赤纬的自行为-15.16毫角秒每年。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.coordinates import ICRS\n  import astropy.units as u\n  return ICRS(ra=8.67*u.degree, dec=53.09*u.degree,\n              pm_ra_cosdec=4.8*u.mas/u.yr, pm_dec=-15.16*u.mas/u.yr)\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 131,
        "prompt_en": "Set and retrieve the current default cosmological model to the Wilkinson Microwave Anisotropy Probe Year Nine (WMAP9) data.",
        "prompt_zh": "设置并获取当前默认的宇宙学模型为第九年Wilkinson Microwave Anisotropy Probe（WMAP9）数据。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.cosmology import default_cosmology\n    # 设置默认的宇宙学模型\n    default_cosmology.set('WMAP9')\n    # 获取当前的默认宇宙学模型\n    cosmo = default_cosmology.get()\n    \n    return cosmo\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n  if data1.name!=data2.name:\n     return False\n  if data1.H0!=data2.H0:\n     return False\n  if data1.Om0!=data2.Om0:\n     return False\n  if data1.Tcmb0!=data2.Tcmb0:\n     return False\n  if data1.Neff!=data2.Neff:\n     return False\n  if data1.m_nu.unit!=data2.m_nu.unit:\n     return False\n  if not np.allclose(data1.m_nu, data2.m_nu, atol=1e-8):\n     return False\n  if data1.Ob0!=data2.Ob0:\n     return False\n  if data1.meta!=data2.meta:\n     return False\n  return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 132,
        "prompt_en": "Using the Planck13 cosmological model, calculate the redshift value when the age of the universe is 2 billion years.",
        "prompt_zh": "使用Planck13宇宙学模型计算宇宙年龄为2千兆年时的红移值。\n",
        "canonical_solution": "def canonical_solution():\n    import astropy.units as u\n    from astropy.cosmology import Planck13, z_at_value\n    age_z2 = z_at_value(Planck13.age, 2 * u.Gyr)\n    return age_z2\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 133,
        "prompt_en": "Calculate the proper horizon distance corresponding to each arcminute at a redshift of 3 in the WMAP9 cosmological model, with the unit in kiloparsecs (kpc).",
        "prompt_zh": "计算在宇宙学模型WMAP9中，红移为3时每弧分对应的恒定视界距离，单位为千帕秒(kpc)。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.cosmology import WMAP9 as cosmo\n  return cosmo.kpc_proper_per_arcmin(3)\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 134,
        "prompt_en": "Calculate the comoving distances of celestial objects with redshift values of 0.5, 1.0, and 1.5 under the WMAP9 cosmological model.",
        "prompt_zh": "计算在WMAP9宇宙模型下红移值为0.5、1.0和1.5的天体的共动距离。\n",
        "canonical_solution": "def canonical_solution():\n  import numpy as np\n  from astropy.cosmology import WMAP9 as cosmo\n  return cosmo.comoving_distance(np.array([0.5, 1.0, 1.5]))\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 135,
        "prompt_en": "Create a ΛCDM model representing the universe with the Hubble parameter H0 set to 70 (km/s/Mpc), the matter density parameter Om0 set to 0.3, and the cosmic microwave background temperature Tcmb0 set to 2.725 K. Return the string description of the model.",
        "prompt_zh": "创建一个代表宇宙的ΛCDM模型，赫歇尔参数H0设为70 (km/s/Mpc)，物质密度参数Om0设为0.3，宇宙微波背景辐射温度Tcmb0为2.725 K，并返回模型的字符串描述。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.cosmology import FlatLambdaCDM\n  cosmo = FlatLambdaCDM(H0=70, Om0=0.3, Tcmb0=2.725)\n  return str(cosmo)\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 136,
        "prompt_en": "Calculate the luminosity distance of an astronomical object with a redshift of z=4 in a flat ΛCDM cosmological model, assuming a Hubble constant of 70 km/s/Mpc, a cosmic microwave background temperature of 2.725 K, and a matter density parameter of 0.3.",
        "prompt_zh": "计算在假设哈勃常数为70 km/s/Mpc、宇宙微波背景辐射温度为2.725 K，以及物质密度参数为0.3的平坦ΛCDM宇宙模型中，具有红移z=4的天体的光度距离。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.cosmology import FlatLambdaCDM\n  import astropy.units as u\n  cosmo = FlatLambdaCDM(H0=70 * u.km / u.s / u.Mpc, Tcmb0=2.725 * u.K, Om0=0.3)\n  return cosmo.luminosity_distance(4)\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 137,
        "prompt_en": "Calculate the critical density of the universe at the current age of the universe using the cosmological data from the WMAP seven-year results.",
        "prompt_zh": "计算当前宇宙年龄时的宇宙临界密度，使用WMAP第七年的宇宙学数据结果。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.cosmology import WMAP7\n  return WMAP7.critical_density(0)\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 138,
        "prompt_en": "Convert the cosmological model Planck18 to an Astropy table format and reconstruct the Cosmology object from this table format.",
        "prompt_zh": "将宇宙学模型Planck18转换为Astropy表格式，并从该表格式重新构建Cosmology对象。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.cosmology import Cosmology, Planck18\n    ct = Planck18.to_format(\"astropy.table\")\n    return Cosmology.from_format(ct, format=\"astropy.table\")\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n  if data1.name!=data2.name:\n     return False\n  if data1.H0!=data2.H0:\n     return False\n  if data1.Om0!=data2.Om0:\n     return False\n  if data1.Tcmb0!=data2.Tcmb0:\n     return False\n  if data1.Neff!=data2.Neff:\n     return False\n  if data1.m_nu.unit!=data2.m_nu.unit:\n     return False\n  if not np.allclose(data1.m_nu, data2.m_nu, atol=1e-8):\n     return False\n  if data1.Ob0!=data2.Ob0:\n     return False\n  if data1.meta!=data2.meta:\n     return False\n  return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 139,
        "prompt_en": "Convert the parameters of the Planck18 cosmology model into the Astropy table format and return the result.",
        "prompt_zh": "将Planck18宇宙学模型的参数转换为Astropy表格格式并返回。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.cosmology import Planck18\n    # 将Planck18 cosmology模型转换为QTable格式\n    ct = Planck18.to_format(\"astropy.table\")\n    return ct\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 140,
        "prompt_en": "Retrieve the values of the Hubble constant (H0) and the matter density parameter (Om0) from the Planck15 cosmological model.",
        "prompt_zh": "获取Planck15宇宙学模型中的哈勃常数(H0)和物质密度参数(Om0)的值。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.cosmology import Planck15\n  return Planck15.H0, Planck15.Om0\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit",
            "\nimport math\n\ndef test_code(data1, data2):\n    # 设置绝对误差容许值\n    abs_tol = 1e-8\n    # 使用math.isclose来比较两个浮点数是否在误差范围内相等\n    return math.isclose(data1, data2, abs_tol=abs_tol)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 141,
        "prompt_en": "Get and return the value of the current dark matter density parameter in the Planck Collaboration 2018 cosmological model.",
        "prompt_zh": "获取并返回Planck Collaboration 2018宇宙学模型中当前暗物质密度参数的值。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.cosmology import Planck18\n  return Planck18.Odm0\n\n\n",
        "test_code": [
            "\nimport math\n\ndef test_code(data1, data2):\n    # 设置绝对误差容许值\n    abs_tol = 1e-8\n    # 使用math.isclose来比较两个浮点数是否在误差范围内相等\n    return math.isclose(data1, data2, abs_tol=abs_tol)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 142,
        "prompt_en": "Return the values of the current matter density parameter and the Hubble constant in the Planck 2015 cosmological model.",
        "prompt_zh": "返回Planck2015宇宙学模型中关于当前物质密度参数和哈勃常数的值。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.cosmology import Planck15\n  return Planck15.Om0, Planck15.H0\n\n\n",
        "test_code": [
            "\nimport math\n\ndef test_code(data1, data2):\n    # 设置绝对误差容许值\n    abs_tol = 1e-8\n    # 使用math.isclose来比较两个浮点数是否在误差范围内相等\n    return math.isclose(data1, data2, abs_tol=abs_tol)\n\n",
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 143,
        "prompt_en": "Retrieve the temperature of the cosmic microwave background radiation today and the effective number of neutrino species from the Planck 2013 cosmological model.",
        "prompt_zh": "获取Planck 2013宇宙学模型中的今天的宇宙微波背景辐射温度和有效中微子物种数。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.cosmology import Planck13\n  return Planck13.Tcmb0, Planck13.Neff\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit",
            "\nimport math\n\ndef test_code(data1, data2):\n    # 设置绝对误差容许值\n    abs_tol = 1e-8\n    # 使用math.isclose来比较两个浮点数是否在误差范围内相等\n    return math.isclose(data1, data2, abs_tol=abs_tol)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 144,
        "prompt_en": "Calculate the age of the universe at redshift 0 using the WMAP9 cosmological model.",
        "prompt_zh": "计算在红移为0时，根据WMAP9宇宙学模型估计的宇宙年龄。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.cosmology import WMAP9\n  return WMAP9.age(0)\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 145,
        "prompt_en": "Compute the comoving distance at a redshift z=1 under the WMAP7 cosmological model.",
        "prompt_zh": "计算宇宙模型WMAP7下，赤红移z=1时的共动距离。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.cosmology import WMAP7\n  return WMAP7.comoving_distance(1)\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 146,
        "prompt_en": "Calculate the luminosity distance for an astronomical object with a redshift of z = 2.5 using the WMAP (Year 3) cosmological model.",
        "prompt_zh": "计算在WMAP（第三年数据）宇宙学模型下，红移z为2.5的天体的光度距离。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.cosmology import WMAP3\n  return WMAP3.luminosity_distance(2.5)\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 147,
        "prompt_en": "Get the LambdaCDM cosmological model object based on the 2013 data from the Planck satellite.",
        "prompt_zh": "获取基于Planck卫星2013年数据的LambdaCDM宇宙学模型对象。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.cosmology import Planck13\n    return Planck13\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n  if data1.name!=data2.name:\n     return False\n  if data1.H0!=data2.H0:\n     return False\n  if data1.Om0!=data2.Om0:\n     return False\n  if data1.Tcmb0!=data2.Tcmb0:\n     return False\n  if data1.Neff!=data2.Neff:\n     return False\n  if data1.m_nu.unit!=data2.m_nu.unit:\n     return False\n  if not np.allclose(data1.m_nu, data2.m_nu, atol=1e-8):\n     return False\n  if data1.Ob0!=data2.Ob0:\n     return False\n  if data1.meta!=data2.meta:\n     return False\n  return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 148,
        "prompt_en": "Get and return the cosmological parameters object Planck15, which is based on the 2015 Planck satellite data.",
        "prompt_zh": "获取并返回基于2015年Planck卫星数据设定的宇宙学参数对象Planck15。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.cosmology import Planck15\n    return Planck15\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n  if data1.name!=data2.name:\n     return False\n  if data1.H0!=data2.H0:\n     return False\n  if data1.Om0!=data2.Om0:\n     return False\n  if data1.Tcmb0!=data2.Tcmb0:\n     return False\n  if data1.Neff!=data2.Neff:\n     return False\n  if data1.m_nu.unit!=data2.m_nu.unit:\n     return False\n  if not np.allclose(data1.m_nu, data2.m_nu, atol=1e-8):\n     return False\n  if data1.Ob0!=data2.Ob0:\n     return False\n  if data1.meta!=data2.meta:\n     return False\n  return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 149,
        "prompt_en": "Retrieve and return the built-in cosmological model object Planck18 based on the Planck 2018 dataset.",
        "prompt_zh": "获取并返回基于Planck2018数据集的内置宇宙学模型对象Planck18。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.cosmology import Planck18\n    return Planck18\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n  if data1.name!=data2.name:\n     return False\n  if data1.H0!=data2.H0:\n     return False\n  if data1.Om0!=data2.Om0:\n     return False\n  if data1.Tcmb0!=data2.Tcmb0:\n     return False\n  if data1.Neff!=data2.Neff:\n     return False\n  if data1.m_nu.unit!=data2.m_nu.unit:\n     return False\n  if not np.allclose(data1.m_nu, data2.m_nu, atol=1e-8):\n     return False\n  if data1.Ob0!=data2.Ob0:\n     return False\n  if data1.meta!=data2.meta:\n     return False\n  return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 150,
        "prompt_en": "Return the documentation of the fifth-year Wilkinson Microwave Anisotropy Probe (WMAP) cosmological results.",
        "prompt_zh": "返回第五年Wilkinson Microwave Anisotropy Probe (WMAP) 宇宙学结果的文档说明。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.cosmology import WMAP5\n    return WMAP5.__doc__\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 151,
        "prompt_en": "Return the documentation string of the WMAP7 cosmology model included in the Astropy library to obtain detailed information and parameter descriptions.",
        "prompt_zh": "返回Astropy库中所包含的WMAP7宇宙学模型的文档字符串，以获取其详细信息和参数描述。",
        "canonical_solution": "def canonical_solution():\n    from astropy.cosmology import WMAP7\n    return WMAP7.__doc__\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 152,
        "prompt_en": "Return the documentation string for WMAP9 (Wilkinson Microwave Anisotropy Probe 9-year data model), which includes relevant cosmological parameters and usage instructions.",
        "prompt_zh": "返回WMAP9（威尔金森微波各向异性探测器9年数据模型）的文档字符串，包含有关的宇宙学参数和使用说明。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.cosmology import WMAP9\n    return WMAP9.__doc__\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 153,
        "prompt_en": "Return the documentation of the Planck 2013 cosmological model from the Astropy library.",
        "prompt_zh": "返回Astropy库中Planck2013宇宙学模型的文档说明。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.cosmology import Planck13\n    return Planck13.__doc__\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 154,
        "prompt_en": "Return the documentation string associated with the Planck15 cosmological model in the astropy library to understand the detailed information and parameters of the model.",
        "prompt_zh": "返回与astropy库中Planck15宇宙学模型相关的文档字符串，了解模型的详细信息和参数。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.cosmology import Planck15\n    return Planck15.__doc__\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 155,
        "prompt_en": "Return the documentation of the Planck18 cosmological model from the Astropy library.",
        "prompt_zh": "返回Astropy库中的Planck18宇宙学模型的文档说明。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.cosmology import Planck18\n    return Planck18.__doc__\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 156,
        "prompt_en": "Output the detailed description and parameter information of the WMAP1 cosmological model.",
        "prompt_zh": "输出WMAP1宇宙学模型的详细描述和参数信息。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.cosmology import WMAP1\n    return WMAP1.__doc__\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 157,
        "prompt_en": "Return the docstring of the WMAP3 cosmology model in Astropy to view detailed information and parameters of the model.",
        "prompt_zh": "返回Astropy中WMAP3宇宙学模型的文档字符串，以便查看该模型的详细信息和参数。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.cosmology import WMAP3\n    return WMAP3.__doc__\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 158,
        "prompt_en": "Convert the redshift value 1100 into a luminosity distance based on the WMAP9 model, with the unit in megaparsecs (Mpc).",
        "prompt_zh": "将红移值1100转换为基于WMAP9模型的光度距离，单位为兆秒差距（Mpc）。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.cosmology import WMAP9\n  import astropy.units as u\n  import astropy.cosmology.units as cu\n  z = 1100 * cu.redshift\n  return z.to(u.Mpc, cu.with_redshift(WMAP9, distance=\"luminosity\"))\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 159,
        "prompt_en": "Use the Astropy library to convert the redshift value of 1100 to a dimensionless unit, considering the equivalency of redshift.",
        "prompt_zh": "将红移值1100转换成无量纲单位，使用Astropy库并考虑红移的等效性。\n",
        "canonical_solution": "def canonical_solution():\n    import astropy.units as u\n    import astropy.cosmology.units as cu\n    z = 1100 * cu.redshift\n    return z.to(u.dimensionless_unscaled, equivalencies=cu.dimensionless_redshift())\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 160,
        "prompt_en": "Convert the redshift value of 1100, which corresponds to the cosmic microwave background radiation, into temperature units in Kelvin using the WMAP9 cosmological model.",
        "prompt_zh": "计算宇宙微波背景辐射对应的红移值1100在WMAP9宇宙学模型下转换为温度单位Kelvin的值。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.cosmology import WMAP9\n    import astropy.units as u\n    import astropy.cosmology.units as cu\n    z = 1100 * cu.redshift\n    return z.to(u.K, cu.with_redshift(WMAP9))\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 161,
        "prompt_en": "Convert the cosmological distance expressed in units of 70 Mpc/h to the actual distance unit of Mpc. Use a Hubble constant (H0) of 70 km/s/Mpc for the conversion.",
        "prompt_zh": "将宇宙学中以Hubble参数形式表示的距离70 Mpc/h，转换为实际的距离单位Mpc，使用Hubble常数H0等于70公里/秒/百万秒差距进行换算。\n",
        "canonical_solution": "def canonical_solution():\n    import astropy.units as u\n    import astropy.cosmology.units as cu\n    H0_70 = 70 * u.km/u.s/u.Mpc\n    distance = 70 * (u.Mpc/cu.littleh)\n    return distance.to(u.Mpc, cu.with_H0(H0_70))\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 162,
        "prompt_en": "Create an Astropy Table with masked elements, containing two columns of data: one column named 'x', with type float32, unit meters (m), and values [1.0, 2.0, 3.0], masking the second element; another column named 'y', with type boolean, and values [False, True, False], masking the first element. Write this table to a file named 'my_data.ecsv' in ECSV format, ensuring that if the file exists, it is overwritten. Finally, return the created table object.",
        "prompt_zh": "创建一个包含掩码元素的Astropy Table，其中包含两列数据：一列名为'x'，类型为float32，单位为米(m)，数值为[1.0, 2.0, 3.0]，并对第二个元素进行掩码处理；另一列名为'y'，类型为bool，数值为[False, True, False]，并对第一个元素进行掩码处理。然后将此表格以ECsv格式写入到名为'my_data.ecsv'的文件，并确保如果文件存在则覆盖。最后返回创建的表格对象。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.table import Table, MaskedColumn\n    import numpy as np\n    # Define a table with masked values using an empty string as the marker for missing values\n    t = Table()\n    t['x'] = MaskedColumn([1.0, 2.0, 3.0], unit='m', dtype='float32')\n    t['x'][1] = np.ma.masked  # Mask the second element of 'x'.\n    t['y'] = MaskedColumn([False, True, False], dtype='bool')\n    t['y'][0] = np.ma.masked  # Mask the first element of 'y'.\n    t.write('my_data.ecsv', format='ascii.ecsv', overwrite=True)  \n    return t\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 163,
        "prompt_en": "Create a table containing two columns of data. The first column is named 'x' and contains the floating-point numbers [1.0, 2.0, 3.0] with units of meters, masking the second element. The second column is named 'y' and contains the boolean values [False, True, False], masking the first element. Write this table to the file 'my_data.ecsv' using the 'data_mask' serialization method, overwriting the file if it already exists. Finally, return the table object.",
        "prompt_zh": "创建一个表包含两列数据，第一列名为'x'，包含单位为米的浮点数[1.0, 2.0, 3.0]并掩码第二个元素；第二列名为'y'，包含布尔值[False, True, False]并掩码第一个元素。将该表格以'data_mask'的序列化方式写入文件'my_data.ecsv'，如果文件存在则覆盖。最后返回表格对象。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.table import Table, MaskedColumn\n    import numpy as np\n    # Write masked data to ECSV by splitting into separate data and mask columns.\n    t = Table()\n    t['x'] = MaskedColumn([1.0, 2.0, 3.0], unit='m', dtype='float32')\n    t['x'][1] = np.ma.masked  # Mask the second element of 'x'.\n    t['y'] = MaskedColumn([False, True, False], dtype='bool')\n    t['y'][0] = np.ma.masked  # Mask the first element of 'y'.\n    t.write('my_data.ecsv', serialize_method='data_mask', overwrite=True)  \n    return t\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 164,
        "prompt_en": "Read a fixed-width format string table with two columns named Col1 and Col2. The table data is as follows:\n```\n      Col1  |  Col2 |\n      1.2       \"hello\"\n      2.4   sdf's worlds\n```\nConvert it into an Astropy Table object.",
        "prompt_zh": "读取一个固定宽度格式的字符串表格，表格有两列分别名为Col1和Col2。表格数据如下：\n```\n      Col1  |  Col2 |\n      1.2       \"hello\"\n      2.4   sdf's worlds\n```\n并将其转换成Astropy Table对象。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.io import ascii\n    table = \"\"\"\n      Col1  |  Col2 |\n      1.2       \"hello\"\n      2.4   sdf's worlds\n    \"\"\"\n    return ascii.read(table, format='fixed_width')\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 165,
        "prompt_en": "Read a string table in fixed-width format:  \n```  \n     Name  --Phone-    ----TCP-----  \n     John  555-1234    192.168.1.10  \n     Mary  555-2134    192.168.1.12  \n      Bob  555-4527     192.168.1.9  \n```  \nUse a space as the delimiter. Convert this table into an Astropy Table object and return it.",
        "prompt_zh": "读取一个固定宽度格式的字符串表格，\"\"\"\n     Name  --Phone-    ----TCP-----\n     John  555-1234    192.168.1.10\n     Mary  555-2134    192.168.1.12\n      Bob  555-4527     192.168.1.9\n    \"\"\"，使用空格作为分隔符。将这个表格转换为Astropy Table对象并返回。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.io import ascii\n    table = \"\"\"\n     Name  --Phone-    ----TCP-----\n     John  555-1234    192.168.1.10\n     Mary  555-2134    192.168.1.12\n      Bob  555-4527     192.168.1.9\n    \"\"\"\n    return ascii.read(table, format='fixed_width', delimiter=' ')\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 166,
        "prompt_en": "Read a fixed-width text table without column headers and convert it into an Astropy Table object. The table data is as follows:\n```\n|  John  | 555-1234 |192.168.1.10|\n|  Mary  | 555-2134 |192.168.1.12|\n|   Bob  | 555-4527 | 192.168.1.9|\n```",
        "prompt_zh": "读取一个没有列标题的固定宽度的文本表格，并将其转换为一个Astropy Table对象返回。表格数据如下：\n\"\"\"\n|  John  | 555-1234 |192.168.1.10|\n|  Mary  | 555-2134 |192.168.1.12|\n|   Bob  | 555-4527 | 192.168.1.9|\n\"\"\"\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.io import ascii\n    table = \"\"\"\n|  John  | 555-1234 |192.168.1.10|\n|  Mary  | 555-2134 |192.168.1.12|\n|   Bob  | 555-4527 | 192.168.1.9|\n\"\"\"\n    return ascii.read(table, format='fixed_width', header_start=None, data_start=0)\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 167,
        "prompt_en": "Read the given fixed-width text table data, \"\"\"\n    |  Name  --Phone-    ----TCP-----\n    |  John  555-1234    192.168.1.10\n    |  Mary  555-2134    192.168.1.12\n    |   Bob  555-4527     192.168.1.9\n    \"\"\". Parse this text data into an Astropy Table object.",
        "prompt_zh": "读取给定的固定宽度文本表格数据，\"\"\"\n    |  Name  --Phone-    ----TCP-----\n    |  John  555-1234    192.168.1.10\n    |  Mary  555-2134    192.168.1.12\n    |   Bob  555-4527     192.168.1.9\n    \"\"\"。将此文本数据解析为Astropy Table对象。",
        "canonical_solution": "def canonical_solution():\n    from astropy.io import ascii\n    table = \"\"\"\n    |  Name  --Phone-    ----TCP-----\n    |  John  555-1234    192.168.1.10\n    |  Mary  555-2134    192.168.1.12\n    |   Bob  555-4527     192.168.1.9\n    \"\"\"\n    return ascii.read(table, format='fixed_width', delimiter=' ')\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 168,
        "prompt_en": "Read a table of data represented in a fixed-width column format:\n```\n|  Col1  |  Col2   |\n|  1.2   | \"hello\" |\n|  2.4   | 's worlds |\n```\nConvert this information into an Astropy Table object and return it.",
        "prompt_zh": "读取一个用固定宽度列格式表示的表格数据，\"\"\"\n|  Col1  |  Col2   |\n|  1.2   | \"hello\" |\n|  2.4   |'s worlds|\n\"\"\"。将这些信息转换为Astropy Table对象并返回。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.io import ascii\n    table = \"\"\"\n|  Col1  |  Col2   |\n|  1.2   | \"hello\" |\n|  2.4   |'s worlds|\n\"\"\"\n    return ascii.read(table, format='fixed_width')\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 169,
        "prompt_en": "Read a fixed-width table containing data on name, phone number, and TCP address, and convert it into an Astropy Table object. The table is formatted as follows:\n```\n|| Name ||   Phone ||         TCP||\n|  John  | 555-1234 |192.168.1.10X|\n|  Mary  | 555-2134 |192.168.1.12X|\n|   Bob  | 555-4527 | 192.168.1.9X|\n```",
        "prompt_zh": "读取一个包含名称、电话和TCP地址的固定宽度表格数据，并将其转换为Astropy Table对象。表格格式如下所示：\n\"\"\"\n|| Name ||   Phone ||         TCP||\n|  John  | 555-1234 |192.168.1.10X|\n|  Mary  | 555-2134 |192.168.1.12X|\n|   Bob  | 555-4527 | 192.168.1.9X|\n\"\"\"\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.io import ascii\n    table = \"\"\"\n|| Name ||   Phone ||         TCP||\n|  John  | 555-1234 |192.168.1.10X|\n|  Mary  | 555-2134 |192.168.1.12X|\n|   Bob  | 555-4527 | 192.168.1.9X|\n\"\"\"\n    return ascii.read(table, format='fixed_width')\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 170,
        "prompt_en": "Read a fixed-width table data without a header row and convert it into an Astropy Table object. The table data is given as \"\"\"\n|  1.2  | \"hello\" |\n|  2.4  |'s worlds|\n\"\"\"",
        "prompt_zh": "读取一个没有标题行的固定宽度的表格数据，并将其转换为Astropy Table对象。表格数据为\"\"\"\n|  1.2  | \"hello\" |\n|  2.4  |'s worlds|\n\"\"\"\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.io import ascii\n    table = \"\"\"\n|  1.2  | \"hello\" |\n|  2.4  |'s worlds|\n\"\"\"\n    return ascii.read(table, format='fixed_width_no_header')\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 171,
        "prompt_en": "Translate the following fixed-width formatted table data into an Astropy Table object, with column names 'Name', 'Phone', and 'TCP'. Explicitly set the starting positions of each column as 1, 9, and 19, respectively. The data is as follows:  \n```\n#1       9        19                <== Column start indexes\n#|       |         |                <== Column start positions\n#<------><--------><------------->  <== Inferred column positions\n  John   555- 1234 192.168.1.10\n  Mary   555- 2134 192.168.1.123\n   Bob   555- 4527  192.168.1.9\n   Bill  555-9875  192.255.255.255\n```\n",
        "prompt_zh": "将以下固定宽度格式的表格数据，转换为一个Astropy Table对象，列名分别为'Name', 'Phone', 'TCP'，并明确每列的起始位置分别为1, 9, 19。数据如下：\n\"\"\"\n    #1       9        19                <== Column start indexes\n    #|       |         |                <== Column start positions\\n    #<------><--------><------------->  <== Inferred column positions\\n      John   555- 1234 192.168.1.10\\n      Mary   555- 2134 192.168.1.123\\n       Bob   555- 4527  192.168.1.9\\n       Bill  555-9875  192.255.255.255\n    \"\"\"",
        "canonical_solution": "def canonical_solution():\n    from astropy.io import ascii\n    table = \"\"\"\n    #1       9        19                <== Column start indexes\n    #|       |         |                <== Column start positions\n    #<------><--------><------------->  <== Inferred column positions\n      John   555- 1234 192.168.1.10\n      Mary   555- 2134 192.168.1.123\n       Bob   555- 4527  192.168.1.9\n       Bill  555-9875  192.255.255.255\n    \"\"\"\n    return ascii.read(table, format='fixed_width_no_header', names=('Name', 'Phone', 'TCP'), col_starts=(1, 9, 19), )\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 172,
        "prompt_en": "Read the table data from a given fixed-width format string and convert it into an Astropy table object. The fixed-width format consists of two header lines, with data columns including Col1, Col2, Col3, and Col4. The data is as follows:\n```\n    Col1      Col2 Col3 Col4\n    ---- --------- ---- ----\n    1.2   \"hello\"    1    a\n    2.4 's worlds    2    2\n```",
        "prompt_zh": "从给定的固定宽度格式字符串中，读取表格数据并转换成Astropy表对象。固定宽度格式为包含两个标题行，数据列包括Col1、Col2、Col3和Col4，数据如下\n\"\"\"\n    Col1      Col2 Col3 Col4\n    ---- --------- ---- ----\n    1.2   \"hello\"    1    a\n    2.4 's worlds    2    2\n    \"\"\"",
        "canonical_solution": "def canonical_solution():\n    from astropy.io import ascii\n    table = \"\"\"\n    Col1      Col2 Col3 Col4\n    ---- --------- ---- ----\n    1.2   \"hello\"    1    a\n    2.4 's worlds    2    2\n    \"\"\"\n    return ascii.read(table, format='fixed_width_two_line')\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 173,
        "prompt_en": "Create an Astropy Table by reading data from an ASCII formatted string variable:\n\n```\ntarget observatory obsid\nTW_Hya Chandra     22178\nMP_Mus XMM         0406030101\n```\n\nEnsure that the 'obsid' column is converted to a string format. Return the resulting table object.",
        "prompt_zh": "创建一个Astropy Table从ASCII格式的字符串变量中读取数据，\"\"\"\n  target observatory obsid\n  TW_Hya Chandra     22178\n  MP_Mus XMM         0406030101\"\"\"，并确保obsid列被转换为字符串格式。 返回这个表格对象。",
        "canonical_solution": "def canonical_solution():\n  from astropy.table import Table\n  from astropy.io import ascii\n  sources = \"\"\"\n  target observatory obsid\n  TW_Hya Chandra     22178\n  MP_Mus XMM         0406030101\"\"\"\n  data = Table.read(sources, format='ascii', converters={'obsid': ascii.convert_numpy(str)})\n  return data\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 174,
        "prompt_en": "Create a table with two columns, where the first column is named 'x' and contains the integers [1, 2, 3], and the second column is named 'y' containing the square of each value in the first column. Save this table as an ASCII format file named 'values.dat' and overwrite any file with the same name.",
        "prompt_zh": "创建一个包含两列数据的表，第一列名为'x'，包含整数[1, 2, 3]，第二列名为'y'，包含第一列中每个数值的平方，然后将该表保存为名为'values.dat'的ASCII格式文件，并覆盖同名文件。\n",
        "canonical_solution": "def canonical_solution():\n  import numpy as np\n  from astropy.io import ascii\n  from astropy.table import Table\n  data = Table()\n  data['x'] = np.array([1, 2, 3], dtype=np.int32)\n  data['y'] = data['x'] ** 2\n  ascii.write(data, 'values.dat', overwrite=True)\n  return 'values.dat'\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 175,
        "prompt_en": "Create an Astropy Table object from the provided ASCII-formatted textual data:\n\n```\n... target observatory obsid\n... TW_Hya Chandra     22178\n... MP_Mus XMM         0406030101\n```\n\nEnsure that the datatype of the observation ID ('obsid') column is a string. Return this table object.",
        "prompt_zh": "从提供的ASCII格式文本数据\"\"\"\\n... target observatory obsid\n... TW_Hya Chandra     22178\n... MP_Mus XMM         0406030101\"\"\"创建一个Astropy Table对象，并确保观测ID（obsid）列的数据类型为字符串，返回这个表格对象。",
        "canonical_solution": "def canonical_solution():\n    from astropy.table import Table\n    sources = \"\"\"\n... target observatory obsid\n... TW_Hya Chandra     22178\n... MP_Mus XMM         0406030101\"\"\"\n    data = Table.read(sources, format='ascii', converters={'obsid': str})\n    return data\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 176,
        "prompt_en": "Create an empty Astropy Table object, add a column named 'x' containing integers [1, 2, 3], then add a column named 'y' containing the square of each element in column 'x'. Finally, write this table to a file named 'values.dat' in ASCII format, overwriting any existing file, and return the table object.",
        "prompt_zh": "创建一个空Astropy Table对象，添加名为'x'的列，其包含整数[1, 2, 3]，然后添加名为'y'的列，其包含列'x'中每个元素的平方值。最后将这个表格以ASCII格式写入到名为'values.dat'的文件中，并覆盖任何已存在的文件，返回这个表格对象。",
        "canonical_solution": "def canonical_solution():\n    import numpy as np\n    from astropy.io import ascii\n    from astropy.table import Table\n    data = Table()\n    data['x'] = np.array([1, 2, 3], dtype=np.int32)\n    data['y'] = data['x'] ** 2\n    ascii.write(data, 'values.dat', overwrite=True)\n    return data\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 177,
        "prompt_en": "Create an Astropy Table object containing columns x and y, and assign the values [1, 2, 3] and [1, 4, 9] to these columns, respectively. Then, save this table to the file 'values.ecsv' in ECSV format, ensuring to overwrite it if the file already exists. Finally, return the table.",
        "prompt_zh": "创建一个包含列x和列y的Astropy Table对象，并分别为这两列赋值[1, 2, 3]和[1, 4, 9]。然后将此表格以ECSV格式保存到文件'values.ecsv'中，并确保如果该文件已存在则覆盖它。最后，返回该表格。",
        "canonical_solution": "def canonical_solution():\n    from astropy.table import Table\n    data = Table()\n    data['x'] = [1, 2, 3]\n    data['y'] = [1, 4, 9]\n    data.write('values.ecsv', format='ascii.ecsv', overwrite=True)\n    return data\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 178,
        "prompt_en": "Create an Astropy table containing two columns of data: the first column named 'x' containing integers [1, 2, 3], and the second column named 'y' containing the square values of each integer in the first column. Save this table to a file named 'values.dat', overwriting any existing file with the same name. Return the table object created.",
        "prompt_zh": "创建一个Astropy表格，它包含两列数据：第一列名为'x'，包含整数[1, 2, 3]；第二列名为'y'，包含第一列每个整数的平方值。将这个表格保存到一个名为'values.dat'的文件中，并覆盖任何同名现有文件。返回创建的表格对象。\n",
        "canonical_solution": "def canonical_solution():\n    import numpy as np\n    from astropy.io import ascii\n    from astropy.table import Table\n    data = Table()\n    data['x'] = np.array([1, 2, 3], dtype=np.int32)\n    data['y'] = data['x'] ** 2\n    ascii.write(data, 'values.dat', overwrite=True)\n    return data\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 179,
        "prompt_en": " Create an empty Astropy Table and save it as a file named 'values.ecsv'. If the file already exists, overwrite it.",
        "prompt_zh": "创建一个空的Astropy Table表格，并将其保存为名为'values.ecsv'的文件，如果文件已存在则覆盖它。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.table import Table\n    data = Table()\n    data.write('values.ecsv', overwrite=True)  \n    return data\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 180,
        "prompt_en": "Create a data table with the first column named 'a' containing integers [1, 2, 3] and the second column named 'b' containing floating-point numbers [4.2, 5.5, 6.8]. Save this table in CSV format to a file named 'table.csv', ensuring that if the file already exists, it is overwritten.",
        "prompt_zh": "创建一个数据表，第一列名为'a'，包含整数[1, 2, 3]；第二列名为'b'，包含浮点数[4.2, 5.5, 6.8]。将这个表格以CSV格式保存到名为'table.csv'的文件中，并确保如果文件已经存在，则覆盖它。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.table import Table\n    from astropy.io import ascii\n    data = Table({'a': [1, 2, 3], 'b': [4.2, 5.5, 6.8]})\n    ascii.write(data, 'table.csv', format='csv', overwrite=True)\n    return data\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 181,
        "prompt_en": "Create an Astropy Table to store astronomical data, with the data in string format as follows:\n```\n    target observatory obsid\n    TW_Hya Chandra     22178\n    MP_Mus XMM         0406030101\n```\nEnsure the observation ID is stored as a string. Return the Table object.\n\nFeel free to provide more instructions for translation!",
        "prompt_zh": "创建一个Astropy Table来存储天文数据，数据为字符串形式，\"\"\"\n    target observatory obsid\n    TW_Hya Chandra     22178\n    MP_Mus XMM         0406030101\"\"\"\n，确保观测ID以字符串格式存储，返回这个Table对象。",
        "canonical_solution": "def canonical_solution():\n    from astropy.table import Table\n    sources = \"\"\"\n    target observatory obsid\n    TW_Hya Chandra     22178\n    MP_Mus XMM         0406030101\"\"\"\n    data = Table.read(sources, format='ascii', converters={'obsid': str})\n    return data\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 182,
        "prompt_en": "Create a table and add two columns of data. The first column is named 'x' and contains the integers [1, 2, 3]. The second column is named 'y' and contains the square of each element in the first column. Write this table to a file named 'values.dat' in ASCII format, overwriting the file if it already exists. Return this table.",
        "prompt_zh": "创建一个表格并添加两列数据，第一列命名为'x'，包含整数[1, 2, 3]；第二列命名为'y'，为第一列每个元素的平方。将这个表格以ASCII格式写入到名为'values.dat'的文件中，并覆盖同名文件如果它已经存在。返回这个表格。\n",
        "canonical_solution": "def canonical_solution():\n    import numpy as np\n    from astropy.io import ascii\n    from astropy.table import Table\n    data = Table()\n    data['x'] = np.array([1, 2, 3], dtype=np.int32)\n    data['y'] = data['x'] ** 2\n    ascii.write(data, 'values.dat', overwrite=True)\n    return data\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 183,
        "prompt_en": "Create a table containing two columns of data, where the first column is named 'x' with data [1, 2, 3], and the second column is named 'y' with data [1, 4, 9]. Write this table to a file named 'values.ecsv' in the enhanced CSV format, ensuring that if the file already exists, it is overwritten. Return this table.",
        "prompt_zh": "生成一张包含两列数据的列表，第一列列名为'x'，包含数据[1, 2, 3]，第二列列名为'y'，包含数据[1, 4, 9]，将这张表以增强CSV格式写入到名为'values.ecsv'的文件中，并确保如果文件已存在则覆盖它，返回这个表格。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.table import Table\n    data = Table({'x': [1, 2, 3], 'y': [1, 4, 9]})\n    data.write('values.ecsv', format='ascii.ecsv', overwrite=True)\n    return data\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 184,
        "prompt_en": "Read a table string that uses `&` as a delimiter:\n```\n        objID     & osrcid            & xsrcid       \n        --------- & ----------------- & -------------\n        277955213 & S000.7044P00.7513 & XS04861B6_005\n        889974380 & S002.9051P14.7003 & XS03957B7_004\n    ```.And parse it into an Astropy Table object. The table includes three columns named `objID`, `osrcid` and `xsrcid`, and the data starts from the third row of the table string.",
        "prompt_zh": "读取使用`&`作为分隔符的表格字符串\"\"\"\n        objID     & osrcid            & xsrcid       \n        --------- & ----------------- & -------------\n        277955213 & S000.7044P00.7513 & XS04861B6_005\n        889974380 & S002.9051P14.7003 & XS03957B7_004\n    \"\"\"并将其解析为一个Astropy Table对象。表格中包括三个列名为`objID`、`osrcid`和`xsrcid`的列，数据从表格字符串的第三行开始。",
        "canonical_solution": "from astropy.io import ascii\ndef canonical_solution():\n    table = \"\"\"\n        objID     & osrcid            & xsrcid       \n        --------- & ----------------- & -------------\n        277955213 & S000.7044P00.7513 & XS04861B6_005\n        889974380 & S002.9051P14.7003 & XS03957B7_004\n    \"\"\"        \n    data = ascii.read(table, data_start=2, delimiter='&')\n    return data\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 185,
        "prompt_en": "Read ASCII table data delimited by '&' from ['objID & osrcid & xsrcid', \n             '----------------------- & ----------------- & -------------', \n             '277955213 & S000.7044P00.7513 & XS04861B6_005', \n             '889974380 & S002.9051P14.7003 & XS03957B7_004'], where the first two lines are titles and delimiters, and the real data starts from the third line. Process the data and save it as an Astropy Table object to return.",
        "prompt_zh": "读取用'&'作为分隔符的ASCII表数据['objID & osrcid & xsrcid', \n             '----------------------- & ----------------- & -------------', \n             '277955213 & S000.7044P00.7513 & XS04861B6_005', \n             '889974380 & S002.9051P14.7003 & XS03957B7_004']，数据表的前两行是标题和分隔符，真正的数据从第三行开始。处理后将数据保存为一个Astropy Table对象并进行返回。",
        "canonical_solution": "def canonical_solution():\n    from astropy.io import ascii\n    lines = ['objID & osrcid & xsrcid', \n             '----------------------- & ----------------- & -------------', \n             '277955213 & S000.7044P00.7513 & XS04861B6_005', \n             '889974380 & S002.9051P14.7003 & XS03957B7_004']\n    data = ascii.read(lines, data_start=2, delimiter='&')\n    return data\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 186,
        "prompt_en": "Create a table containing an integer array x (values 1, 2, 3) and its corresponding squared array y, and save this table to a file named 'values.dat'. Overwrite the file if it already exists.",
        "prompt_zh": "创建一个包含整型数列x（值为1, 2, 3）及其平方的对应数列y的表格，并将这个表格保存到一个名为'values.dat'的文件中，如果文件已经存在则覆盖它。\n",
        "canonical_solution": "def canonical_solution():\n  import numpy as np\n  from astropy.io import ascii\n  from astropy.table import Table\n  data = Table()\n  data['x'] = np.array([1, 2, 3], dtype=np.int32)\n  data['y'] = data['x'] ** 2\n  ascii.write(data, 'values.dat', overwrite=True)\n  return 'Wrote to values.dat'\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 187,
        "prompt_en": "Create a table with a column 'x' containing the integers from 1 to 3 and a column 'y' containing their respective squared values. Save the table to a file named 'values.dat', overwriting the file if it exists. Also, return the created table object.",
        "prompt_zh": "创建一个包含整数1到3的列'x'及其平方值的列'y'的表，并将该表保存到名为'values.dat'的文件中，若文件已存在则覆盖。同时返回生成的表格对象。\n",
        "canonical_solution": "def canonical_solution():\n    import numpy as np\n    from astropy.io import ascii\n    from astropy.table import Table\n    data = Table()\n    data['x'] = np.array([1, 2, 3], dtype=np.int32)\n    data['y'] = data['x'] ** 2\n    ascii.write(data, 'values.dat', overwrite=True)\n    # Assuming the function must also return the created table:\n    return data\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 188,
        "prompt_en": "Create an Astropy Table object containing two columns, where the first column is named 'x' with values [1, 2, 3], and the second column is named 'y' with values [1, 4, 9]. Write this table to a file named 'values.ecsv' in the ECSV format, ensuring that if the file exists, it is overwritten. Return the table object for subsequent verification.",
        "prompt_zh": "创建一个包含两列数据，其中第一列名为'x'，其值为[1, 2, 3]，第二列名为'y'，其值为[1, 4, 9]的Astropy Table对象。将这个表格以ECSV格式写入到名为'values.ecsv'的文件中，并确保如果文件已存在则覆盖它。返回该表格对象供后续验证使用。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.io import ascii\n    from astropy.table import Table\n    data = Table()\n    data['x'] = [1, 2, 3]\n    data['y'] = [1, 4, 9]\n    # 使用ECSV格式写入文件\n    data.write('values.ecsv', format='ascii.ecsv', overwrite=True)\n    # 函数返回表格的数据用于验证\n    return data\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 189,
        "prompt_en": "Create an Astropy table containing two columns x and y, with x column values [1, 2, 3] and y column values [4, 5, 6]. Then write this table to a file in LaTeX format and return the table object.",
        "prompt_zh": "创建一个Astropy表格，其包含两列x和y，x列的值为[1, 2, 3]，y列的值为[4, 5, 6]，然后将该表格以LaTeX格式写入文件，并返回这个表格对象。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.io import ascii\n    from astropy.table import Table\n\n    data = Table()\n    data['x'] = [1, 2, 3]\n    data['y'] = [4, 5, 6]\n    ascii.write(data, format='latex')\n    return data\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 190,
        "prompt_en": "Create a FITS image HDU containing the data [[0, 1], [2, 3]], convert the data type to signed 16-bit integers, and scale the data range according to the minimum and maximum values. Then return the scaled image data array.",
        "prompt_zh": "创建一个包含数据[[0, 1], [2, 3]]的FITS图像HDU，将数据类型转换为有符号16位整数，并按照最小和最大值缩放数据范围，然后返回缩放后的图像数据数组。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.io import fits\n  from numpy import array\n  hdu = fits.ImageHDU(array([[0, 1], [2, 3]], dtype='uint8'))\n  hdu.scale('int16', option='minmax')\n  return hdu.data\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 191,
        "prompt_en": "Open a FITS file named 'test0.fits', read the data content of the second HDU, and return that data.",
        "prompt_zh": "打开一个名为'test0.fits'的FITS文件，读取第二个HDU的数据内容，并返回这些数据。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.io import fits\n    fits_image_filename = fits.util.get_testdata_filepath('test0.fits')\n    hdul = fits.open(fits_image_filename)\n    data = hdul[1].data\n    hdul.close()\n    return data\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 192,
        "prompt_en": "Read the header information of the first HDU from the FITS file named 'history_header.fits', extract all entries under the 'HISTORY' keyword, and return the last history entry in the list.",
        "prompt_zh": "读取名为'history_header.fits'的FITS文件中第一个HDU的头部信息，提取'HISTORY'关键字下的所有条目，并返回列表中的最后一个历史条目。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.io import fits\n    filename = fits.util.get_testdata_filepath('history_header.fits')\n    with fits.open(filename) as hdul:\n        hdr = hdul[0].header\n        history_entries = hdr['HISTORY']\n    return history_entries[-1]\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 193,
        "prompt_en": "Create a FITS card containing temperature information with the keyword 'TEMP', a value of 80.0, and a comment 'temperature, floating value'. Convert it to a string format and return.",
        "prompt_zh": "创建一个包含温度信息的FITS卡片，其关键字为'TEMP'，数值为80.0，注释为'temperature, floating value'，并将其转换为字符串形式返回。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.io import fits\n    c1 = fits.Card('TEMP', 80.0, 'temperature, floating value')\n    return str(c1)\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 194,
        "prompt_en": "Open the FITS file located at 'history_header.fits', add two 'HISTORY' entries in the header indicating updates on '02/03/2011' and '02/04/2011' with the notes 'I updated this file on 02/03/2011' and 'I updated this file on 02/04/2011', then return a list of all 'HISTORY' entries.",
        "prompt_zh": "打开地址为'history_header.fits'的FITS文件，向头部信息中添加两条'HISTORY'条目，分别注明在2011年2月3日和4日更新了这个文件'I updated this file on 02/03/2011'、'I updated this file on 02/04/2011'，然后返回所有'HISTORY'条目的列表。",
        "canonical_solution": "def canonical_solution():\n    from astropy.io import fits\n    fits_image_filename = fits.util.get_testdata_filepath('history_header.fits')\n    with fits.open(fits_image_filename) as hdul:\n        hdr = hdul[0].header\n        hdr['HISTORY'] = 'I updated this file on 02/03/2011'\n        hdr['HISTORY'] = 'I updated this file on 02/04/2011'\n    # Assuming the context requires returning the list of HISTORY entries\n    return hdr['HISTORY']\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 检查值是否相等\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 195,
        "prompt_en": "Create an empty FITS header object, add a key-value pair with the key 'abc' and the value as the string 'abcdefg' repeated 20 times. Then retrieve and return the value of this key.",
        "prompt_zh": "创建一个空的FITS头信息对象，添加一个键为'abc'，值为字符串'abcdefg'重复20次的键值对。然后检索并返回该键的值。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.io import fits\n    hdr = fits.Header()\n    hdr['abc'] = 'abcdefg' * 20\n    long_string = hdr['abc']\n    return long_string\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 196,
        "prompt_en": "Add a key named 'UNDEF' with an undefined value (None) to the FITS header information. Then check and return if the value of this key is undefined.",
        "prompt_zh": "在FITS头部信息中添加一个值为未定义（None）的关键字'UNDEF'，然后检查并返回这个关键字的值是否为未定义。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.io import fits\n  hdr = fits.Header()\n  hdr['UNDEF'] = None\n  return hdr['UNDEF'] is None\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 197,
        "prompt_en": "Add a long keyword 'longkeyword' with its corresponding value 'longvalue' to the header information of a FITS file, and then return the value of the newly added keyword.",
        "prompt_zh": "在一个FITS文件头部信息中添加一个长关键字'longkeyword'及其对应的值'longvalue'，然后返回这个新添加的关键字的值。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.io import fits\n  hdr = fits.Header()\n  hdr['HIERARCH longkeyword'] = 'longvalue'\n  return hdr['longkeyword']\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 198,
        "prompt_en": "Open a FITS file named `'test0.fits'`, change the value of the `'DARKCORR'` keyword in the header information to `'PERFORM'`, save the modification and return the updated header information.",
        "prompt_zh": "打开一个名为`'test0.fits'`的FITS文件，修改头部信息中`'DARKCORR'`关键字的值为`'PERFORM'`，保存修改并返回更新后的头部信息。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.io import fits\n    fits_image_filename = fits.util.get_testdata_filepath('test0.fits')\n    hdul = fits.open(fits_image_filename)\n    hdr = hdul[0].header\n    hdr['DARKCORR'] = 'PERFORM'\n    hdul.close()\n    return hdr\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 199,
        "prompt_en": "Create a header for a FITS file and add a long comment 'This is an example of a long comment that will span across multiple CONTINUE cards in a FITS header.' to ensure the comment covers multiple CONTINUE cards. Then return the string representation of the header information.",
        "prompt_zh": "创建一个FITS文件的头部信息，添加一个长注释'This is an example of a long comment that will span across multiple CONTINUE cards in a FITS header.'，以确保注释会覆盖多个CONTINUE卡片。然后返回头部信息的字符串表示形式。",
        "canonical_solution": "def canonical_solution():\n    from astropy.io import fits\n    hdr = fits.Header()\n    hdr['COMMENT'] = 'This is an example of a long comment that will span across multiple CONTINUE cards in a FITS header.'\n    return str(hdr)\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 200,
        "prompt_en": "Create a new Primary Header Data Unit (Primary HDU) for a FITS file, and set the value of 'HIERARCH ESO DET CHIP1' to 1.0 in its header information. Then, return this header information.",
        "prompt_zh": "创建一个新的FITS文件的主头数据单元（Primary HDU），并在其头信息中设置'HIERARCH ESO DET CHIP1'的值为1.0，然后返回这个头信息。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.io import fits\n    hdu = fits.PrimaryHDU()\n    hdu.header['HIERARCH ESO DET CHIP1'] = 1.0\n    return hdu.header\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 201,
        "prompt_en": "Open the FITS file named 'test0.fits', retrieve and return the header information value of the specified index 34, the header information value with the key 'DARKCORR', and all related header information values with the pattern 'DARKCOR*' from the primary header.",
        "prompt_zh": "打开名为'test0.fits'的FITS文件，并从主头部信息（header）中检索并返回指定索引为34的头部信息值、键为'DARKCORR'的头部信息值以及所有模式为'DARKCOR*'的相关头部信息值。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.io import fits\n    \n    fits_image_filename = fits.util.get_testdata_filepath('test0.fits')\n    hdul = fits.open(fits_image_filename)\n    hdr = hdul[0].header  # the primary HDU header\n    hdul.close()  \n    return hdr[34], hdr['DARKCORR'], hdr['DARKCOR*']\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接比较两个整数是否相同\n    return data1 == data2\n\n",
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n",
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 202,
        "prompt_en": "Open the FITS file named 'test0.fits', modify the value of the 'DARKCORR' keyword to 'OMIT' in the header of the second HDU, and then return the value of 'DARKCORR'.",
        "prompt_zh": "打开名为'test0.fits'的FITS文件，修改第二个HDU的header中，添加或修改'DARKCORR'关键字的值为'OMIT'，然后返回'DARKCORR'的值。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.io import fits\n    \n    fits_image_filename = fits.util.get_testdata_filepath('test0.fits')\n    hdul = fits.open(fits_image_filename)\n    hdr = hdul[1].header\n    hdul.close()  \n    hdr['DARKCORR'] = 'OMIT'  # Add a new DARKCORR keyword\n    return hdr['DARKCORR']\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 203,
        "prompt_en": "Create a FITS header object and add the key 'NAXIS' with the value set to 2, representing the dimensions of the image data. Add an explanatory comment for this key 'The number of image axes'. Finally, return the comment content of the 'NAXIS' key in the header.",
        "prompt_zh": "创建一个FITS头部信息对象，并为其添加'NAXIS'键（表示图像数据的维度）的值设定为2，并添加该键的解释注释为'The number of image axes'。最后返回这个头部信息中'NAXIS'键的注释内容。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.io import fits\n  hdr = fits.Header()\n  hdr['NAXIS'] = 2\n  hdr.comments['NAXIS'] = 'The number of image axes'\n  return hdr.comments['NAXIS']\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 204,
        "prompt_en": "Create a new blank primary FITS data unit, add a new keyword 'DARKCORR' with the value 'OMIT' to its header information, and then return the header information.",
        "prompt_zh": "创建一个新的空白FITS主数据单元，并在其中的头部信息添加一个新关键词'DARKCORR'，其值设定为'OMIT'，然后返回该头部信息。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.io import fits\n  hdu = fits.PrimaryHDU()\n  hdu.header['DARKCORR'] = 'OMIT'  # Add a new DARKCORR keyword\n  return hdu.header\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 205,
        "prompt_en": "Create an empty FITS Header object and add a keyword 'abc' with its value set to the string 'abcdefg' repeated 20 times. Then, return this FITS Header object.",
        "prompt_zh": "创建一个空的FITS Header对象，并向其中添加关键字'abc'，其值设置为字符串'abcdefg'重复20次，然后返回这个FITS Header对象。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.io import fits\n  hdr = fits.Header()\n  hdr['abc'] = 'abcdefg' * 20\n  return hdr\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 206,
        "prompt_en": "In a new FITS file's primary header, add a custom key 'HIERARCH abcdefghi' with a value of 10, and return the value corresponding to this key.",
        "prompt_zh": "在一个新的FITS文件的主要结构单元的头部信息中添加一个自定义的键'HIERARCH abcdefghi'，其值为10，并返回这个键对应的值。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.io import fits\n  hdu = fits.PrimaryHDU()\n  hdu.header['HIERARCH abcdefghi'] = 10\n  return hdu.header['abcdefghi']\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接比较两个整数是否相同\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 207,
        "prompt_en": "Open the FITS file named 'test0.fits', modify the 'DARKCORR' keyword in the header of the first HDU to 'PERFORM', and then return the value of this keyword.",
        "prompt_zh": "打开名称为'test0.fits'的FITS文件，修改其第一个HDU的header中的'DARKCORR'关键字为'PERFORM'，然后返回这个关键字的值。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.io import fits\n    fits_image_filename = fits.util.get_testdata_filepath('test0.fits')\n    hdul = fits.open(fits_image_filename)  \n    hdr = hdul[0].header  \n    hdr['DARKCORR'] = 'PERFORM'  \n    hdul.close()\n    return hdr['DARKCORR']\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 208,
        "prompt_en": "Extract and return the history entries (HISTORY) from the header information of the FITS file named 'history_header.fits'.",
        "prompt_zh": "提取并返回名为'history_header.fits'的FITS文件中头部信息的历史条目(HISTORY)。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.io import fits\n    filename = fits.util.get_testdata_filepath('history_header.fits')\n    with fits.open(filename) as hdul:  \n        hdr = hdul[0].header\n    history_entries = hdr['HISTORY']\n    return history_entries\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 检查值是否相等\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 209,
        "prompt_en": "Add a keyword named 'DARKCORR' to the Header of a FITS file, set its value to 'OMIT', and add a comment 'Dark Image Subtraction' for this keyword. Then, return the value of this keyword and its comment.",
        "prompt_zh": "在一个FITS文件的Header中添加一个名为'DARKCORR'的关键字，其值设置为'OMIT'，并为这个关键字添加注释'Dark Image Subtraction'。然后返回这个关键字的值以及其注释。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.io import fits\n    hdr = fits.Header()\n    hdr['DARKCORR'] = 'OMIT'  # 添加一个新的DARKCORR关键字\n    hdr.append(('DARKCORR', 'OMIT', 'Dark Image Subtraction'), end=True)\n    return hdr['DARKCORR'], hdr.comments['DARKCORR']\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n",
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 210,
        "prompt_en": "Add two undefined entries 'UNDEF2' and 'UNDEF3' in the FITS header information, where 'UNDEF3' has a comment 'Undefined value'. Return the value of the first newly added undefined entry 'UNDEF2' and the card information of the last entry.",
        "prompt_zh": "在FITS头部信息中新增两个未定义的项：'UNDEF2'和'UNDEF3'，其中'UNDEF3'带有一个注释'Undefined value'。返回新增的第一个未定义项'UNDEF2'的值以及最后一个条目的卡片信息。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.io import fits\n    hdr = fits.Header()\n    hdr.append('UNDEF2')\n    hdr.append(('UNDEF3', None, 'Undefined value'))\n    return hdr['UNDEF2'], str(hdr.cards[-1])\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    return data1 is None and data2 is None\n\n",
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 211,
        "prompt_en": "Create a new FITS primary header data unit and return its header information.",
        "prompt_zh": "创建一个新的FITS主头数据单元并返回其头部信息。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.io import fits\n    hdu = fits.PrimaryHDU()\n    return hdu.header\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 212,
        "prompt_en": "Open the FITS file 'test0.fits', modify the header information of its first HDU by setting the value of the keyword at index 34 to 20, and add a new keyword 'DARKCORR' with its value set to 'PERFORM'. Then, return the modified header information.",
        "prompt_zh": "打开FITS文件'test0.fits'，修改其第一个HDU的头信息，设置索引为34的关键字的值为20，并添加一个新的关键字'DARKCORR'，其值设为'PERFORM'，然后返回修改后的头信息。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.io import fits\n    fits_image_filename = fits.util.get_testdata_filepath('test0.fits')\n    hdul = fits.open(fits_image_filename)\n    hdr = hdul[0].header\n    hdr[34] = 20\n    hdr['DARKCORR'] = 'PERFORM'\n    hdul.close()\n    return hdr\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 213,
        "prompt_en": "Create a FITS file header and add the keyword `DARKCORR` with the value `OMIT`. Then, return the modified header object.",
        "prompt_zh": "创建一个FITS文件头部并添加关键字`DARKCORR`，其值为`OMIT`，然后返回这个修改后的头部对象。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.io import fits\n    hdr = fits.Header()\n    hdr['DARKCORR'] = 'OMIT'  # Add a new DARKCORR keyword\n    return hdr\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 214,
        "prompt_en": "Create a new FITS Header object and add a key named 'DARKCORR' with the value 'OMIT' and the comment 'Dark Image Subtraction'. Then, insert the same key, value, and comment at the 20th position in the Header again and return this Header object.",
        "prompt_zh": "创建一个新的FITS Header对象，为其添加名为'DARKCORR'的键，并设置值为'OMIT'，注释为'Dark Image Subtraction'。随后，在Header的第20个位置再次插入同样的键、值和注释，并返回这个Header对象。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.io import fits\n    hdr = fits.Header()\n    hdr['DARKCORR'] = ('OMIT', 'Dark Image Subtraction')\n    hdr.insert(20, ('DARKCORR', 'OMIT', 'Dark Image Subtraction'))\n    return hdr\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 215,
        "prompt_en": "Create a FITS Header object and add a keyword named 'NAXIS' with a value set to 2. Attach a comment to this keyword explaining it as 'The number of image axes'. Finally, return this Header object.",
        "prompt_zh": "创建一个FITS Header对象，添加一个名为'NAXIS'的关键字，其值设为2，并附上这个关键字的注释说明为'The number of image axes'。最后返回这个Header对象。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.io import fits\n    hdr = fits.Header()\n    hdr['NAXIS'] = 2\n    hdr.comments['NAXIS'] = 'The number of image axes'\n    return hdr\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 216,
        "prompt_en": "Extract and return a subsection of the data in the first HDU of the FITS file located at the path 'tutorials/FITS-images/HorseHead.fits'. The subsection should have row indices ranging from 30 to 40 (excluding 40) and column indices ranging from 10 to 20 (excluding 20).",
        "prompt_zh": "提取并返回位于路径'tutorials/FITS-images/HorseHead.fits'的FITS文件中，第一个HDU的数据的子区域，该子区域的行索引范围为30到40（不包括40），列索引范围为10到20（不包括20）。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.io import fits\n    from astropy.utils.data import get_pkg_data_filename\n    fits_image_filename = get_pkg_data_filename('tutorials/FITS-images/HorseHead.fits')\n    with fits.open(fits_image_filename) as hdul:\n        data = hdul[0].data\n    subsection = data[30:40, 10:20]\n    return subsection\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 217,
        "prompt_en": "Open the image file 'tutorials/FITS-images/HorseHead.fits' and replace all negative pixel values in the image data with 0. Return the modified data.",
        "prompt_zh": "打开'tutorials/FITS-images/HorseHead.fits'图像文件，将图像数据中的所有负值像素替换为0，并返回修改后的数据。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.io import fits\n    from astropy.utils.data import get_pkg_data_filename\n    fits_image_filename = get_pkg_data_filename('tutorials/FITS-images/HorseHead.fits')\n    with fits.open(fits_image_filename) as hdul:\n        data = hdul[0].data\n    data[data < 0] = 0\n    return data\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 218,
        "prompt_en": "Extract data from the second HDU of the FITS file named 'test0.fits' and return a subsection of the data approximately located between rows 30 to 40 and columns 10 to 20 of the pixel data.",
        "prompt_zh": "从名为'test0.fits'的FITS文件中提取第二个HDU的数据，并返回该数据的一个子区域，大致位于第30至40行和第10至20列之间的像素数据。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.io import fits\n  fits_image_filename = fits.util.get_testdata_filepath('test0.fits')\n  with fits.open(fits_image_filename) as hdul:\n      data = hdul[1].data\n  subsection = data[30:40, 10:20]\n  return subsection\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 219,
        "prompt_en": "Modify the pixel values in the second data unit (HDU) of the FITS file named 'test0.fits' to 0 for rows 30 to 40 and columns 10 to 20. Return the data of the modified region.",
        "prompt_zh": "在名为'test0.fits'的FITS文件中，修改第二个数据单元（HDU）内第30至40行、第10至20列的像素值为0，并返回这个修改后区域的数据。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.io import fits\n  fits_image_filename = fits.util.get_testdata_filepath('test0.fits')\n  with fits.open(fits_image_filename) as hdul:\n      data = hdul[1].data\n      data[30:40, 10:20] = 0\n  return data[30:40, 10:20]\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 220,
        "prompt_en": "Open the FITS file named 'scale.fits' and return the value of the first data point in the first HDU, the data type of the data array, and the value of the 'bitpix' keyword in the header.",
        "prompt_zh": "打开名为'scale.fits'的FITS文件，并返回第一个HDU中第一个数据点的值、数据数组的数据类型以及头信息中'bitpix'关键字的值。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.io import fits\n  fits_image_filename = fits.util.get_testdata_filepath('scale.fits')\n  with fits.open(fits_image_filename) as hdul:\n    hdu = hdul[0]\n    scaled_value = hdu.data[0, 0]\n    data_type = hdu.data.dtype.name\n    updated_bitpix = hdu.header['bitpix']\n  return scaled_value, data_type, updated_bitpix\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 检查值是否相等\n    return data1 == data2\n\n",
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n",
            "\ndef test_code(data1, data2):\n    # 直接比较两个整数是否相同\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 221,
        "prompt_en": "Compare the keywords and corresponding values of two FITS header objects fits.Header([('KEY_A', 1), ('KEY_B', 2)]) and fits.Header([('KEY_A', 3), ('KEY_C', 4)]). Return the result as a Python dictionary in the form { 'identical': 'whether completely identical', 'diff_keywords': 'which keywords are different', 'diff_keyword_values': 'which keyword values are different'}.",
        "prompt_zh": "对比两个FITS头部对象fits.Header([('KEY_A', 1), ('KEY_B', 2)])和fits.Header([('KEY_A', 3), ('KEY_C', 4)])的关键字和对应的值，用python dict的形式返回{ 'identical':'是否完全一致','diff_keywords':'哪些关键词不同', 'diff_keyword_values': '哪些关键字的值有所不同'}",
        "canonical_solution": "def canonical_solution():\n    from astropy.io import fits\n    header1 = fits.Header([('KEY_A', 1), ('KEY_B', 2)])\n    header2 = fits.Header([('KEY_A', 3), ('KEY_C', 4)])\n    diff = fits.diff.HeaderDiff(header1, header2)\n    return {\n        'identical': diff.identical,\n        'diff_keywords': diff.diff_keywords,\n        'diff_keyword_values': diff.diff_keyword_values\n    }\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    # 检查两个字典的键是否完全相同\n    if data1.keys() != data2.keys():\n        return False\n\n    # 检查每个键对应的值是否相同\n    for key in data1:\n        # 可以这里添加递归比较的逻辑，如果值是复杂的数据结构\n        if not np.all(data1[key] == data2[key]):\n            return False\n    \n    # 如果所有检查都通过，则认为两个字典一致\n    return True\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 222,
        "prompt_en": "Open the FITS file named 'btable.fits', read the first two rows of table data from the first extension, then close the file and return the extracted data.",
        "prompt_zh": "打开名为'btable.fits'的FITS文件，读取第一个扩展中的表格数据的前两行，然后关闭文件并返回提取的数据。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.io import fits\n  fits_table_filename = fits.util.get_testdata_filepath('btable.fits')\n  hdul = fits.open(fits_table_filename)  # open a FITS file\n  data = hdul[1].data  # assume the first extension is a table\n  # show the first two rows\n  first_two_rows = data[:2]\n  hdul.close()\n  return first_two_rows\n\n\n",
        "test_code": [
            "def test_code(data1, data2):\n  if len(data1.columns)!=len(data2.columns):\n     return False\n  for item1,item2 in zip(data1.columns,data2.columns):\n     if item1!=item2:\n        return False\n     for item in item1.array==item2.array:\n        if not item:\n           return False\n  if data1.dtype!=data2.dtype:\n     return False\n  for item in data1==data2:\n    if not item:\n        return False\n  return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 223,
        "prompt_en": "Open a FITS file named 'ascii.fits', read, and return the first record of the data from the second HDU of the file.",
        "prompt_zh": "打开一个名为'ascii.fits'的FITS文件，读取并返回该文件第二个HDU的数据中的第一条记录。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.io import fits\n    filename = fits.util.get_testdata_filepath('ascii.fits')\n    hdul = fits.open(filename)\n    return hdul[1].data[:1]\n\n\n",
        "test_code": [
            "def test_code(data1, data2):\n  if len(data1.columns)!=len(data2.columns):\n     return False\n  for item1,item2 in zip(data1.columns,data2.columns):\n     if item1!=item2:\n        return False\n     for item in item1.array==item2.array:\n        if not item:\n           return False\n  if data1.dtype!=data2.dtype:\n     return False\n  for item in data1==data2:\n    if not item:\n        return False\n  return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 224,
        "prompt_en": "Read the FITS file named 'compressed_image.fits' and return the data from the second HDU (Header Data Unit) in the file.",
        "prompt_zh": "读取名为'compressed_image.fits'的FITS文件，并返回文件中第二个HDU（Header Data Unit）的数据。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.io import fits\n    filename = fits.util.get_testdata_filepath('compressed_image.fits')\n    hdul = fits.open(filename)\n    return hdul[1].data\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 225,
        "prompt_en": "Open the FITS file named 'ascii.fits' and read the data from the column named 'a' in the second HDU (Header Data Unit) of the file. Then, close the FITS file and return the extracted data.",
        "prompt_zh": "打开名为'ascii.fits'的FITS文件，从文件的第二个HDU（Header Data Unit）中读取名为'a'的列的数据，然后关闭FITS文件并返回提取的数据。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.io import fits\n    filename = fits.util.get_testdata_filepath('ascii.fits')\n    hdul = fits.open(filename)\n    data = hdul[1].data['a']\n    hdul.close()\n    return data\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 226,
        "prompt_en": "Create a FITS table containing three columns of data. The first column is named 'abc', with format 'A3', and contains the string array ['abcd', 'def']. The second column is named 'def', with format 'E', and contains the float array [11.0, 12.0], scaled by 2.3 with a zero point of 0.6. The third column is named 't1', with format 'I', and contains the integer array [91, 92, 93]. Finally, return the data from this FITS table.",
        "prompt_zh": "创建一个FITS表，其中包含三列数据。第一列名为'abc'，格式为'A3'，包含字符串数组['abcd', 'def']；第二列名为'def'，格式为'E'，包含浮点数数组[11.0, 12.0]，以2.3为比例尺和0.6为零点；第三列名为't1'，格式为'I'，包含整数数组[91, 92, 93]。最后返回这个FITS表的数据。\n\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.io import fits\n    import numpy as np\n    a1 = np.array(['abcd', 'def'])\n    r1 = np.array([11., 12.])\n    col1 = fits.Column(name='abc', format='A3', array=a1, ascii=True)\n    col2 = fits.Column(name='def', format='E', array=r1, bscale=2.3,\n                       bzero=0.6, ascii=True)\n    col3 = fits.Column(name='t1', format='I', array=[91, 92, 93], ascii=True)\n    hdu = fits.TableHDU.from_columns([col1, col2, col3])\n    return hdu.data\n\n\n",
        "test_code": [
            "def test_code(data1, data2):\n  if len(data1.columns)!=len(data2.columns):\n     return False\n  for item1,item2 in zip(data1.columns,data2.columns):\n     if item1!=item2:\n        return False\n     for item in item1.array==item2.array:\n        if not item:\n           return False\n  if data1.dtype!=data2.dtype:\n     return False\n  for item in data1==data2:\n    if not item:\n        return False\n  return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 227,
        "prompt_en": "Create a FITS card object with the content 'FIX1 = 2.1e23'. Perform verification and fix any issues silently without raising error warnings. Finally, return the string representation of the fixed FITS card object.",
        "prompt_zh": "创建一个FITS卡片对象，内容为'FIX1 = 2.1e23'，并在不引起错误警告的情况下进行校验和修复，最终返回修复后的FITS卡片对象的字符串表示形式。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.io import fits\n    c = fits.Card.fromstring('FIX1    = 2.1e23')\n    c.verify('silentfix')\n    result = str(c)\n    return result\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 228,
        "prompt_en": "Open the FITS file named 'checksum.fits', verify its checksum, then extract and return the header information of the first HDU.",
        "prompt_zh": "打开名为'checksum.fits'的FITS文件，并验证其校验和，然后提取并返回第一个HDU的头部信息。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.io import fits\n    filename = fits.util.get_testdata_filepath('checksum.fits')\n    with fits.open(filename, checksum=True) as hdul:\n        result = hdul[0].header\n    return result\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 229,
        "prompt_en": "Serialize a time in Modified Julian Date (MJD) format and a location on Earth into a YAML formatted string, then deserialize this string back into a time object, and return the time object. The time value is 2457389.0, and the Earth location coordinates are (1000, 2000, 3000) kilometers.",
        "prompt_zh": "将一个修正儒略日格式的时间和地球上一点的位置序列化为YAML格式的字符串，之后再从这个字符串反序列化为时间对象，并返回这个时间对象。时间数值为2457389.0，地球位置坐标为(1000, 2000, 3000)公里。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.io.misc import yaml\n    from astropy.time import Time\n    from astropy.coordinates import EarthLocation\n    import astropy.units as u\n\n    t = Time(2457389.0, format='mjd', location=EarthLocation(1000, 2000, 3000, unit=u.km))\n    td = yaml.dump(t)\n    ty = yaml.load(td)\n    return ty\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 230,
        "prompt_en": "Create an Astropy Table object and add three columns of data to it: the first column is named 'a' and contains integers [1, 4, 5]; the second column is named 'b' and contains strings ['x', 'y', 'z']; the third column is named 'c' and contains floats [2.0, 5.0, 8.5]. Finally, return the complete table object.",
        "prompt_zh": "创建一个Astropy Table对象，并在其内添加三列数据：第一列名为'a'，包含整数[1, 4, 5]；第二列名为'b'，包含字符串['x', 'y', 'z']；第三列名为'c'，包含浮点数[2.0, 5.0, 8.5]。最后返回完整的表格对象。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.table import Table\n  t = Table()\n  t['a'] = [1, 4, 5]\n  t['b'] = ['x', 'y', 'z']\n  t['c'] = [2.0, 5.0, 8.5]\n  return t\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 231,
        "prompt_en": "Read the file from the FTP address `ftp://cdsarc.u-strasbg.fr/pub/cats/VII/253/snrs.dat`, and use the associated `ReadMe` file \"ftp://cdsarc.u-strasbg.fr/pub/cats/VII/253/ReadMe\" to understand the data format. Read this data using the ascii.cds format and return the Astropy Table object obtained.",
        "prompt_zh": "从FTP地址`ftp://cdsarc.u-strasbg.fr/pub/cats/VII/253/snrs.dat`读取文件，并使用与之相关的`ReadMe`文件\"ftp://cdsarc.u-strasbg.fr/pub/cats/VII/253/ReadMe\"来理解数据格式，使用ascii.cds格式读取这些数据，并返回读取的Astropy Table对象。",
        "canonical_solution": "from astropy.table import Table\ndef canonical_solution():\n    t = Table.read(\"ftp://cdsarc.u-strasbg.fr/pub/cats/VII/253/snrs.dat\", \n                   readme=\"ftp://cdsarc.u-strasbg.fr/pub/cats/VII/253/ReadMe\", \n                   format=\"ascii.cds\")\n    return t\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 232,
        "prompt_en": "Create a QTable object using the Astropy library, containing a list of lengths [1, 2] in angstrom units. Write this table to the file '`my_table.fits`', then read the table from the same file, and return the read QTable object.",
        "prompt_zh": "利用Astropy库创建一个QTable对象，其中包含以埃为单位的长度列表[1, 2]，将该表格写入'`my_table.fits`'文件，然后从同一个文件读取该表格，并返回读取到的QTable对象。\n",
        "canonical_solution": "from astropy.table import QTable\nimport astropy.units as u\ndef canonical_solution():\n    t = QTable([[1, 2]*u.angstrom])\n    t.write('my_table.fits', overwrite=True)\n    qt = QTable.read('my_table.fits')\n    return qt\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 233,
        "prompt_en": "Create a composite model that first shifts the input coordinates by -1 unit along both the x and y axes, then scales the coordinates by a factor of 2 along the x axis and by a factor of 3 along the y axis. Replace the scaling operation with a 90-degree rotation operation. Apply this new model to the coordinates (2, 1) and return the transformed result.",
        "prompt_zh": "创建一个组合模型，这个模型首先将输入坐标沿x和y轴分别平移-1个单位，然后沿x和y轴分别放大2倍和3倍，然后将缩放操作替换为一个90度的旋转操作。将这个新的模型应用到坐标(2,1)上，返回变换后的结果。",
        "canonical_solution": "def canonical_solution():\n    from astropy.modeling.models import Shift, Scale, Rotation2D\n    shift = Shift(-1) & Shift(-1)\n    scale = Scale(2) & Scale(3)\n    scale.name = \"Scale\"\n    model = shift | scale\n    new_model = model.replace_submodel('Scale', Rotation2D(90, name='Rotation'))\n    result = new_model(2, 1)\n    return result\n\n\n",
        "test_code": [
            "\nimport math\n\ndef test_code(data1, data2):\n    # 设置绝对误差容许值\n    abs_tol = 1e-8\n    # 使用math.isclose来比较两个浮点数是否在误差范围内相等\n    return math.isclose(data1, data2, abs_tol=abs_tol)\n\n",
            "\nimport math\n\ndef test_code(data1, data2):\n    # 设置绝对误差容许值\n    abs_tol = 1e-8\n    # 使用math.isclose来比较两个浮点数是否在误差范围内相等\n    return math.isclose(data1, data2, abs_tol=abs_tol)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 234,
        "prompt_en": "Create two one-dimensional Gaussian models: the first model has an amplitude of 1, a mean of 0, and a standard deviation of 0.2; the second model has an amplitude of 2.5, a mean of 0.5, and a standard deviation of 0.1. Add these two models together. Calculate and return the value of the composite model at x=0.25.",
        "prompt_zh": "创建两个一维高斯模型，第一个模型幅值为1，中心在0，标准差为0.2；第二个模型幅值为2.5，中心在0.5，标准差为0.1，并将这两个模型相加。计算并返回复合模型在x=0.25处的值。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.modeling import models\n    g1 = models.Gaussian1D(1, 0, 0.2)\n    g2 = models.Gaussian1D(2.5, 0.5, 0.1)\n    g1_plus_g2 = g1 + g2\n    return g1_plus_g2(0.25)\n\n\n",
        "test_code": [
            "\nimport math\n\ndef test_code(data1, data2):\n    # 设置绝对误差容许值\n    abs_tol = 1e-8\n    # 使用math.isclose来比较两个浮点数是否在误差范围内相等\n    return math.isclose(data1, data2, abs_tol=abs_tol)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 235,
        "prompt_en": "Create two one-dimensional Gaussian models; the first model has an amplitude, mean, and standard deviation of 1, -1, and 1 respectively, while the second model has an amplitude, mean, and standard deviation of 1, 1, and 1. Perform FFT convolution on these two models. Then, generate a uniform series of 50 points in the interval from -3 to 3, and compute the values of the convolved model on this series.",
        "prompt_zh": "创建两个一维高斯模型，第一个模型的幅度、均值和标准差为1、-1、1，第二个模型的幅度、均值和标准差为1、1、1。对这两个模型进行FFT卷积。然后在-3到3的区间内均匀生成一个包含50个点的数列，并计算卷积模型在这个数列上的值。\n",
        "canonical_solution": "def canonical_solution():\n    import numpy as np\n    from astropy.modeling import models\n    from astropy.convolution import convolve_models\n    g1 = models.Gaussian1D(1, -1, 1)\n    g2 = models.Gaussian1D(1, 1, 1)\n    g3 = convolve_models(g1, g2, mode='convolve_fft')\n    x = np.linspace(-3, 3, 50)\n    return g3(x)\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 236,
        "prompt_en": "Retrieve and list the types of model constraints supported by the LinearLSQFitter class in Astropy.",
        "prompt_zh": "获取并列出Astropy中LinearLSQFitter类支持的模型约束类型。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.modeling import fitting\n    return fitting.LinearLSQFitter.supported_constraints\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 比较列表长度和元素内容\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 237,
        "prompt_en": " Retrieve the list of model constraint types supported by the LevMarLSQFitter fitter in the Astropy library.",
        "prompt_zh": "获取Astropy库中LevMarLSQFitter拟合器支持的模型约束类型列表。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.modeling import fitting\n    return fitting.LevMarLSQFitter.supported_constraints\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 比较列表长度和元素内容\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 238,
        "prompt_en": " List the types of constraints supported by the SLSQPLSQFitter fitter in Astropy model fitting.",
        "prompt_zh": "列出Astropy模型拟合中SLSQPLSQFitter拟合器支持的约束类型。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.modeling import fitting\n    return fitting.SLSQPLSQFitter.supported_constraints\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 比较列表长度和元素内容\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 239,
        "prompt_en": "Create a one-dimensional Gaussian distribution model with an amplitude of 1, a mean of 0, and a standard deviation of 1. Calculate the function value at x=0.",
        "prompt_zh": "创建一个幅度为1、均值为0、标准差为1的一维高斯分布模型，并计算在x=0处的函数值。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.modeling.models import Gaussian1D\n    g = Gaussian1D(amplitude=1, mean=0, stddev=1)\n    return g(0)\n\n\n",
        "test_code": [
            "\nimport math\n\ndef test_code(data1, data2):\n    # 设置绝对误差容许值\n    abs_tol = 1e-8\n    # 使用math.isclose来比较两个浮点数是否在误差范围内相等\n    return math.isclose(data1, data2, abs_tol=abs_tol)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 240,
        "prompt_en": "Create a one-dimensional Gaussian model with an amplitude of 1.2, a mean of 0.9, and a standard deviation of 0.5. Return the amplitude, mean, and standard deviation parameters of the model.",
        "prompt_zh": "创建一个振幅为1.2、均值为0.9、标准偏差为0.5的一维高斯模型，并返回该模型的振幅、均值和标准偏差参数。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.modeling import models\n    g = models.Gaussian1D(amplitude=1.2, mean=0.9, stddev=0.5)\n    return g.amplitude, g.mean, g.stddev\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n",
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n",
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 241,
        "prompt_en": "Create a one-dimensional Gaussian function with an amplitude of 1.2, mean of 0.9, and a standard deviation of 0.5. Compute the function value at x=0.1.",
        "prompt_zh": "创建一个一维高斯函数，其幅值为1.2，均值为0.9，标准差为0.5，并计算在x=0.1处的函数值。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.modeling import models\n    g = models.Gaussian1D(amplitude=1.2, mean=0.9, stddev=0.5)\n    result = g(0.1)\n    return result\n\n\n",
        "test_code": [
            "\nimport math\n\ndef test_code(data1, data2):\n    # 设置绝对误差容许值\n    abs_tol = 1e-8\n    # 使用math.isclose来比较两个浮点数是否在误差范围内相等\n    return math.isclose(data1, data2, abs_tol=abs_tol)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 242,
        "prompt_en": "Create a linear model with a slope of 0.8 and an intercept of 1.0, then calculate the input value corresponding to an output value of 2.0 when the linear model is inverted.",
        "prompt_zh": "创建一个线性模型，斜率为0.8，截距为1.0，然后计算该线性模型逆转时，输出值为2.0所对应的输入值。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.modeling import models\n    linear = models.Linear1D(slope=0.8, intercept=1.0)\n    return linear.inverse(2.0)\n\n\n",
        "test_code": [
            "\nimport math\n\ndef test_code(data1, data2):\n    # 设置绝对误差容许值\n    abs_tol = 1e-8\n    # 使用math.isclose来比较两个浮点数是否在误差范围内相等\n    return math.isclose(data1, data2, abs_tol=abs_tol)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 243,
        "prompt_en": "Create a Gaussian model set containing three Gaussian function models, with amplitudes of 1, 1.5, and 2, respectively. Set the means of all models consecutively at 0, 1, 2, with a standard deviation of 1.0 for each. Compute the output values of this set of models at an independent variable value of 1.0 and return these values.",
        "prompt_zh": "创建一组包含三个高斯函数模型的高斯模型集合，每个模型的幅度分别为1, 1.5, 2，所有模型的均值依次为0, 1, 2，标准差均设置为1.0。计算自变量值为1.0时这组模型的输出值，并返回这些值。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.modeling import models\n    gset = models.Gaussian1D(amplitude=[1, 1.5, 2], mean=[0, 1, 2], stddev=[1., 1., 1.], n_models=3)\n    return gset(1.0)\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 244,
        "prompt_en": "Create a composite Gaussian model containing two Gaussian components with amplitudes of 1 and 2 respectively, both with a mean of 0, and standard deviations set to 0.1 and 0.2. Then calculate the function values of this composite model at x equals 0 and 0.1.",
        "prompt_zh": "创建一个复合高斯模型，包含两个高斯成分，这两个成分的幅度分别为1和2，均值都设定为0，标准差分别设置为0.1和0.2。然后计算这个复合模型在x等于0和0.1时的函数值。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.modeling import models\n    g = models.Gaussian1D(amplitude=[1, 2], mean=[0, 0], stddev=[0.1, 0.2], n_models=2)\n    return g([0, 0.1])\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 245,
        "prompt_en": "Create a one-dimensional Gaussian model with a specified amplitude of 1, a mean of 0, and a standard deviation of 1. Evaluate the Gaussian function at 100 equally spaced points from -5 to 5, and return the computed values.",
        "prompt_zh": "创建一个具有指定振幅1、均值0以及标准差1的一维高斯模型，对于在-5到5之间等间距的100个点进行高斯函数的求值，并返回这些计算出的值。\n",
        "canonical_solution": "import numpy as np\nfrom astropy.modeling import Fittable1DModel, Parameter\nclass Gaussian1D(Fittable1DModel):\n    amplitude = Parameter()\n    mean = Parameter()\n    stddev = Parameter()\n    @staticmethod\n    def evaluate(x, amplitude, mean, stddev):\n        return amplitude * np.exp((-(1 / (2. * stddev**2)) * (x - mean)**2))\n    \n    @staticmethod\n    def fit_deriv(x, amplitude, mean, stddev):\n        d_amplitude = np.exp((-(1 / (stddev**2)) * (x - mean)**2))\n        d_mean = (2 * amplitude *\n                  np.exp((-(1 / (stddev**2)) * (x - mean)**2)) *\n                  (x - mean) / (stddev**2))\n        d_stddev = (2 * amplitude *\n                    np.exp((-(1 / (stddev**2)) * (x - mean)**2)) *\n                    ((x - mean)**2) / (stddev**3))\n        return [d_amplitude, d_mean, d_stddev]\ndef canonical_solution():\n  x = np.linspace(-5, 5, 100)\n  gaussian_model = Gaussian1D(amplitude=1, mean=0, stddev=1)\n  y_evaluated = gaussian_model.evaluate(x, gaussian_model.amplitude.value, gaussian_model.mean.value, gaussian_model.stddev.value)\n  \n  return y_evaluated\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 246,
        "prompt_en": "Create a cubic polynomial model with coefficients c0=1.0, c1=0.0, c2=2.0, c3=3.0, and return the list of parameter names for that model.",
        "prompt_zh": "创建一个三次多项式模型，系数分别为c0=1.0，c1=0.0，c2=2.0，c3=3.0，并返回该模型的参数名称列表。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.modeling.models import Polynomial1D\n  p = Polynomial1D(degree=3, c0=1.0, c1=0.0, c2=2.0, c3=3.0)\n  return p.param_names\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n",
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n",
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n",
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 247,
        "prompt_en": "Create a two-dimensional Chebyshev polynomial model with the highest degree of x as 2 and y as 3. Specify the coefficients as {\n    'c0_0': [0, 10], 'c0_1': [3, 13],\n    'c0_2': [6, 16], 'c0_3': [9, 19],\n    'c1_0': [1, 11], 'c1_1': [4, 14],\n    'c1_2': [7, 17], 'c1_3': [10, 20],\n    'c2_0': [2, 12], 'c2_1': [5, 15],\n    'c2_2': [8, 18], 'c2_3': [11, 21]\n  }. Return the parameter set of the model.",
        "prompt_zh": "创建一个二维切比雪夫多项式模型，设定x的最高次数为2、y的最高次数为3，并指定多项式的系数{\n    'c0_0': [0, 10], 'c0_1': [3, 13],\n    'c0_2': [6, 16], 'c0_3': [9, 19],\n    'c1_0': [1, 11], 'c1_1': [4, 14],\n    'c1_2': [7, 17], 'c1_3': [10, 20],\n    'c2_0': [2, 12], 'c2_1': [5, 15],\n    'c2_2': [8, 18], 'c2_3': [11, 21]\n  }。返回该模型的参数集合。",
        "canonical_solution": "def canonical_solution():\n  from astropy.modeling.models import Chebyshev2D\n  coeffs = {\n    'c0_0': [0, 10], 'c0_1': [3, 13],\n    'c0_2': [6, 16], 'c0_3': [9, 19],\n    'c1_0': [1, 11], 'c1_1': [4, 14],\n    'c1_2': [7, 17], 'c1_3': [10, 20],\n    'c2_0': [2, 12], 'c2_1': [5, 15],\n    'c2_2': [8, 18], 'c2_3': [11, 21]\n  }\n  ch2 = Chebyshev2D(x_degree=2, y_degree=3, **coeffs)\n  return ch2.param_sets\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 248,
        "prompt_en": "For the given two-dimensional array c2 and one-dimensional array c1, multiply each element within c2 by 4 (i.e., the square of 2), add it to the corresponding element in c1 multiplied by 2, and then add 1 to the overall result. Return the new array obtained.",
        "prompt_zh": "对给定的二维数组c2和一维数组c1，将c2内的每个元素乘以4（即2的平方），与c1的对应元素（乘以2）的和相加，再整体加上1，返回得到的新数组。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.modeling.models import Polynomial1D\n  import numpy as np\n  c2 = np.array([[4.0, 5.0],\n                 [6.0, 7.0],\n                 [8.0, 9.0]])\n  c1 = np.array([2.0, 3.0])\n  coeff_result = c2 * 2.0**2 + c1 * 2.0 + 1.0\n  return coeff_result\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 249,
        "prompt_en": "Generate a logarithmically spaced array with 1000 points ranging from 1000 angstroms to 30000 angstroms, and calculate the radiative intensity of a blackbody radiation model at these wavelength points for a temperature of 10000 Kelvin.",
        "prompt_zh": "生成一个在1000埃到30000埃波长范围内，拥有1000个点数的对数等距数组，并计算温度为10000开尔文的黑体辐射模型在这些波长点上的辐射强度。\n",
        "canonical_solution": "def canonical_solution():\n    import numpy as np\n    from astropy.modeling.models import BlackBody\n    import astropy.units as u\n    \n    wavelength = np.logspace(np.log10(1000), np.log10(3e4), num=1000) * u.AA\n    temperature = 10000 * u.K\n    bb = BlackBody(temperature=temperature, scale=1.0)\n    bb_result = bb(wavelength)\n    \n    return bb_result\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 250,
        "prompt_en": "Create an NFW model representing a dark matter halo, with a mass of 2.0E15 solar masses, a concentration of 8.5, and a redshift of 0.63, using the Planck15 cosmological model. Specify the mass definition as 200 times the critical density. Calculate and return the dark matter density profile from a range of 0.01 to 20 megaparsecs.",
        "prompt_zh": "创建一个代表暗物质晕的NFW模型，设置质量为2.0E15太阳质量、集中度为8.5、红移为0.63，并使用Planck15宇宙学模型。指定质量定义为临界密度的200倍。计算并返回从0.01到20兆秒差距范围内的暗物质密度轮廓。\n",
        "canonical_solution": "def canonical_solution():\n    import numpy as np\n    from astropy.modeling.models import NFW\n    import astropy.units as u\n    from astropy import cosmology\n\n    mass = u.Quantity(2.0E15, u.M_sun)\n    concentration = 8.5\n    redshift = 0.63\n    cosmo = cosmology.Planck15\n    massfactor = (\"critical\", 200)\n    \n    n = NFW(mass=mass, concentration=concentration, redshift=redshift, cosmo=cosmo, massfactor=massfactor)\n    \n    radii = np.linspace(0.01, 20, num=1000) * u.Mpc\n    n_result = n(radii)\n    \n    return n_result\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 251,
        "prompt_en": "Create a blackbody radiation model with a temperature set at 10,000 K and calculate the radiative intensity values at 1,000 logarithmically spaced points in the wavelength range from 1,000 Å to 30,000 Å. Return these values as an array of pure numbers.",
        "prompt_zh": "创建一个黑体辐射模型，设定温度为10000 K，并计算在1000埃到30000埃波长范围内对数等分的1000个点上的辐射强度值，返回这些值的纯数值数组。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.modeling.models import BlackBody\n    import astropy.units as u\n    import numpy as np\n\n    wavelength = np.logspace(np.log10(1000), np.log10(3e4), num=1000) * u.AA\n    temperature = 10000 * u.K\n    bb = BlackBody(temperature=temperature, scale=10000.0)\n    bb_result = bb(wavelength)\n\n    return bb_result.value\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 252,
        "prompt_en": "Create a Drude1D model with 1000 points in the wavelength range from 1000 Å to 4000 Å. The model should have an amplitude of 1.0, a central wavelength of 2175 Å, and a full-width at half-maximum (FWHM) of 400 Å. Calculate the Drude model values within this wavelength range and return their numerical values.",
        "prompt_zh": "创建一个波长范围在1000埃到4000埃，有1000个点的Drude1D模型。该模型的振幅为1.0，中心波长为2175埃，全宽半高为400埃。计算这个波长范围内的Drude模型值，并返回它们的数值。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.modeling.models import Drude1D\n    import astropy.units as u\n    import numpy as np\n\n    wavelengths = np.linspace(1000, 4000, num=1000) * u.AA\n    amplitude = 1.0\n    x_0 = 2175. * u.AA\n    fwhm = 400. * u.AA\n    drude = Drude1D(amplitude=amplitude, x_0=x_0, fwhm=fwhm)\n    drude_result = drude(wavelengths)\n\n    return drude_result.value\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 253,
        "prompt_en": "Create a second-order one-dimensional polynomial model with a domain of [-2, 2] and a window of [-1, 1], and calculate the polynomial result at the value of 1.",
        "prompt_zh": "创建一个定义域为[-2, 2]和窗口为[-1, 1]的二阶一维多项式模型，并计算在值1处的多项式结果。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.modeling import models\n    p1 = models.Polynomial1D(degree=2, domain=[-2,2], window=[-1,1])\n    return p1(1)\n\n\n",
        "test_code": [
            "\nimport math\n\ndef test_code(data1, data2):\n    # 设置绝对误差容许值\n    abs_tol = 1e-8\n    # 使用math.isclose来比较两个浮点数是否在误差范围内相等\n    return math.isclose(data1, data2, abs_tol=abs_tol)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 254,
        "prompt_en": "Create a quadratic one-dimensional Chebyshev model defined on the interval from 0 to 2 with the window in the interval from -1 to 1, and calculate its value at the point 1.5.",
        "prompt_zh": "创建一个定义在0到2区间、窗口在-1到1区间的二次一维切比雪夫模型，并计算在1.5这一点的值。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.modeling import models\n    cheb2 = models.Chebyshev1D(degree=2, domain=[0,2], window=[-1,1])\n    return cheb2(1.5)\n\n\n",
        "test_code": [
            "\nimport math\n\ndef test_code(data1, data2):\n    # 设置绝对误差容许值\n    abs_tol = 1e-8\n    # 使用math.isclose来比较两个浮点数是否在误差范围内相等\n    return math.isclose(data1, data2, abs_tol=abs_tol)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 255,
        "prompt_en": "Create a two-dimensional Legendre polynomial model with both x and y being of degree 1. Calculate the model value at point (0.5, 0.5), within the domain and window defined as the interval from [-1,1] to [0,1].",
        "prompt_zh": "创建一个x和y均为一次的二维勒让德多项式模型，并计算其在定义域以及窗口均为[-1,1]到[0,1]区间内，点(0.5, 0.5)的模型值。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.modeling import models\n    legendre2 = models.Legendre2D(x_degree=1, y_degree=1, x_domain=[-1,1], y_domain=[-1,1], x_window=[0,1], y_window=[0,1])\n    return legendre2(0.5, 0.5)\n\n\n",
        "test_code": [
            "\nimport math\n\ndef test_code(data1, data2):\n    # 设置绝对误差容许值\n    abs_tol = 1e-8\n    # 使用math.isclose来比较两个浮点数是否在误差范围内相等\n    return math.isclose(data1, data2, abs_tol=abs_tol)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 256,
        "prompt_en": "Create a third-degree Hermite polynomial with a domain from 0 to 2 and a window from -1 to 1. Compute the value of the polynomial at x=0.8.",
        "prompt_zh": "创建一个3阶Hermite多项式，其定义域为0到2，窗口为-1到1。计算在x=0.8处的多项式值。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.modeling import models\n    hermite2 = models.Hermite1D(degree=3, domain=[0,2], window=[-1,1])\n    return hermite2(0.8)\n\n\n",
        "test_code": [
            "\nimport math\n\ndef test_code(data1, data2):\n    # 设置绝对误差容许值\n    abs_tol = 1e-8\n    # 使用math.isclose来比较两个浮点数是否在误差范围内相等\n    return math.isclose(data1, data2, abs_tol=abs_tol)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 257,
        "prompt_en": "Create a one-dimensional Gaussian model with default parameters.",
        "prompt_zh": "创建一个默认参数的一维高斯模型。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.modeling import models\n    g = models.Gaussian1D()     # returns a 1D Gaussian model\n    return g\n\n\n",
        "test_code": [
            "def test_code(model1,model2):\n    if not model1.amplitude==model2.amplitude:\n        return False\n    if not model1.mean==model2.mean:\n        return False\n    if not model1.stddev==model2.stddev:\n        return False\n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 258,
        "prompt_en": "Create a one-dimensional trapezoid model with an amplitude of 1, centered at position 0, a width of 1, and a slope of 0.5.",
        "prompt_zh": "创建一个振幅为1，中心位置在0，宽度为1，斜率为0.5的一维梯形模型。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.modeling import models\n    tr = models.Trapezoid1D(amplitude=1, x_0=0, width=1, slope=0.5)   # returns a 1D trapezoid model\n    return tr\n\n\n",
        "test_code": [
            "def test_code(model1,model2):\n    if model1.param_names!=model2.param_names:\n        return False\n    if model1.amplitude != model2.amplitude:\n        return False\n    if model1.x_0 != model2.x_0:\n        return False\n    if model1.width != model2.width:\n        return False\n    if model1.slope != model2.slope:\n        return False\n    return True\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 259,
        "prompt_en": "Create a one-dimensional Gaussian model object with an amplitude of 1.2, a mean of 0.9, and a standard deviation of 0.5.",
        "prompt_zh": "创建一个幅度为1.2、均值为0.9、标准差为0.5的一维高斯模型对象。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.modeling import models\n    g = models.Gaussian1D(amplitude=1.2, mean=0.9, stddev=0.5)\n    return g\n\n\n",
        "test_code": [
            "def test_code(model1,model2):\n    if not model1.amplitude==model2.amplitude:\n        return False\n    if not model1.mean==model2.mean:\n        return False\n    if not model1.stddev==model2.stddev:\n        return False\n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 260,
        "prompt_en": "Create a one-dimensional trapezoid model with an amplitude of 3.3, a central position of 2.0, a width of 1.0, and edge slopes of 5.0, and return the model object.",
        "prompt_zh": "创建一个一维梯形模型，其幅度为3.3，中心位置为2.0，宽度为1.0，边缘斜率为5.0，并返回该模型对象。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.modeling import models\n    t = models.Trapezoid1D(amplitude=3.3, x_0=2.0, width=1.0, slope=5.0)\n    return t\n\n\n",
        "test_code": [
            "def test_code(model1,model2):\n    if model1.param_names!=model2.param_names:\n        return False\n    if model1.amplitude != model2.amplitude:\n        return False\n    if model1.x_0 != model2.x_0:\n        return False\n    if model1.width != model2.width:\n        return False\n    if model1.slope != model2.slope:\n        return False\n    return True\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 261,
        "prompt_en": "Create a 3x3 array with the following values:\\n\n[[3.0, 0.0, 0.0],\n [0.0, 2.0, 0.0],\n [0.0, 0.0, 0.0]]\\n\nUse the Tabular2D class from Astropy for 2D interpolation, defining the input value positions as points (1, 1), (2, 2), (3, 3). Set the bounds_error parameter to False, do not fill any values, and use the nearest neighbor interpolation method. Then use this model to obtain the interpolation result for the point at position (2, 2).",
        "prompt_zh": "创建一个3x3数组，值如下：\\n\n[[3.0, 0.0, 0.0],\n [0.0, 2.0, 0.0],\n [0.0, 0.0, 0.0]]\\n\n使用Astropy的Tabular2D类进行二维插值，定义输入值的位置为点(1, 1)、(2, 2)、(3, 3)。设置边界错误参数为False，不填充任何值，并使用最近邻插值方法。然后使用这个模型来获取位置(2, 2)点对应的插值结果。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.modeling.tabular import Tabular2D\n  import numpy as np\n  \n  table = np.array([[ 3.,  0.,  0.],\n                    [ 0.,  2.,  0.],\n                    [ 0.,  0.,  0.]])\n  points = ([1, 2, 3], [1, 2, 3])\n  t2 = Tabular2D(points, lookup_table=table, bounds_error=False,\n                 fill_value=None, method='nearest')\n\n  return t2(2, 2)\n\n\n",
        "test_code": [
            "\nimport math\n\ndef test_code(data1, data2):\n    # 设置绝对误差容许值\n    abs_tol = 1e-8\n    # 使用math.isclose来比较两个浮点数是否在误差范围内相等\n    return math.isclose(data1, data2, abs_tol=abs_tol)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 262,
        "prompt_en": "Fit a spline to Gaussian distributed data with noise and generate a fitted curve over a dense range of x-values. Specifically, fit the data with y-values generated by a Gaussian function exp(-x^2) plus 0.1 times standard normal distribution noise on 50 equally spaced x-values ranging from -3 to 3. Then, generate 1000 equally spaced points within the range of -3 to 3 and compute the corresponding y-values of the fitted spline curve.",
        "prompt_zh": "对包含噪声的高斯分布数据进行样条插值拟合，并生成一个密集的x值范围内的拟合曲线。具体而言，对范围在-3到3之间、点数为50的等距x值上，根据高斯函数exp(-x^2)加上0.1倍标准正态分布噪声生成的y值数据进行拟合。然后，在-3到3的范围内生成1000个等距点，并计算对应的拟合样条曲线的y值。",
        "canonical_solution": "def canonical_solution():\n  import numpy as np\n  from astropy.modeling.models import Spline1D\n  from astropy.modeling.fitting import SplineInterpolateFitter\n  rng = np.random.default_rng()\n  x = np.linspace(-3, 3, 50)\n  y = np.exp(-x**2) + 0.1 * rng.standard_normal(50)\n  spl = Spline1D()\n  fitter = SplineInterpolateFitter()\n  spl1 = fitter(spl, x, y)\n  xs = np.linspace(-3, 3, 1000)\n  return spl1(xs)\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 263,
        "prompt_en": "Create a one-dimensional Gaussian model with a mean of 3 meters, a standard deviation of 2 centimeters, and an amplitude of 3 Jansky. Return the mean of this model, including the unit information.",
        "prompt_zh": "创建一个一维高斯模型，其均值为3米，标准差为2厘米，振幅为3焦耳每秒，并返回该模型的均值，包含单位信息。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n    from astropy.modeling.models import Gaussian1D\n    g1 = Gaussian1D(mean=3 * u.m, stddev=2 * u.cm, amplitude=3 * u.Jy)\n    return g1.mean\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 264,
        "prompt_en": "Create a one-dimensional Gaussian model with a mean of 3 microns, a standard deviation of 1 micron, and an amplitude of 3 joules. Then, calculate the value of the model at a frequency of 110 terahertz.",
        "prompt_zh": "创建一个一维高斯模型，其平均值为3微米，标准偏差为1微米，振幅为3焦耳，然后计算模型在110太赫兹频率下的值。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n    from astropy.modeling.models import Gaussian1D\n    g4 = Gaussian1D(mean=3 * u.micron, stddev=1 * u.micron, amplitude=3 * u.Jy)\n    g4.input_units_equivalencies = {'x': u.spectral()}\n    return g4(110 * u.THz)\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 265,
        "prompt_en": "Create a one-dimensional Gaussian model with a mean, standard deviation, and amplitude set to 3 meters, 2 centimeters, and 3 Jy (Jansky), respectively. Extract and return the numerical value and unit of the model's mean. The return format should be a Python dictionary {'mean_value': **, 'mean_unit': **}, and note that 'mean_unit' should be returned as a string.",
        "prompt_zh": "创建一个一维高斯模型，其均值、标准差和振幅分别设为3米、2厘米和3焦耳(Jy)。提取并返回该模型均值的数值和单位，返回格式是python dict{'mean_value': **, 'mean_unit': **}，注意'mean_unit'返回字符串形式。",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n    from astropy.modeling.models import Gaussian1D\n    g1 = Gaussian1D(mean=3 * u.m, stddev=2 * u.cm, amplitude=3 * u.Jy)\n    mean_value = g1.mean.value\n    mean_unit = g1.mean.unit\n    return {'mean_value': mean_value, 'mean_unit': str(mean_unit)}\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    # 检查两个字典的键是否完全相同\n    if data1.keys() != data2.keys():\n        return False\n\n    # 检查每个键对应的值是否相同\n    for key in data1:\n        # 可以这里添加递归比较的逻辑，如果值是复杂的数据结构\n        if not np.all(data1[key] == data2[key]):\n            return False\n    \n    # 如果所有检查都通过，则认为两个字典一致\n    return True\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 266,
        "prompt_en": "Create a one-dimensional Gaussian model with a mean of 3 meters and a standard deviation of 5 centimeters. Calculate the function value at 2.9 meters and return the numerical part of the value without including the units.",
        "prompt_zh": "创建一个以3米为平均值、5厘米为标准差的一维高斯模型，并计算在2.9米处的函数值，返回该值的数值部分而不包含单位。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n    from astropy.modeling.models import Gaussian1D\n    g3 = Gaussian1D(mean=3 * u.m, stddev=5 * u.cm)\n    return g3(2.9 * u.m).value\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查两个浮点数是否近似相等\n    return np.isclose(data1, data2, atol=1e-8)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 267,
        "prompt_en": "Create a one-dimensional Gaussian model with a mean wavelength of 3 microns, a standard deviation of 1 micron, and an amplitude of 3 Jy. Then, calculate the model's value at a frequency of 110 THz.",
        "prompt_zh": "创建一个一维高斯模型，其平均波长为3微米，标准差为1微米，振幅为3焦耳/赫兹，然后计算模型在110 THz频率下的值。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n    from astropy.modeling.models import Gaussian1D\n    g4 = Gaussian1D(mean=3 * u.micron, stddev=1 * u.micron, amplitude=3 * u.Jy)\n    new_mean = 110 * u.THz\n    g4.input_units_equivalencies = {'x': u.spectral()}\n    return g4(new_mean).value\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查两个浮点数是否近似相等\n    return np.isclose(data1, data2, atol=1e-8)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 268,
        "prompt_en": "Create a first-order polynomial model with coefficients c0 equal to 1 and c1 equal to 2. Coerce the model to have input units in Hertz (Hz) and output units in seconds (s), considering the equivalency of frequency units. Then, calculate the result of the model when the input is 10 Hz and return the numerical result.",
        "prompt_zh": "创建一个一阶多项式模型，其系数c0为1，c1为2。强制模型输入单位为赫兹（Hz），输出单位为秒（s），考虑频率的单位等价性。然后计算模型在输入为10 Hz时的结果，并返回该数值结果。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.modeling import models\n    from astropy import units as u\n    model = models.Polynomial1D(1, c0=1, c1=2)\n    new_model = model.coerce_units(input_units={'x': u.Hz}, return_units={'y': u.s},\n                                   input_units_equivalencies={'x':u.spectral()})\n    return new_model(10 * u.Hz).value\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查两个浮点数是否近似相等\n    return np.isclose(data1, data2, atol=1e-8)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 269,
        "prompt_en": "Convert the integer 9 into a boolean mask, ignoring the flags at positions with the binary bits [1, 8, 64].",
        "prompt_zh": "将整数9转换为一个布尔掩码，忽略具有二进制位[1, 8, 64]的位置上的标志。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.nddata import bitmask\n    return bitmask.bitfield_to_boolean_mask(9, ignore_flags=[1, 8, 64])\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 270,
        "prompt_en": "Convert the integer value 217 into a boolean mask array, while ignoring the specific bit flag 80.",
        "prompt_zh": "将整数值217转换为一个布尔掩码数组，同时忽略特定的位标志80。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.nddata import bitmask\n    import numpy as np\n    return bitmask.bitfield_to_boolean_mask(217, ignore_flags=80)\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 271,
        "prompt_en": "Convert the given list of bitfield values [9, 10, 73, 217] into a boolean mask array. Ignore bit flags 1, 8, and 64 during the conversion process.",
        "prompt_zh": "将给定的位场值列表[9, 10, 73, 217]转换为布尔掩码数组，并在转换过程中忽略位标志1、8和64。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.nddata import bitmask\n    import numpy as np\n    return bitmask.bitfield_to_boolean_mask([9, 10, 73, 217], ignore_flags='1,8,64')\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 272,
        "prompt_en": "Create a one-dimensional array [1, 2, 3, 4] and encapsulate it using Astropy's NDData class. Return the raw data from within the encapsulated NDData object.",
        "prompt_zh": "创建一个一维数组 [1, 2, 3, 4] 并使用Astropy的NDData类进行封装。返回封装后的NDData对象中的原始数据。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.nddata import NDData\n    ndd2 = NDData([1, 2, 3, 4])\n    return ndd2.data\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 273,
        "prompt_en": "Create an Astropy NDData object for a one-dimensional numerical data array [1, 2, 3, 4]. Set the unit as 'erg / s' and add the standard deviation as the uncertainty information. Additionally, items in the data array greater than 2 should be masked and marked as True. Include metadata with a key 'object' and a value 'fictional data.'. Return the content of the mask attribute of this NDData object.",
        "prompt_zh": "为一个一维数值数据数组[1, 2, 3, 4]创建一个Astropy的NDData对象，设定单位为'erg / s'，并添加标准偏差作为不确定性信息。此外，数据中大于2的项应被掩码标注为True。附加元数据应包含一个键'object'，与值'fictional data.'。返回这个NDData对象掩码属性的内容。\n",
        "canonical_solution": "def canonical_solution():\n    import numpy as np\n    from astropy.nddata import NDData, StdDevUncertainty\n    data = np.array([1, 2, 3, 4])\n    mask = data > 2\n    unit = 'erg / s'\n    uncertainty = StdDevUncertainty(np.sqrt(data))\n    meta = {'object': 'fictional data.'}\n    ndd = NDData(data, mask=mask, unit=unit, uncertainty=uncertainty, meta=meta)\n    return ndd.mask\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 274,
        "prompt_en": "Create an NDDataRef object with units of \"erg / s\" and values [1, 2, 3, 4]. Then add it to another array with values [4, -3.5, 3, 2.5] and units \"erg / s\", and return the result.",
        "prompt_zh": "创建一个具有单位\"erg / s\"和数值[1, 2, 3, 4]的NDDataRef对象，然后将其与另一个数值[4, -3.5, 3, 2.5]、单位\"erg / s\"的数组相加，并返回结果。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.nddata import NDDataRef\n    from astropy import units as u\n    ndd = NDDataRef([1, 2, 3, 4], unit='erg / s')\n    ndd2 = ndd.add([4, -3.5, 3, 2.5] * u.erg / u.s)\n    return ndd2\n\n\n",
        "test_code": [
            "\nfrom astropy.nddata import NDDataRef\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状\n    if data1.data.shape != data2.data.shape:\n        return False\n    # 检查数据值\n    if not np.allclose(data1.data, data2.data, atol=1e-8):\n        return False\n    # 检查单位\n    if data1.unit != data2.unit:\n        return False\n    # 检查元数据\n    # 需要注意比较元数据时可能需要更复杂的逻辑\n    if data1.meta != data2.meta:\n        return False\n    # 检查WCS信息\n    # 需要确保这里的比较操作对于WCS对象是有效的\n    if data1.wcs != data2.wcs:\n        return False\n    # 如果所有检查都通过了，则认为数据一致\n    return True\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 275,
        "prompt_en": "Create a CCDData object containing the data [1, 2, 3, 4], set a mask for data elements greater than 2, specify the unit as 'erg / s', calculate the uncertainty for each data point as its square root, and add metadata labeling the data as 'fictional data.'. Output the created CCDData object.",
        "prompt_zh": "创建一个包含数据[1, 2, 3, 4]的CCDData对象，为大于2的数据元素设置掩码，指定单位为'erg / s'，计算每个数据点的不确定性即其平方根，添加元数据标记数据为'fictional data.'。 输出创建的CCDData对象。\n",
        "canonical_solution": "from astropy.nddata import CCDData\nimport numpy as np\n\ndef canonical_solution():\n    # Create an array and related objects for initializing NDData\n    data = np.array([1, 2, 3, 4])\n    mask = data > 2\n    unit = 'erg / s'\n    uncertainty = np.sqrt(data)\n    meta = {'object': 'fictional data.'}\n    # Instantiate the NDData object with additional properties\n    ndd = CCDData(data, mask=mask, unit=unit, uncertainty=uncertainty, meta=meta)\n    return ndd\n\n# Execute the canonical solution function and get the result\nresult = canonical_solution()\nprint(result)\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n  if data1.unit!=data2.unit:\n     return False\n  if not np.allclose(data1.data, data2.data, atol=1e-8):\n     return False\n  if not np.allclose(data1.mask, data2.mask, atol=1e-8):\n     return False\n  return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 276,
        "prompt_en": "Use NDDataRef to add the two numbers 1 and 3, and return the result.",
        "prompt_zh": "使用NDDataRef将两个数字1和3相加并返回结果。",
        "canonical_solution": "def canonical_solution():\n    from astropy.nddata import NDDataRef\n    result = NDDataRef.add(1, 3)\n    return result\n\n\n",
        "test_code": [
            "\nfrom astropy.nddata import NDDataRef\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状\n    if data1.data.shape != data2.data.shape:\n        return False\n    # 检查数据值\n    if not np.allclose(data1.data, data2.data, atol=1e-8):\n        return False\n    # 检查单位\n    if data1.unit != data2.unit:\n        return False\n    # 检查元数据\n    # 需要注意比较元数据时可能需要更复杂的逻辑\n    if data1.meta != data2.meta:\n        return False\n    # 检查WCS信息\n    # 需要确保这里的比较操作对于WCS对象是有效的\n    if data1.wcs != data2.wcs:\n        return False\n    # 如果所有检查都通过了，则认为数据一致\n    return True\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 277,
        "prompt_en": "Multiply the two numerical arrays [1, 2] meters and [10, 20] centimeters element-wise. Return the result and its unit.",
        "prompt_zh": "执行两个数值数组[1, 2]米和[10, 20]厘米的逐元素乘法，并返回结果及其单位。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.nddata import NDDataRef\n    import astropy.units as u\n    ndd = NDDataRef.multiply([1, 2] * u.m, [10, 20] * u.cm)\n    return ndd, ndd.unit\n\n\n",
        "test_code": [
            "\nfrom astropy.nddata import NDDataRef\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状\n    if data1.data.shape != data2.data.shape:\n        return False\n    # 检查数据值\n    if not np.allclose(data1.data, data2.data, atol=1e-8):\n        return False\n    # 检查单位\n    if data1.unit != data2.unit:\n        return False\n    # 检查元数据\n    # 需要注意比较元数据时可能需要更复杂的逻辑\n    if data1.meta != data2.meta:\n        return False\n    # 检查WCS信息\n    # 需要确保这里的比较操作对于WCS对象是有效的\n    if data1.wcs != data2.wcs:\n        return False\n    # 如果所有检查都通过了，则认为数据一致\n    return True\n\n",
            "\ndef test_code(unit1, unit2):\n    # 直接比较两个单位对象是否相等\n    return unit1 == unit2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 278,
        "prompt_en": "Create an Astropy NDDataRef object with a value of 1, and divide 1 by this object. Return the resulting output.",
        "prompt_zh": "创建一个值为1的Astropy NDDataRef对象，并将1除以这个对象，返回得到的结果。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.nddata import NDDataRef\n    ndd1 = NDDataRef(1)\n    result = NDDataRef.divide(1, ndd1)\n    return result\n\n\n",
        "test_code": [
            "\nfrom astropy.nddata import NDDataRef\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状\n    if data1.data.shape != data2.data.shape:\n        return False\n    # 检查数据值\n    if not np.allclose(data1.data, data2.data, atol=1e-8):\n        return False\n    # 检查单位\n    if data1.unit != data2.unit:\n        return False\n    # 检查元数据\n    # 需要注意比较元数据时可能需要更复杂的逻辑\n    if data1.meta != data2.meta:\n        return False\n    # 检查WCS信息\n    # 需要确保这里的比较操作对于WCS对象是有效的\n    if data1.wcs != data2.wcs:\n        return False\n    # 如果所有检查都通过了，则认为数据一致\n    return True\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 279,
        "prompt_en": "Create an NDDataRef object containing the elements [1, 2, 3, 4] and increase the value of each element by 3. Then return the modified result.",
        "prompt_zh": "创建一个包含元素[1, 2, 3, 4]的NDDataRef对象，并将每个元素的值都增加3，然后返回修改后的结果。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.nddata import NDDataRef\n    ndd1 = NDDataRef([1, 2, 3, 4])\n    return ndd1.add(3)\n\n\n",
        "test_code": [
            "\nfrom astropy.nddata import NDDataRef\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状\n    if data1.data.shape != data2.data.shape:\n        return False\n    # 检查数据值\n    if not np.allclose(data1.data, data2.data, atol=1e-8):\n        return False\n    # 检查单位\n    if data1.unit != data2.unit:\n        return False\n    # 检查元数据\n    # 需要注意比较元数据时可能需要更复杂的逻辑\n    if data1.meta != data2.meta:\n        return False\n    # 检查WCS信息\n    # 需要确保这里的比较操作对于WCS对象是有效的\n    if data1.wcs != data2.wcs:\n        return False\n    # 如果所有检查都通过了，则认为数据一致\n    return True\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 280,
        "prompt_en": "Subtract the array [1, 1, 1, 1] from the array [1, 2, 3, 4] and return the result.",
        "prompt_zh": "从数组[1, 2, 3, 4]中减去数组[1, 1, 1, 1]，并返回结果。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.nddata import NDDataRef\n    ndd1 = NDDataRef([1, 2, 3, 4])\n    return ndd1.subtract([1, 1, 1, 1])\n\n\n",
        "test_code": [
            "\nfrom astropy.nddata import NDDataRef\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状\n    if data1.data.shape != data2.data.shape:\n        return False\n    # 检查数据值\n    if not np.allclose(data1.data, data2.data, atol=1e-8):\n        return False\n    # 检查单位\n    if data1.unit != data2.unit:\n        return False\n    # 检查元数据\n    # 需要注意比较元数据时可能需要更复杂的逻辑\n    if data1.meta != data2.meta:\n        return False\n    # 检查WCS信息\n    # 需要确保这里的比较操作对于WCS对象是有效的\n    if data1.wcs != data2.wcs:\n        return False\n    # 如果所有检查都通过了，则认为数据一致\n    return True\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 281,
        "prompt_en": "Use the Astropy NDDataRef object to multiply the array [1, 2, 3, 4] by the array [4, 5, 6, 7] and return the multiplication result.",
        "prompt_zh": "使用Astropy NDDataRef对象将数组[1, 2, 3, 4]与数组[4, 5, 6, 7]相乘，并返回乘法结果。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.nddata import NDDataRef\n    import numpy as np\n    ndd1 = NDDataRef([1, 2, 3, 4])\n    return ndd1.multiply(np.arange(4, 8))\n\n\n",
        "test_code": [
            "\nfrom astropy.nddata import NDDataRef\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状\n    if data1.data.shape != data2.data.shape:\n        return False\n    # 检查数据值\n    if not np.allclose(data1.data, data2.data, atol=1e-8):\n        return False\n    # 检查单位\n    if data1.unit != data2.unit:\n        return False\n    # 检查元数据\n    # 需要注意比较元数据时可能需要更复杂的逻辑\n    if data1.meta != data2.meta:\n        return False\n    # 检查WCS信息\n    # 需要确保这里的比较操作对于WCS对象是有效的\n    if data1.wcs != data2.wcs:\n        return False\n    # 如果所有检查都通过了，则认为数据一致\n    return True\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 282,
        "prompt_en": "Perform element-wise division by taking the one-dimensional data sequence [1, 2, 3, 4] as the numerator, and a matrix of shape 3 rows by 4 columns with elements ranging from 1 to 12 as the denominator. Return the result.",
        "prompt_zh": "将一维数据序列[1, 2, 3, 4]作为分子，与一个形状为3行4列、元素值从1到12的矩阵作为分母，执行按元素的除法操作，并返回结果。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.nddata import NDDataRef\n    import numpy as np\n    ndd1 = NDDataRef([1, 2, 3, 4])\n    return ndd1.divide(np.arange(1, 13).reshape(3, 4))\n\n\n",
        "test_code": [
            "\nfrom astropy.nddata import NDDataRef\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状\n    if data1.data.shape != data2.data.shape:\n        return False\n    # 检查数据值\n    if not np.allclose(data1.data, data2.data, atol=1e-8):\n        return False\n    # 检查单位\n    if data1.unit != data2.unit:\n        return False\n    # 检查元数据\n    # 需要注意比较元数据时可能需要更复杂的逻辑\n    if data1.meta != data2.meta:\n        return False\n    # 检查WCS信息\n    # 需要确保这里的比较操作对于WCS对象是有效的\n    if data1.wcs != data2.wcs:\n        return False\n    # 如果所有检查都通过了，则认为数据一致\n    return True\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 283,
        "prompt_en": "Multiply the corresponding elements of the two arrays [1, 2] meters and [10, 20] centimeters, and return the calculated results.",
        "prompt_zh": "将两个数组[1, 2]米和[10, 20]厘米对应元素相乘，并返回计算结果。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.nddata import NDDataRef\n    import astropy.units as u\n    ndd = NDDataRef.multiply([1, 2] * u.m, [10, 20] * u.cm)\n    return ndd\n\n\n",
        "test_code": [
            "\nfrom astropy.nddata import NDDataRef\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状\n    if data1.data.shape != data2.data.shape:\n        return False\n    # 检查数据值\n    if not np.allclose(data1.data, data2.data, atol=1e-8):\n        return False\n    # 检查单位\n    if data1.unit != data2.unit:\n        return False\n    # 检查元数据\n    # 需要注意比较元数据时可能需要更复杂的逻辑\n    if data1.meta != data2.meta:\n        return False\n    # 检查WCS信息\n    # 需要确保这里的比较操作对于WCS对象是有效的\n    if data1.wcs != data2.wcs:\n        return False\n    # 如果所有检查都通过了，则认为数据一致\n    return True\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 284,
        "prompt_en": "Use NDDataRef to divide the number 1 by each element in the array [1, 2, 3, 4] and return the result array.",
        "prompt_zh": "使用NDDataRef将数字1除以数组[1, 2, 3, 4]中的每一个元素，并返回结果数组。",
        "canonical_solution": "def canonical_solution():\n    from astropy.nddata import NDDataRef\n    return NDDataRef.divide(1, NDDataRef([1, 2, 3, 4]))\n\n\n",
        "test_code": [
            "\nfrom astropy.nddata import NDDataRef\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状\n    if data1.data.shape != data2.data.shape:\n        return False\n    # 检查数据值\n    if not np.allclose(data1.data, data2.data, atol=1e-8):\n        return False\n    # 检查单位\n    if data1.unit != data2.unit:\n        return False\n    # 检查元数据\n    # 需要注意比较元数据时可能需要更复杂的逻辑\n    if data1.meta != data2.meta:\n        return False\n    # 检查WCS信息\n    # 需要确保这里的比较操作对于WCS对象是有效的\n    if data1.wcs != data2.wcs:\n        return False\n    # 如果所有检查都通过了，则认为数据一致\n    return True\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 285,
        "prompt_en": "Create a one-dimensional array [1, 2, 3, 4], create a mask for values greater than 2, and calculate the square root of each data point as the uncertainty. Then, encapsulate this information using the Astropy NDDataRef class. Perform slicing operations on the encapsulated data to extract the second and third data points (based on 0-based indexing), and finally return the sliced data mask and uncertainty information.",
        "prompt_zh": "创建一个一维数组[1, 2, 3, 4]，为大于2的值创建掩码，计算每个数据点的平方根作为不确定度。然后，用Astropy NDDataRef类封装这些信息。对封装好的数据进行切片操作，提取第2个和第3个数据点（基于0的索引），最后返回切片后的数据掩码和不确定度信息。",
        "canonical_solution": "def canonical_solution():\n  import numpy as np\n  from astropy.nddata import NDDataRef\n  from astropy.nddata import StdDevUncertainty\n  data = np.array([1, 2, 3, 4])\n  mask = data > 2\n  uncertainty = StdDevUncertainty(np.sqrt(data))\n  ndd = NDDataRef(data, mask=mask, uncertainty=uncertainty)\n  sliced_ndd = ndd[1:3]\n  return sliced_ndd.mask, sliced_ndd.uncertainty\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n",
            "import numpy as np\ndef test_code(data1, data2):\n  if not np.allclose(data1.array, data2.array, atol=1e-8):\n     return False\n  return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 286,
        "prompt_en": "Create an `NDDataRef` object containing values, a mask, and standard deviation uncertainties. The values are a 3x3 array [[1,2,3],[4,5,6],[7,8,9]], the mask is [[False,True,False],[True,True,True],[False,False,True]], and the uncertainty is the square root of the data. Then, remove the data masked out and return the remaining data.",
        "prompt_zh": "创建含有数值、掩码和标准差不确定性的`NDDataRef`对象，数值为一个3x3数组[[1,2,3],[4,5,6],[7,8,9]]，掩码为[[False,True,False],[True,True,True],[False,False,True]]，不确定度为数据平方根，然后去除被掩码掉的数据并返回剩余数据。",
        "canonical_solution": "def canonical_solution():\n  import numpy as np\n  from astropy.nddata import NDDataRef\n  from astropy.nddata import StdDevUncertainty\n  data = np.array([[1,2,3],[4,5,6],[7,8,9]])\n  mask = np.array([[0,1,0],[1,1,1],[0,0,1]], dtype=bool)\n  uncertainty = StdDevUncertainty(np.sqrt(data))\n  ndd = NDDataRef(data, mask=mask, uncertainty=uncertainty)\n  ndd_sliced = ndd[~ndd.mask]\n  return ndd_sliced\n\n\n",
        "test_code": [
            "\nfrom astropy.nddata import NDDataRef\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状\n    if data1.data.shape != data2.data.shape:\n        return False\n    # 检查数据值\n    if not np.allclose(data1.data, data2.data, atol=1e-8):\n        return False\n    # 检查单位\n    if data1.unit != data2.unit:\n        return False\n    # 检查元数据\n    # 需要注意比较元数据时可能需要更复杂的逻辑\n    if data1.meta != data2.meta:\n        return False\n    # 检查WCS信息\n    # 需要确保这里的比较操作对于WCS对象是有效的\n    if data1.wcs != data2.wcs:\n        return False\n    # 如果所有检查都通过了，则认为数据一致\n    return True\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 287,
        "prompt_en": "Create an astronomical data object containing a 3x3 array with values: [[1,2,3],[4,5,6],[7,8,9]]. Define a mask array to identify data points to be ignored, with the mask as: [[False,True,False],[True,True,True],[False,False,True]]. Calculate the square root of the original data as the uncertainty. Return an array composed of the data points selected by the mask, where the mask is true.",
        "prompt_zh": "创建一个天文数据对象，包含以下值的3x3数组：[[1,2,3],[4,5,6],[7,8,9]]。定义一个掩码数组来标识需要被忽略的数据点，这个掩码为：[[False,True,False],[True,True,True],[False,False,True]]。为原始数据计算平方根作为不确定度。返回使用掩码选择出的，即掩码为真的数据点构成的数组。",
        "canonical_solution": "def canonical_solution():\n  import numpy as np\n  from astropy.nddata import NDDataRef\n  from astropy.nddata import StdDevUncertainty\n  data = np.array([[1,2,3],[4,5,6],[7,8,9]])\n  mask = np.array([[0,1,0],[1,1,1],[0,0,1]], dtype=bool)\n  uncertainty = StdDevUncertainty(np.sqrt(data))\n  ndd = NDDataRef(data, mask=mask, uncertainty=uncertainty)\n  ndd_sliced = ndd[ndd.mask]  # This time without the ~\n  return ndd_sliced\n\n\n",
        "test_code": [
            "\nfrom astropy.nddata import NDDataRef\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状\n    if data1.data.shape != data2.data.shape:\n        return False\n    # 检查数据值\n    if not np.allclose(data1.data, data2.data, atol=1e-8):\n        return False\n    # 检查单位\n    if data1.unit != data2.unit:\n        return False\n    # 检查元数据\n    # 需要注意比较元数据时可能需要更复杂的逻辑\n    if data1.meta != data2.meta:\n        return False\n    # 检查WCS信息\n    # 需要确保这里的比较操作对于WCS对象是有效的\n    if data1.wcs != data2.wcs:\n        return False\n    # 如果所有检查都通过了，则认为数据一致\n    return True\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 288,
        "prompt_en": "Construct an NDDataRef object containing the data [1, 2, 3, 4]. Add a mask to the data to flag elements greater than 2. Add the square root of each data element as the uncertainty. Then, extract the data slice from index 1 to 2, and return the data, mask, and uncertainty arrays of this slice.",
        "prompt_zh": "构建包含数据[1, 2, 3, 4]的NDDataRef对象，为数据添加一个掩码以标记数值大于2的元素，添加数据每个元素的平方根作为不确定性。之后，提取索引为1到2的数据片段，并返回该片段的数据、掩码和不确定性数组。",
        "canonical_solution": "def canonical_solution():\n    import numpy as np\n    from astropy.nddata import NDDataRef, StdDevUncertainty\n    data = np.array([1, 2, 3, 4])\n    mask = data > 2\n    uncertainty = StdDevUncertainty(np.sqrt(data))\n    ndd = NDDataRef(data, mask=mask, uncertainty=uncertainty)\n    ndd_sliced = ndd[1:3]\n    return ndd_sliced.data, ndd_sliced.mask, ndd_sliced.uncertainty.array\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n",
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n",
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 289,
        "prompt_en": "Create a 3x3 array named data with contents [[1,2,3],[4,5,6],[7,8,9]]. Apply a mask named 'mask' to indicate which parts of the data are valid, with the mask being [[0,1,0],[1,1,1],[0,0,1]]. Calculate the square root of each data point as the uncertainty and include it as part of the array. Then, create an NDDataRef object containing data, mask, and uncertainty. Finally, extract the unmasked data from the NDDataRef object, returning the values, mask, and uncertainty of these data points.",
        "prompt_zh": "创建一个3x3的数组data，其内容为[[1,2,3],[4,5,6],[7,8,9]]。应用一个掩码mask，用于指示数据的哪些部分有效，掩码为[[0,1,0],[1,1,1],[0,0,1]]。计算每个数据点的平方根作为不确定度，并将其作为数组的一部分。之后，创建一个NDDataRef对象包含data，mask和uncertainty。最后，从NDDataRef对象中提取未被掩盖的数据，返回这些数据点的值、掩码和不确定度。",
        "canonical_solution": "def canonical_solution():\n    import numpy as np\n    from astropy.nddata import NDDataRef, StdDevUncertainty\n    data = np.array([[1,2,3],[4,5,6],[7,8,9]])\n    mask = np.array([[0,1,0],[1,1,1],[0,0,1]], dtype=bool)\n    uncertainty = StdDevUncertainty(np.sqrt(data))\n    ndd = NDDataRef(data, mask=mask, uncertainty=uncertainty)\n    ndd_sliced = ndd[~ndd.mask]\n    return ndd_sliced.data, ndd_sliced.mask, ndd_sliced.uncertainty.array\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n",
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n",
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 290,
        "prompt_en": "Create a 3x3 numerical array and apply a Boolean mask to it, while calculating the square root of each point in the array as uncertainty. Then, encapsulate this data using the NDDataRef class in Astropy, and extract the data corresponding to the True positions of the mask along with their uncertainty information. Finally, return these masked numerical data along with their corresponding mask states and uncertainty values.",
        "prompt_zh": "创建一个3x3的数值数组并对其应用布尔掩码，同时计算数组中每个点的平方根作为不确定性。然后使用Astropy的NDDataRef类将这些数据封装起来，并提取对应于掩码True位置的数据及其不确定性信息。最终返回这些被掩码的数值数据及其对应掩码状态和不确定性值。",
        "canonical_solution": "def canonical_solution():\n    import numpy as np\n    from astropy.nddata import NDDataRef, StdDevUncertainty\n    data = np.array([[1,2,3],[4,5,6],[7,8,9]])\n    mask = np.array([[0,1,0],[1,1,1],[0,0,1]], dtype=bool)\n    uncertainty = StdDevUncertainty(np.sqrt(data))\n    ndd = NDDataRef(data, mask=mask, uncertainty=uncertainty)\n    ndd_sliced = ndd[ndd.mask]\n    return ndd_sliced.data, ndd_sliced.mask, ndd_sliced.uncertainty.array\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n",
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n",
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 291,
        "prompt_en": "Create a one-dimensional array with elements [1, 2, 3, 4] and convert it into an NDDataRef object from Astropy. Then return the slice of the object from the second to the third element.",
        "prompt_zh": "创建一个包含元素[1, 2, 3, 4]的一维数组，并将其转换为Astropy的NDDataRef对象。然后返回该对象第二个元素至第三个元素的切片。\n",
        "canonical_solution": "def canonical_solution():\n  import numpy as np\n  from astropy.nddata import NDDataRef\n  data = np.array([1, 2, 3, 4])\n  ndd = NDDataRef(data)\n  return ndd[1:3]\n\n\n",
        "test_code": [
            "\nfrom astropy.nddata import NDDataRef\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状\n    if data1.data.shape != data2.data.shape:\n        return False\n    # 检查数据值\n    if not np.allclose(data1.data, data2.data, atol=1e-8):\n        return False\n    # 检查单位\n    if data1.unit != data2.unit:\n        return False\n    # 检查元数据\n    # 需要注意比较元数据时可能需要更复杂的逻辑\n    if data1.meta != data2.meta:\n        return False\n    # 检查WCS信息\n    # 需要确保这里的比较操作对于WCS对象是有效的\n    if data1.wcs != data2.wcs:\n        return False\n    # 如果所有检查都通过了，则认为数据一致\n    return True\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 292,
        "prompt_en": "Create a one-dimensional array containing the values [1, 2, 3, 4], and wrap the array using Astropy's NDDataRef class. Return the value of the element at index 1 in the NDDataRef object.",
        "prompt_zh": "创建一个包含数值 [1, 2, 3, 4] 的一维数组，并利用 Astropy 的 NDDataRef 类包装该数组。返回 NDDataRef 对象中索引为 1 的元素的值。\n",
        "canonical_solution": "def canonical_solution():\n    import numpy as np\n    from astropy.nddata import NDDataRef\n    data = np.array([1, 2, 3, 4])\n    ndd = NDDataRef(data)\n    return ndd[1]\n\n\n",
        "test_code": [
            "\nfrom astropy.nddata import NDDataRef\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状\n    if data1.data.shape != data2.data.shape:\n        return False\n    # 检查数据值\n    if not np.allclose(data1.data, data2.data, atol=1e-8):\n        return False\n    # 检查单位\n    if data1.unit != data2.unit:\n        return False\n    # 检查元数据\n    # 需要注意比较元数据时可能需要更复杂的逻辑\n    if data1.meta != data2.meta:\n        return False\n    # 检查WCS信息\n    # 需要确保这里的比较操作对于WCS对象是有效的\n    if data1.wcs != data2.wcs:\n        return False\n    # 如果所有检查都通过了，则认为数据一致\n    return True\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 293,
        "prompt_en": "Create an NDDataRef object containing the values [1, 2, 3, 4], and assign a standard deviation uncertainty based on the square root for each value. Apply a mask to the data to mask all values greater than 2. Then return the data, mask, and uncertainty attributes for the slice with indices 1 to 2.",
        "prompt_zh": "创建一个包含数值[1, 2, 3, 4]的NDDataRef对象，并为每个数值设置基于其平方根的标准偏差不确定性。为该数据设置一个掩码，掩盖所有大于2的值。然后返回索引1到2的切片的数据、掩码和不确定性属性。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.nddata import NDDataRef, StdDevUncertainty\n    import numpy as np\n    data = np.array([1, 2, 3, 4])\n    mask = data > 2\n    uncertainty = StdDevUncertainty(np.sqrt(data))\n    ndd = NDDataRef(data, mask=mask, uncertainty=uncertainty)\n    ndd_sliced = ndd[1:3]\n    return ndd_sliced.data, ndd_sliced.mask, ndd_sliced.uncertainty\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n",
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n",
            "import numpy as np\ndef test_code(data1, data2):\n  if not np.allclose(data1.array, data2.array, atol=1e-8):\n     return False\n  return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 294,
        "prompt_en": "Create an NDDataRef object containing the data [1, 2, 3, 4], specifying that all data is valid (unmasked) and the standard deviation uncertainty is 0. Subsequently, extract a subset of this data object (index range 1 to 2) and return the mask information of this subset.",
        "prompt_zh": "创建一个包含数据[1, 2, 3, 4]的NDDataRef对象，指定所有数据都是有效的（不被掩蔽）并且标准差不确定性为0。随后，提取这个数据对象的子集（索引范围1到2），并返回这个子集的掩码信息。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.nddata import NDDataRef, StdDevUncertainty\n    import numpy as np\n    data = np.array([1, 2, 3, 4])\n    mask = False\n    uncertainty = StdDevUncertainty(0)\n    ndd = NDDataRef(data, mask=mask, uncertainty=uncertainty)\n    ndd_sliced = ndd[1:3]\n    return ndd_sliced.mask\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 295,
        "prompt_en": "Create an NDDataRef object containing the data [[1,2,3],[4,5,6],[7,8,9]], establish a boolean mask array [[0,1,0],[1,1,1],[0,0,1]] to indicate which data will be ignored, and calculate the uncertainty based on the square root of the data values. Afterwards, extract and return the unmasked data, the mask, and the uncertainty information.",
        "prompt_zh": "创建一个包含数据[[1,2,3],[4,5,6],[7,8,9]]的NDDataRef对象，同时为这些数据建立一个布尔型掩码数组[[0,1,0],[1,1,1],[0,0,1]]来表示哪些数据将被忽略，以及基于数据值的平方根计算标准差的不确定性。之后，提取并返回未被掩码的数据、掩码和不确定性信息。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.nddata import NDDataRef, StdDevUncertainty\n    import numpy as np\n    data = np.array([[1,2,3],[4,5,6],[7,8,9]])\n    mask = np.array([[0,1,0],[1,1,1],[0,0,1]], dtype=bool)\n    uncertainty = StdDevUncertainty(np.sqrt(data))\n    ndd = NDDataRef(data, mask=mask, uncertainty=uncertainty)\n    ndd_sliced = ndd[~ndd.mask]\n    return ndd_sliced.data, ndd_sliced.mask, ndd_sliced.uncertainty\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n",
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n",
            "import numpy as np\ndef test_code(data1, data2):\n  if not np.allclose(data1.array, data2.array, atol=1e-8):\n     return False\n  return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 296,
        "prompt_en": "Create a 3x3 NumPy array `data` with values\n[[1,2,3],\n[4,5,6],\n[7,8,9]],\nand generate a mask array `mask` with values\n[[False, True, False],\n[True, True, True],\n[False, False, True]].\nThen create an uncertainty object `uncertainty` as the square root of each value in `data`.\nUse Astropy's `NDDataRef` class to encapsulate `data`, `mask`, and `uncertainty` into a multidimensional data object `ndd`.\nSelect the elements in `ndd` marked as True by `mask`, and return this subset of data, mask, and uncertainty.",
        "prompt_zh": "创建一个3x3的NumPy数组 `data`，其值为\\n[[1,2,3],\\n[4,5,6],\\n[7,8,9]]\\n，为这些数据生成一个掩码数组 `mask`，其值为\\n[[False, True, False],\\n[True, True, True],\\n[False, False, True]]。\\n然后创建不确定性对象 `uncertainty`，为 `data` 中每个值的平方根。\\n使用Astropy的 `NDDataRef` 类，把 `data`、`mask` 和 `uncertainty` 封装起来，构成一个多维数据对象 `ndd`。\\n选取 `ndd` 中被 `mask` 标记为True的元素，并返回这部分数据、掩码和不确定性。",
        "canonical_solution": "def canonical_solution():\n    from astropy.nddata import NDDataRef, StdDevUncertainty\n    import numpy as np\n    data = np.array([[1,2,3],[4,5,6],[7,8,9]])\n    mask = np.array([[0,1,0],[1,1,1],[0,0,1]], dtype=bool)\n    uncertainty = StdDevUncertainty(np.sqrt(data))\n    ndd = NDDataRef(data, mask=mask, uncertainty=uncertainty)\n    ndd_sliced = ndd[ndd.mask]\n    return ndd_sliced.data, ndd_sliced.mask, ndd_sliced.uncertainty\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n",
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n",
            "import numpy as np\ndef test_code(data1, data2):\n  if not np.allclose(data1.array, data2.array, atol=1e-8):\n     return False\n  return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 297,
        "prompt_en": "Create a 3x3 NumPy array with the content [[0, 1, 0], [1, 0, 1], [0, 1, 0]], wrap this array in an Astropy NDData object, and return the data in this object.",
        "prompt_zh": "创建一个3x3的NumPy数组，具体内容为[[0, 1, 0], [1, 0, 1], [0, 1, 0]]，将这个数组包装在一个Astropy的NDData对象中，并返回这个对象中的数据。",
        "canonical_solution": "def canonical_solution():\n  import numpy as np\n  from astropy.nddata import NDData\n  array = np.array([[0, 1, 0], [1, 0, 1], [0, 1, 0]])\n  ndd = NDData(array)\n  return ndd.data\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 298,
        "prompt_en": "Create a list containing the elements [1, 2, 3, 4] and wrap it with the NDData class from Astropy. Return the original data list inside the NDData object.",
        "prompt_zh": "创建一个包含元素[1, 2, 3, 4]的列表，并使用Astropy的NDData类包装该列表。返回NDData对象中的原始数据列表。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.nddata import NDData\n  alist = [1, 2, 3, 4]\n  ndd = NDData(alist)\n  return ndd.data\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 299,
        "prompt_en": "Create a new class NDDataWithFlags that inherits from the Astropy NDData class. During the initialization of this new class, check if the flags parameter is provided; if so, store it, otherwise set it to None. Then, create an instance of the NDDataWithFlags class, passing in the list [1,2,3] as the data, and check whether the flags attribute of the instance is None.",
        "prompt_zh": "创建一个继承自Astropy的NDData类的新类NDDataWithFlags。在这个新类的初始化时，检查是否提供了flags参数，如果提供则存储，如果没有提供则设置为None。接着，创建NDDataWithFlags类的实例，传入列表[1,2,3]作为数据，并检查该实例的flags属性是否为空。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.nddata import NDData\n  class NDDataWithFlags(NDData):\n      def __init__(self, *args, **kwargs):\n          # Remove flags attribute if given and pass it to the setter.\n          self.flags = kwargs.pop('flags') if 'flags' in kwargs else None\n          super().__init__(*args, **kwargs)\n  \n  ndd = NDDataWithFlags([1,2,3])\n  return ndd.flags is None\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 300,
        "prompt_en": "Create a 2D array of shape 5x4 with elements ranging from 0 to 19. Then, crop a 3x3 size region at the top-left corner, specifically at position (0,0). If the cropped region goes beyond the boundary of the original array, automatically trim to the boundary. Return the data of the cropped array afterwards.",
        "prompt_zh": "创建一个5x4形状的二维数组，其元素从0到19。然后在数组的左上角，即位置(0,0)，裁切一个3x3大小的区域。如果裁切出的区域超出原始数组的边界，则自动修剪到边界。最后返回裁切出来的新数组数据。\n",
        "canonical_solution": "def canonical_solution():\n    import numpy as np\n    from astropy.nddata import Cutout2D\n    # Generate simple data\n    data2 = np.arange(20.).reshape(5, 4)\n    # Define a position and size and create a Cutout2D object in 'trim' mode\n    position = (0, 0)\n    size = (3, 3)\n    cutout = Cutout2D(data2, position, size, mode='trim')\n    return cutout.data\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 301,
        "prompt_en": "Crop a 3x3 size region centered at (0, 0) from a two-dimensional array with 5 rows and 4 columns and numerical values ranging from 0 to 19. If the cropping area extends beyond the array boundaries, return the actual crop-able part.",
        "prompt_zh": "从一个5行4列、数值从0到19的二维数组中，以(0, 0)为中心裁剪出一个3x3大小的区域，如果裁剪区域超出数组边界，则返回实际可裁剪的部分。\n",
        "canonical_solution": "def canonical_solution():\n    import numpy as np\n    from astropy.nddata import Cutout2D\n    # Generate simple data\n    data2 = np.arange(20.).reshape(5, 4)\n    # Define a position and size and create a Cutout2D object in 'partial' mode\n    position = (0, 0)\n    size = (3, 3)\n    cutout = Cutout2D(data2, position, size, mode='partial')\n    return cutout.data\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 302,
        "prompt_en": "Generate a 500x500 pixel image of a two-dimensional Gaussian distribution with parameters set as amplitude=1, center_x=50, center_y=100, standard deviation in the x-direction=10, standard deviation in the y-direction=5, and a rotation angle of 0.5 radians. Then crop a region from this Gaussian distribution image centered at (49.7, 100.1) with the size of 41x51 pixels, and display the cropped image. Finally, return the data within the cropped area.",
        "prompt_zh": "生成一个500x500像素的二维高斯分布图像，其参数设置为幅度=1、中心x=50、中心y=100、x方向的标准差=10、y方向的标准差=5、偏转角度为0.5弧度。然后从这个高斯分布图像中剪裁出一个中心在(49.7, 100.1)、大小为41x51像素的区域，并展示这个剪裁图像。最终返回剪裁区域内的数据。\n",
        "canonical_solution": "def canonical_solution():\n  import numpy as np\n  from astropy.modeling.models import Gaussian2D\n  from astropy.nddata import Cutout2D\n  import matplotlib.pyplot as plt\n\n  # 创建一个2D高斯源数据\n  y, x = np.mgrid[0:500, 0:500]\n  data = Gaussian2D(1, 50, 100, 10, 5, theta=0.5)(x, y)\n\n  # 创建一个剪裁图像，中心为(49.7, 100.1)，大小为(41, 51)像素\n  position = (49.7, 100.1)\n  size = (41, 51)\n  cutout = Cutout2D(data, position, size)\n\n  # 显示剪裁图像数据\n  plt.imshow(cutout.data, origin='lower')\n  plt.show()\n\n  return cutout.data\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 303,
        "prompt_en": "Perform a sigma clipping operation on the dataset [1, 5, 6, 8, 100, 5, 3, 2] with a sigma value of 2 and a maximum number of iterations set to 5. Return the processed data result.",
        "prompt_zh": "对数据集[1, 5, 6, 8, 100, 5, 3, 2]执行Sigma剪辑操作，设置sigma为2，最大迭代次数为5，并返回处理后的数据结果。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.stats import SigmaClip\n    data = [1, 5, 6, 8, 100, 5, 3, 2]\n    sigclip = SigmaClip(sigma=2, maxiters=5)\n    result = sigclip(data)\n    return result\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n  if not np.allclose(data1.data, data2.data, atol=1e-8):\n     return False\n  if not np.allclose(data1.mask, data2.mask, atol=1e-8):\n     return False\n  if data1.fill_value!=data2.fill_value:\n     return False\n  return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 304,
        "prompt_en": "Provide a function to convert the full width at half maximum (FWHM) of a Gaussian distribution to the standard deviation (sigma).",
        "prompt_zh": "提供一个将高斯分布的全宽半最大值（FWHM）转换为标准差（sigma）的功能。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.stats import gaussian_fwhm_to_sigma\n    return gaussian_fwhm_to_sigma\n\n\n",
        "test_code": [
            "\nimport math\n\ndef test_code(data1, data2):\n    # 设置绝对误差容许值\n    abs_tol = 1e-8\n    # 使用math.isclose来比较两个浮点数是否在误差范围内相等\n    return math.isclose(data1, data2, abs_tol=abs_tol)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 305,
        "prompt_en": "Apply sigma clipping to the array [1, 0, 0, 1, 99, 0, 0, 1, 0], and then return the mean value of the clipped data.",
        "prompt_zh": "对数组[1, 0, 0, 1, 99, 0, 0, 1, 0]进行sigma裁剪，然后返回裁剪后数据的平均值。",
        "canonical_solution": "def canonical_solution():\n    import numpy as np\n    from astropy.stats import sigma_clip\n\n    x = np.array([1, 0, 0, 1, 99, 0, 0, 1, 0])\n    clipped = sigma_clip(x)\n    return clipped.mean()\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查两个浮点数是否近似相等\n    return np.isclose(data1, data2, atol=1e-8)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 306,
        "prompt_en": "Apply sigma clipping to the data list [1, 5, 6, 8, 100, 5, 3, 2], excluding data points that deviate from the mean by more than 2 times the standard deviation, with a maximum of 5 iterations. Calculate the mean of the data after clipping.",
        "prompt_zh": "对数据列表[1, 5, 6, 8, 100, 5, 3, 2]进行sigma剪裁处理，剔除与平均值偏离超过2倍标准差的数据点，最大迭代次数为5，并计算剪裁之后数据的平均值。",
        "canonical_solution": "def canonical_solution():\n    from astropy import stats\n    import numpy as np\n\n    data = [1, 5, 6, 8, 100, 5, 3, 2]\n    data_clipped = stats.sigma_clip(data, sigma=2, maxiters=5)\n    mean_clipped = np.mean(data_clipped)\n    return mean_clipped\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查两个浮点数是否近似相等\n    return np.isclose(data1, data2, atol=1e-8)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 307,
        "prompt_en": "Calculate the mean, median, and standard deviation of the list data [1, 5, 6, 8, 100, 5, 3, 2] after applying sigma clipping (removing data points that exceed 2 standard deviations) for 5 iterations.",
        "prompt_zh": "计算列表数据 [1, 5, 6, 8, 100, 5, 3, 2] 经过sigma剪裁（剔除超过2个标准差的数据点）5次迭代之后的平均值、中位数和标准差。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import stats\n\n    data = [1, 5, 6, 8, 100, 5, 3, 2]\n    mean_clipped, median_clipped, std_clipped = stats.sigma_clipped_stats(data, sigma=2, maxiters=5)\n    return mean_clipped, median_clipped, std_clipped\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查两个浮点数是否近似相等\n    return np.isclose(data1, data2, atol=1e-8)\n\n",
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查两个浮点数是否近似相等\n    return np.isclose(data1, data2, atol=1e-8)\n\n",
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查两个浮点数是否近似相等\n    return np.isclose(data1, data2, atol=1e-8)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 308,
        "prompt_en": "Obtain the conversion factor for transforming the standard deviation of a Gaussian distribution to its full width at half maximum (FWHM).",
        "prompt_zh": "获取将高斯分布的标准差转换为全宽半最大值的转换因子。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.stats import gaussian_sigma_to_fwhm\n\n    return gaussian_sigma_to_fwhm\n\n\n",
        "test_code": [
            "\nimport math\n\ndef test_code(data1, data2):\n    # 设置绝对误差容许值\n    abs_tol = 1e-8\n    # 使用math.isclose来比较两个浮点数是否在误差范围内相等\n    return math.isclose(data1, data2, abs_tol=abs_tol)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 309,
        "prompt_en": "Generate a set of artificial data consisting of 200 data points. The data is composed of two parts: the first part follows a normal distribution with a mean of 0 and a standard deviation of 0.2, while the second part consists of outliers generated with a 35% probability, following a normal distribution with a mean of 3.0 and a standard deviation of 5.0. Next, apply sigma clipping with a threshold of three standard deviations and up to 10 iterations to remove outliers from the dataset. Return the processed dataset.",
        "prompt_zh": "生成一组包括200个数据点的人工数据，数据由两部分组成：第一部分是符合均值为0，标准差为0.2的正态分布，第二部分是35%几率生成的异常值，其符合均值为3.0，标准差为5.0的正态分布。接着，应用三个标准差和最多10次迭代的Sigma剪裁处理，去除异常值，并返回处理后的数据集。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.stats import SigmaClip\n  import numpy as np\n  import scipy.stats as stats\n  # Generate fake data with a mean of 0, std dev of 0.2, and outliers\n  rng = np.random.default_rng(0)\n  x = np.arange(200)\n  y = np.zeros(200)\n  c = stats.bernoulli.rvs(0.35, size=x.shape)\n  y += (rng.normal(0., 0.2, x.shape) + c * rng.normal(3.0, 5.0, x.shape))\n  # Define a SigmaClip instance\n  sigclip = SigmaClip(sigma=3, maxiters=10)\n  \n  # Apply sigma clipping using the instance\n  filtered_data = sigclip(y)\n  return filtered_data\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n  if not np.allclose(data1.data, data2.data, atol=1e-8):\n     return False\n  if not np.allclose(data1.mask, data2.mask, atol=1e-8):\n     return False\n  if data1.fill_value!=data2.fill_value:\n     return False\n  return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 310,
        "prompt_en": "Generate a one-dimensional dataset containing 200 data points, where the data consists of zero values plus Gaussian-distributed noise with a mean of 0 and a standard deviation of 0.2. Additionally, 35% of the data points are randomly augmented with larger Gaussian-distributed noise (mean of 3.0, standard deviation of 5.0) to simulate outliers. Then, use the sigma clipping statistics method (with a maximum of 10 iterations) to compute and return the mean, median, and standard deviation of the dataset after removing outliers.",
        "prompt_zh": "成一个含200个数据点的一维数据集，其中数据由零值加高斯分布噪声（均值0，标准差0.2）组成，且35%的数据点被随机加入更大的高斯分布噪声（均值3.0，标准差5.0）以模拟离群点。随后利用sigma剪切统计法（最大迭代次数为10）计算并返回剔除了离群点的数据集的均值、中位数和标准偏差。",
        "canonical_solution": "def canonical_solution():\n  from astropy.stats import sigma_clipped_stats\n  import numpy as np\n  import scipy.stats as stats\n  # Generate fake data with a mean of 0, std dev of 0.2, and outliers\n  rng = np.random.default_rng(0)\n  x = np.arange(200)\n  y = np.zeros(200)\n  c = stats.bernoulli.rvs(0.35, size=x.shape)\n  y += (rng.normal(0., 0.2, x.shape) + c * rng.normal(3.0, 5.0, x.shape))\n  # Calculate sigma-clipped mean, median, and standard deviation\n  mean, median, std_dev = sigma_clipped_stats(y, sigma=3, maxiters=10)\n  return mean, median, std_dev\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查两个浮点数是否近似相等\n    return np.isclose(data1, data2, atol=1e-8)\n\n",
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查两个浮点数是否近似相等\n    return np.isclose(data1, data2, atol=1e-8)\n\n",
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查两个浮点数是否近似相等\n    return np.isclose(data1, data2, atol=1e-8)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 311,
        "prompt_en": "Generate a dataset consisting of 200 data points, where each point's value is a random number drawn from a normal distribution with a mean of 0 and a standard deviation of 0.2. However, 35% of the points will additionally overlay a normal distribution with a mean of 3 and a standard deviation of 5 to simulate outliers. Then, calculate the mean, median, and standard deviation after applying 3-sigma clipping to this data.",
        "prompt_zh": "生成一个由200个数据点组成的数据集，每个点的值为从具有均值为0和标准差为0.2的正态分布生成的随机数，但同时有35%的点会叠加一个均值为3、标准差为5的正态分布，以模拟异常值。然后计算这些数据经过3-sigma剪裁之后的均值、中位数和标准差。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.stats import sigma_clipped_stats\n    import numpy as np\n    import scipy.stats as stats\n    # Generate synthetic data with a mean of 0 and standard deviation of 0.2, but with outliers\n    rng = np.random.default_rng(0)\n    x = np.arange(200)\n    y = np.zeros(200)\n    c = stats.bernoulli.rvs(0.35, size=x.shape)\n    y += (rng.normal(0., 0.2, x.shape) + c * rng.normal(3.0, 5.0, x.shape))\n    # Calculate sigma-clipped statistics\n    mean, median, stddev = sigma_clipped_stats(y, sigma=3, maxiters=10)\n    return mean, median, stddev\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查两个浮点数是否近似相等\n    return np.isclose(data1, data2, atol=1e-8)\n\n",
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查两个浮点数是否近似相等\n    return np.isclose(data1, data2, atol=1e-8)\n\n",
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查两个浮点数是否近似相等\n    return np.isclose(data1, data2, atol=1e-8)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 312,
        "prompt_en": "Create a table with 5 rows and 3 columns, with column names 'a', 'b', 'c', and data consisting of consecutive integers from 0 to 14. Set the format of column 'a' to three decimal places, the unit to meters per second, and add the description \"unladen swallow velocity.\" Print the table and return it as the function output.",
        "prompt_zh": "创建一个5行3列的表格，列名分别为'a', 'b', 'c'，数据为从0到14的连续整数。为列'a'设置格式为小数点后三位，单位为米/秒，并添加描述为\"unladen swallow velocity\"。打印表格并将其作为函数输出。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.table import Table\n  import numpy as np\n  import astropy.units as u\n  arr = np.arange(15, dtype=np.int32).reshape(5, 3)\n  t = Table(arr, names=('a', 'b', 'c'), meta={'keywords': {'key1': 'val1'}})\n  t['a'].format = \"{:.3f}\"  # print with 3 digits after decimal point\n  t['a'].unit = u.m / u.second\n  t['a'].description = 'unladen swallow velocity'\n  print(t)\n  return t\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 313,
        "prompt_en": "Create an Astropy Table object containing three columns: 'a', 'b', and 'c'. Each column contains three numerical elements, which are [1, 2, 3], [4, 5, 6], and [7, 8, 9] respectively, with the unit of kilometers. Finally, return the result of the element-wise addition of columns 'a' and 'b'.",
        "prompt_zh": "创建一个Astropy的Table对象，其中包含三列数据'a'、'b'和'c'，每列包含三个数值元素，分别是[1, 2, 3],[4, 5, 6],[7, 8, 9]，单位为千米。最后返回列'a'和'b'的元素逐个相加的结果。",
        "canonical_solution": "def canonical_solution():\n  from astropy.table import Table, Column\n  t = Table()\n  t['a'] = Column([1, 2, 3], unit='km')\n  t['b'] = Column([4, 5, 6], unit='km')\n  t['c'] = Column([7, 8, 9], unit='km')\n  return t['a'] + t['b']\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 314,
        "prompt_en": "Create an Astropy Table object containing two columns of data. The first column, named 'col0', contains three values [1, 2, 3] formatted in scientific notation with the unit 'km^2'. The second column, named 'col1', contains three values [4, 5, 6] with the unit 'km/s'. Print the table with a maximum of 8 lines and a maximum width of 40, and do not show column names. Finally, return the created Table object.",
        "prompt_zh": "创建一个Astropy Table对象，其包含两列数据。第一列名为'col0'，其中包含格式化为科学计数法的三个数值[1, 2, 3]，单位为'km^2'。第二列名为'col1'，其中包含三个数值[4, 5, 6]，单位为'km/s'。将该表格打印出来，表格最大行数设置为8行，最大宽度设置为40，列名不显示。最终返回创建的Table对象。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.table import Table, Column\n  import astropy.units as u\n  t = Table()\n  t['col0'] = Column([1, 2, 3], format='%e', unit='km^2')\n  t['col1'] = Column([4, 5, 6], unit='km/s')\n  t.pprint(max_lines=8, max_width=40, show_name=False)\n  return t\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 315,
        "prompt_en": "Create a table with 5 rows and 3 columns, filled with continuous integers from 0 to 14, and name the columns as 'a', 'b', and 'c'. Add metadata with a keyword 'key1' and its corresponding value 'val1'. Finally, return the data of the column named 'a' from the table.",
        "prompt_zh": "创建一个5行3列的表格，使用从0到14的连续整数填充，并将列命名为a、b和c。添加包含关键字key1和对应值val1的元数据。最后，返回该表格中名为a的列的数据。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.table import Table\n    import numpy as np\n    arr = np.arange(15).reshape(5, 3)\n    t = Table(arr, names=('a', 'b', 'c'), meta={'keywords': {'key1': 'val1'}})\n    return t.columns['a']\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 316,
        "prompt_en": "In the Astropy table, create a table containing two columns (named 'a' and 'b') and three rows of data ([1, 2], [3, 4], [5, 6]). Then, return the value of the second element in column 'a'.",
        "prompt_zh": "在Astropy表格中，创建包含两列（名为'a'和'b'）和三行数据（[1, 2], [3, 4], [5, 6]）的表，然后返回列'a'中的第二个元素的值。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.table import Table\n    t = Table(rows=[[1, 2], [3, 4], [5, 6]], names=('a', 'b'))\n    return t['a'][1]\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 检查整数值是否相等\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 317,
        "prompt_en": "Create two Astropy table objects, both containing three columns named 'a', 'b', and 'c'. The data rows for the first table are [1, 2, 3], [4, 5, 6], and [7, 7, 9], while the data rows for the second table are [1, 2, -1], [4, -1, 6], and [7, 7, 9]. Then, compare the data rows of the two tables and return the boolean result of each element comparison.",
        "prompt_zh": "创建两个Astropy表格对象，均包含名为'a'、'b'、'c'的三列，第一个表格的数据行为[1, 2, 3]，[4, 5, 6]，[7, 7, 9]，第二个表格的数据行为[1, 2, -1]，[4, -1, 6]，[7, 7, 9]，然后比较两个表格的数据行，并返回每个元素比较的布尔结果。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.table import Table\n    t = Table(rows=[[1, 2, 3],\n                    [4, 5, 6],\n                    [7, 7, 9]], names=['a', 'b', 'c'])\n    t2 = Table(rows=[[1, 2, -1],\n                    [4, -1, 6],\n                    [7, 7, 9]], names=['a', 'b', 'c'])\n    return t == t2\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 318,
        "prompt_en": "Create an Astropy Table and add two columns of data to the table. Assign the first column 'a' with the data [1, 2, 3] in units of meters, and the second column 'b' with the data [4, 5, 6] in units of meters per second. Then convert the units of the first column 'a' from meters to kilometers and return this column.",
        "prompt_zh": "创建一个Astropy Table，并在该表中添加两列数据，第一列'a'的数据按照单位米赋值为[1, 2, 3]，第二列'b'的数据按照单位米每秒赋值为[4, 5, 6]。然后将第一列'a'的单位从米转换为千米并返回这一列。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.table import Table\n    import numpy as np\n    from astropy import units as u\n    t = Table()\n    t['a'] = [1, 2, 3] * u.m\n    t['b'] = [4, 5, 6] * u.m/u.s\n    return t['a'].to(u.km)\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 319,
        "prompt_en": "Create an Astropy Table object with three columns 'a', 'b', 'c', and fill it with the data rows (1, 2.0, 'x'), (4, 5.0, 'y'), and (5, 8.2, 'z').",
        "prompt_zh": "创建一个包含三列 'a', 'b', 'c' 的Astropy Table对象，并分别填入数据行 (1, 2.0, 'x'), (4, 5.0, 'y'), (5, 8.2, 'z')。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.table import Table\n  data_rows = [(1, 2.0, 'x'), (4, 5.0, 'y'), (5, 8.2, 'z')]\n  names = ('a', 'b', 'c')\n  t = Table(rows=data_rows, names=names)\n  return t\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 320,
        "prompt_en": "Create a QTable containing three columns. The first column is named 'a' and contains angle data in degrees [1, 4]. The second column is named 'b' and contains length data in meters [2.0, 5.0]. The third column is named 'c' and contains string data ['x', 'y']. Finally, return this table.",
        "prompt_zh": "创建一个包含三列的量化表（QTable），第一列名为'a'含有以度为单位的角度数据[1, 4]，第二列名为'b'含有以米为单位的长度数据[2.0, 5.0]，第三列名为'c'含有字符串数据['x', 'y']，最后返回这个表。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.table import QTable\n  from astropy import units as u\n  import numpy as np\n  \n  # 创建一个QTable对象\n  t = QTable()\n  t['a'] = [1, 4] * u.degree\n  t['b'] = [2.0, 5.0] * u.meter\n  t['c'] = ['x', 'y']\n  \n  return t\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 321,
        "prompt_en": "Create an Astropy Table object containing three columns of data. The first column is named 'a' and contains the values [1, 4] with the unit of meters. The second column is named 'b' and contains the values [2.0, 5.0] with the unit of kilometers. The third column is named 'c' and contains the characters ['x', 'y'] with no unit and data type of single character. Return this table object.",
        "prompt_zh": "创建一个包含三列数据的Astropy Table对象，第一列名为'a'，包含数值[1, 4]，单位为米；第二列名为'b'，包含数值[2.0, 5.0]，单位为千米；第三列名为'c'，包含字符['x', 'y']，无单位，数据类型为单字符。返回这个表格对象。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.table import Table, Column\n  from astropy import units as u\n  \n  # 创建一个Table对象\n  t = Table()\n  t['a'] = Column([1, 4], unit=u.meter)\n  t['b'] = Column([2.0, 5.0], unit=u.kilometer)\n  t['c'] = Column(['x', 'y'], unit='', dtype='S1')\n  \n  return t\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 322,
        "prompt_en": "Create an Astropy Table object using a structured array that includes integers, floating-point numbers, and strings with a maximum length of two characters. Return the Table object. The data tuples in the structured array are (1, 2.0, 'x') and (4, 5.0, 'y'), with data types corresponding to integer, double precision float, and a string of length 2, respectively.",
        "prompt_zh": "使用一个结构化数组创建一个Astropy Table对象，数组包含整数、浮点数以及最多两个字符的字符串，并返回该Table对象。结构化数组的数据元组为(1, 2.0, 'x')和(4, 5.0, 'y')，数据类型分别对应为整数、双精度浮点数和长度为2的字符串。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.table import Table, Column\n  import numpy as np\n  \n  # 使用结构化数组创建一个Table对象\n  arr = np.array([(1, 2.0, 'x'), (4, 5.0, 'y')],\n                 dtype=[('a', 'i4'), ('b', 'f8'), ('c', 'U2')])\n  t = Table(arr)\n  \n  return t\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 323,
        "prompt_en": "Create a star table containing two time points '2000:002' and '2002:345' and store it as an astronomical table QTable with the column name 'time'. Also, create two celestial coordinates (10°, -45°) and (20°, +40°), with units in degrees, and store them in the table with the column name 'skycoord'. Calculate the time difference between each time point and the Chandra telescope launch time '1999-07-23 04:30:59.984', and add the result to the table in units of days with the column name 'dt_cxo'. The time difference should be rounded to three decimal places. The function returns the final created star table.",
        "prompt_zh": "创建一个包含两个时间点 '2000:002' 和 '2002:345' 的星表，并将其存储为天文表格QTable，列名为time。同时创建两个天体坐标 (10°, -45°) 与 (20°, +40°) ，单位为度，并存储在表格中，列名为skycoord。计算每个时间点与钱德拉望远镜发射时间 '1999-07-23 04:30:59.984' 之间的时间差，并将结果以天数为单位添加到 表格中，列名为'dt_cxo'，时间差保留3位小数。函数返回最终创建的星表。",
        "canonical_solution": "def canonical_solution():\n    from astropy.table import QTable\n    import astropy.units as u\n    from astropy.coordinates import SkyCoord \n    from astropy.time import Time\n    # 创建时间和天体坐标数据\n    tm = Time(['2000:002', '2002:345'])\n    sc = SkyCoord([10, 20], [-45, +40], unit='deg')\n    \n    # 创建包含这些数据的表\n    t = QTable([tm, sc], names=['time', 'skycoord'])\n    \n    # 求时间间隔并添加到表中\n    chandra_launch = Time('1999-07-23 04:30:59.984')\n    t['dt_cxo'] = (t['time'] - chandra_launch).to(u.d)\n    \n    # 设置输出格式\n    t['dt_cxo'].info.format = '.3f'\n    return t\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 324,
        "prompt_en": "Create a QTable named 'first table' with four columns named 'a', 'b', 'c', and 'd'. The 'a' column should contain the integer values [1, 4, 5], the 'b' column should contain the float values [2.0, 5.0, 8.5], the 'c' column should contain the character values ['x', 'y', 'z'], and the 'd' column should contain values with physical units (meters per second) [10, 20, 30]. Finally, return this table object.",
        "prompt_zh": "创建一个名字为'first table'的QTable表格，包含四列命名为'a', 'b', 'c', 'd'。其中，'a'列包含整数值[1, 4, 5]，'b'列包含浮点数值[2.0, 5.0, 8.5]，'c'列包含字符值['x', 'y', 'z']，'d'列包含带物理单位（米每秒）的数值[10, 20, 30]。最后返回这个表格对象。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.table import QTable\n  import astropy.units as u\n  import numpy as np\n  \n  a = np.array([1, 4, 5], dtype=np.int32)\n  b = [2.0, 5.0, 8.5]\n  c = ['x', 'y', 'z']\n  d = [10, 20, 30] * u.m / u.s\n  \n  t = QTable([a, b, c, d], names=('a', 'b', 'c', 'd'), meta={'name': 'first table'})\n  return t\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 325,
        "prompt_en": "Create an Astropy Table object with three columns named 'a', 'b', and 'c'. Column 'a' contains elements [1, 4, 5], but the first two elements should be considered missing or invalid. Column 'b' contains floating-point numbers [2.0, 5.0, 8.5], and column 'c' contains the characters ['x', 'y', 'z']. Return the final table object created.",
        "prompt_zh": "创建一个包含三列名为'a'、'b'和'c'的Astropy Table对象。列'a'包含元素[1, 4, 5]，但其前两个元素应被视为缺失或无效。列'b'包含浮点数[2.0, 5.0, 8.5]，而列'c'包含字母字符['x', 'y', 'z']。返回最终创建的表格对象。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.table import Table, MaskedColumn\n  \n  a = [1, 4, 5]\n  b = [2.0, 5.0, 8.5]\n  c = ['x', 'y', 'z']\n  a_masked = MaskedColumn(a, mask=[True, True, False])\n  \n  t = Table([a_masked, b, c], names=('a', 'b', 'c'))\n  return t\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 326,
        "prompt_en": "Create an Astropy table with two columns named 'a' and 'b', using the tuples (2, 3, 2, 1) and (8, 7, 6, 5) as data. Add an index for column 'a', and return the index object.",
        "prompt_zh": "创建一个包含两列名为'a'和'b'的Astropy表格，并使用元组(2, 3, 2, 1)和(8, 7, 6, 5)作为数据。为列'a'添加一个索引，并返回该索引的对象。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.table import Table\n  t = Table([(2, 3, 2, 1), (8, 7, 6, 5)], names=('a', 'b'))\n  t.add_index('a')\n  return t.indices['a']\n\n\n",
        "test_code": [
            "def test_code(data1,data2):\n    if len(data1.columns)!=len(data2.columns):\n       return False\n    for colunn1,colunn2 in zip(data1.columns,data2.columns):\n       for value in colunn1==colunn2:\n          if not value:\n             return False\n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 327,
        "prompt_en": "Create a table named `t` with two columns named `'a'` and `'b'`, filling them with data `(2, 3, 2, 1)` and `(8, 7, 6, 5)` respectively. Then create an index for these two columns of data and return the index object.",
        "prompt_zh": "创建一个名为`t`的表格，具有两列名为`'a'`和`'b'`，分别填入数据`(2, 3, 2, 1)`和`(8, 7, 6, 5)`。然后为这两列数据创建一个索引，并返回该索引对象。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.table import Table\n  t = Table([(2, 3, 2, 1), (8, 7, 6, 5)], names=('a', 'b'))\n  t.add_index(['a', 'b'])\n  return t.indices['a', 'b']\n\n\n",
        "test_code": [
            "def test_code(data1,data2):\n    if len(data1.columns)!=len(data2.columns):\n       return False\n    for colunn1,colunn2 in zip(data1.columns,data2.columns):\n       for value in colunn1==colunn2:\n          if not value:\n             return False\n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 328,
        "prompt_en": "Create an Astropy Table with columns 'a' and 'b' using the data [1, 2, 3, 4] for column 'a' and [10, 1, 9, 9] for column 'b'. Then, build an index for column 'a' and return the rows where the values in column 'a' are between 1 and 3.",
        "prompt_zh": "创建一个以整数列'a'和'b'为数据的Astropy Table。列'a'的数据为[1, 2, 3, 4]，列'b'的数据为[10, 1, 9, 9]。然后，为列'a'建立索引，并返回表中列'a'值在1到3之间的数据行。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.table import Table\n  t = Table([(1, 2, 3, 4), (10, 1, 9, 9)], names=('a', 'b'), dtype=['i8', 'i8'])\n  t.add_index('a')\n  return t.loc[1:3]\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 329,
        "prompt_en": "Create an Astropy Table object containing two columns of data named 'a' and 'b'. Add string data 'w', 'x', 'y', 'z' to column 'a' and integer data 10, 1, 9, 9 to column 'b'. Build an index for column 'a' to enable fast retrieval by key value. Then, update the row data with key value 'x' to ['a', 12]. Finally, return the updated Table object.",
        "prompt_zh": "创建一个Astropy Table对象，包含两列命名为'a'和'b'的数据。在列'a'中添加字符串数据'w', 'x', 'y', 'z'，并在列'b'中添加整数数据10, 1, 9, 9。给列'a'建立索引以便能够按键值快速检索。然后，将键值为'x'的行数据更新为['a', 12]。最后，返回更新后的Table对象。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.table import Table\n  t = Table([('w', 'x', 'y', 'z'), (10, 1, 9, 9)], names=('a', 'b'), dtype=['str', 'i8'])\n  t.add_index('a')\n  t.loc['x'] = ['a', 12]\n  return t\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 330,
        "prompt_en": "Create an Astropy table consisting of two columns. The first column, named 'a', should have string data with values ('w', 'x', 'y', 'z'). The second column, named 'b', should have 64-bit integer data with values (10, 1, 9, 9). Add an index based on column 'a'. Retrieve and return the row index number where the value in column 'a' is 'x'.",
        "prompt_zh": "创建一个由两列组成的Astropy表，第一列的列名为'a'，数据为字符串类型，具有值('w', 'x', 'y', 'z')；第二列的列名为'b'，数据为64位整数类型，具有值(10, 1, 9, 9)。为这个表添加一个基于列'a'的索引，检索列'a'中值为'x'的行索引号并返回。",
        "canonical_solution": "def canonical_solution():\n  from astropy.table import Table\n  t = Table([('w', 'x', 'y', 'z'), (10, 1, 9, 9)], names=('a', 'b'), dtype=['str', 'i8'])\n  t.add_index('a')\n  return t.loc_indices['x']\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 检查整数值是否相等\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 331,
        "prompt_en": "Create an Astropy table that includes two columns of data. The first column, named 'a', contains masked integer values [1, 2] (with the second value masked), and the second column, named 'b', contains integer values [3, 4]. Then return this table.",
        "prompt_zh": "创建一个Astropy表格，包含两列数据，第一列名为'a'且包含掩码的整数值[1, 2]（第二个值被掩码），第二列名为'b'且包含整数值[3, 4]，然后返回这个表格。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.table import Table, Column, MaskedColumn\n    a = MaskedColumn([1, 2], name='a', mask=[False, True], dtype='i4')\n    b = Column([3, 4], name='b', dtype='i8')\n    return Table([a, b])\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 332,
        "prompt_en": "Create an Astropy table containing two columns: an integer column 'a' with values [1, 2], and a masked column 'b' with values [3, 4], where the first value is masked as invalid.",
        "prompt_zh": "创建一个Astropy表，该表包含两列：整数列'a'，其值为[1, 2]，以及一个带有掩码的列'b'，其值为[3, 4]，其中第一个值被掩码标记为无效。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.table import Table, MaskedColumn\n    t = Table([[1, 2]], names=['a'])\n    b = MaskedColumn([3, 4], mask=[True, False])\n    t['b'] = b\n    return t\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 333,
        "prompt_en": "Create an Astropy Table object containing two columns named 'a' and 'b', where the 'a' column values are [1, 2], and the 'b' column values are [3, 4]. Then add a row of data [3, 6] to the table, where the value in the first column should be masked as invalid, while the second column remains valid. Return the final table object.",
        "prompt_zh": "创建一个Astropy表格对象，包含两列名为'a'和'b'，其中'a'列的值为[1, 2]，'b'列的值为[3, 4]。然后向表格中添加一行数据[3, 6]，其中第一列的值应该被掩码处理为无效，第二列保持有效。返回最终的表格对象。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.table import Table, Column\n    a = Column([1, 2], name='a')\n    b = Column([3, 4], name='b')\n    t = Table([a, b])\n    t.add_row([3, 6], mask=[True, False])\n    return t\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 334,
        "prompt_en": "Create an Astropy table with two columns named 'a' and 'b', containing data [(1, 2), (3, 4)] with masking support, where the data type for column 'a' is a 32-bit integer and for column 'b' is a 64-bit integer.",
        "prompt_zh": "创建一个具有两列的Astropy表，列名分别为'a'和'b'，包含数据[(1, 2), (3, 4)]，并支持掩码处理，其中列'a'的数据类型为32位整数，列'b'的数据类型为64位整数。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.table import Table\n    return Table([(1, 2), (3, 4)], names=('a', 'b'), masked=True, dtype=('i4', 'i8'))\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 335,
        "prompt_en": " Create a quantized table QTable containing index, time, and velocity data. The index column includes numbers 1 and 2, the time column includes two ISO format dates '2001-01-02T12:34:56' and '2001-02-03T00:01:02' in the form of astropy Time objects, and the velocity column includes values 3 and 4 in m/s. Return this quantized table.",
        "prompt_zh": "创建一个包含索引、时间和速度数据的量化表格QTable。索引列包括数字1和2，时间列以astropy Time对象形式包括两个ISO格式日期'2001-01-02T12:34:56'和'2001-02-03T00:01:02'，速度列以m/s为单位包括数值3和4，返回这个量化表格。",
        "canonical_solution": "def canonical_solution():\n    from astropy.table import QTable\n    from astropy.time import Time\n    import astropy.units as u\n    qt = QTable()\n    qt['index'] = [1, 2]\n    qt['time'] = Time(['2001-01-02T12:34:56', '2001-02-03T00:01:02'])\n    qt['velocity'] = [3, 4] * u.m / u.s\n    return qt\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 336,
        "prompt_en": "Create an Astropy Table and add two columns: a 'index' column containing integer values [1, 2], and a 'time' column containing the time strings ['2001-01-02T12:34:56', '2001-02-03T00:01:02']. Return this table object.",
        "prompt_zh": "创建一个Astropy Table，并添加两列：'index'列，包含整数值[1, 2]，以及'time'列，包含时间字符串['2001-01-02T12:34:56', '2001-02-03T00:01:02']。返回这个表格对象。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.table import Table\n  from astropy.time import Time\n  t = Table()\n  t['index'] = [1, 2]\n  t['time'] = Time(['2001-01-02T12:34:56', '2001-02-03T00:01:02'])\n  return t\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 337,
        "prompt_en": "Create an Astropy table containing 5 rows and 3 columns of numbers (from 0 to 14), and name the columns 'a', 'b', and 'c', respectively. Then, change the value in the third row of column 'a' to 30, and add a set of metadata keywords to the table, with the keyword 'key1' corresponding to the value 'val1'. Finally, return the modified table object.",
        "prompt_zh": "创建一个包含5行3列数字（从0到14）的Astropy表格，并为列分别命名为'a'、'b'、'c'。然后，将表格中列'a'的第3行的值更改为30，并为表格添加一组元数据关键字，关键字为'key1'对应的值为'val1'。最后，返回这个修改后的表格对象。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.table import Table\n    import numpy as np\n    arr = np.arange(15).reshape(5, 3)\n    t = Table(arr, names=('a', 'b', 'c'), meta={'keywords': {'key1': 'val1'}})\n    t['a'][2] = 30  # Set row 2 of column 'a'\n    return t\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 338,
        "prompt_en": "Create a 5-row, 3-column Astropy table with column names 'a', 'b', and 'c', containing consecutive integers from 0 to 14, and replace the entire row with index 1 with the values (8, 9, 10). Additionally, add the metadata keyword 'key1' and its corresponding value 'val1' to the table. Return the modified table.",
        "prompt_zh": "创建一个5行3列的Astropy表格，列名分别为'a'，'b'，和'c'，包含从0到14的连续整数，并将索引为1的行整体替换为数值(8, 9, 10)。同时，为表格添加元数据关键词'key1'和对应的值'val1'。最后返回这个已经修改过的表格。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.table import Table\n    import numpy as np\n    arr = np.arange(15).reshape(5, 3)\n    t = Table(arr, names=('a', 'b', 'c'), meta={'keywords': {'key1': 'val1'}})\n    t[1] = (8, 9, 10)  # Set all values of row 1\n    return t\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 339,
        "prompt_en": "Create a table with 5 rows and 3 columns, with column names as 'a', 'b', and 'c', and metadata containing the keyword 'key1' with the value 'val1'. Then, set the values of the first three rows in column 'c' to 100, and return the final table.",
        "prompt_zh": "创建一个5行3列的表格，列名分别为a、b、c，元数据中包含关键字'key1'对应的值'val1'。然后，将列c的前三行的值设置为100，并返回最终的表格。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.table import Table\n    import numpy as np\n    arr = np.arange(15).reshape(5, 3)\n    t = Table(arr, names=('a', 'b', 'c'), meta={'keywords': {'key1': 'val1'}})\n    t[0:3]['c'] = 100  # Set column 'c' of rows 0, 1, 2\n    return t\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 340,
        "prompt_en": "Create an Astropy table consisting of data in 5 rows and 3 columns. The data is a sequence of integers from 0 to 14, reshaped into a 5x3 array. The column names should be 'a', 'b', and 'c', and the table should contain metadata with an entry having the key 'key1' and value 'val1'. Then, modify the values in column 'a' to 1, -2, 3, -4, 5 respectively, and return the final table.",
        "prompt_zh": "创建一个Astropy表格，它包含5行3列的数据。数据是从0到14的连续整数，并且这些数据被重塑成5行3列。列名分别为'a'、'b'和'c'，并且表含有元数据，其中包括一个键为'key1'，值为'val1'的关键字条目。接着，将'a'列的数值依次修改为1, -2, 3, -4, 5，并返回最终的表格。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.table import Table\n    import numpy as np\n    arr = np.arange(15).reshape(5, 3)\n    t = Table(arr, names=('a', 'b', 'c'), meta={'keywords': {'key1': 'val1'}})\n    t['a'][:] = [1, -2, 3, -4, 5]\n    return t\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 341,
        "prompt_en": "Create an Astropy table containing 5 rows and 3 columns of integers (from 0 to 14). Name the columns 'a', 'b', and 'c'. Then modify the content of the second row to (8, 9, 10) and change the value in the second row of column 'b' to -9. Finally, return the table.",
        "prompt_zh": "创建一个包含5行3列整数（从0到14）的Astropy表，对这个表命名列为'a'、'b'、'c'。然后修改表中第2行的内容为(8, 9, 10)并将'b'列第2行的值改为-9，最后返回这个表。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.table import Table\n    import numpy as np\n    t = Table(np.arange(15).reshape(5, 3), names=('a', 'b', 'c'))\n    t[1] = (8, 9, 10)\n    t[1]['b'] = -9\n    return t\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 342,
        "prompt_en": "Create a table with 5 rows and 3 columns, with column names 'a', 'b', and 'c'. If the elements in column 'a' are greater than 3, set their values to 3. Finally, return the modified table.",
        "prompt_zh": "创建一个具有5行3列的表格，列名分别为'a', 'b', 'c'，并且'а'列的元素如果大于3，则将这些元素的值设置为3，最后返回修改后的表格。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.table import Table\n    import numpy as np\n    t = Table(np.arange(15).reshape(5, 3), names=('a', 'b', 'c'))\n    t['a'][np.where(t['a'] > 3)] = 3.\n    return t\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 343,
        "prompt_en": "Create an Astropy Table object containing 3 columns named 'a', 'b', and 'c' with 5 rows of data (integers from 0 to 14). Then add a new column named 'e' containing integers from 0 to 4 and insert it as the first column of the table. Finally, return the updated table.",
        "prompt_zh": "创建一个Astropy Table对象，包含列名称为'a'、'b'、'c'的3列和5行数据（从0到14的整数）。然后，向该表格添加一个名为'e'的新列，包含从0到4的整数，并将该列添加为表格的第一列。最后返回更新后的表格。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.table import Table, Column\n    import numpy as np\n    t = Table(np.arange(15).reshape(5, 3), names=('a', 'b', 'c'))\n    c = Column(np.arange(5), name='e')\n    t.add_column(c, index=0)\n    return t\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 344,
        "prompt_en": "Create a 5x3 table filled with consecutive integers (from 0 to 14), and assign the column names 'a', 'b', and 'c' respectively. Remove the first row of the table, then return the modified table.",
        "prompt_zh": "创建一个包含连续整数（从 0 到 14）的 5 行 3 列表格，并赋予列名分别为 'a'、'b'、'c'。移除表格的第一行，然后返回修改后的表格。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.table import Table\n    import numpy as np\n    t = Table(np.arange(15).reshape(5, 3), names=('a', 'b', 'c'))\n    t.remove_row(0)\n    return t\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 345,
        "prompt_en": "Create a 5x3 array containing numbers from 0 to 14 and convert it to an Astropy table with column names set as 'a', 'b', and 'c'. Add a set of metadata keywords with 'key1' corresponding to 'val1'. Set all values in column 'a' to 1, -2, 3, -4, 5, then change the value of the third row in column 'a' to 30, set the entire second row's values to 8, 9, 10, change the value of column 'b' in the second row to -9, and set the values of column 'c' in the first three rows to 100. Return the modified table.",
        "prompt_zh": "创建一个包含数字0至14的5x3数组并把它转换为一个Astropy表格，列名分别设置为'a'、'b'、'c'，并为表格添加一组元数据关键字，关键字为'key1'对应的值为'val1'。设置列'a'的所有值为1、-2、3、-4、5，接着改变列'a'的第三行的值为30，将整个第二行的值设置为8、9、10，将第二行列'b'的值改为-9，并将前三行列'c'的值都设置为100。最后返回这个修改后的表格。",
        "canonical_solution": "def canonical_solution():\n    from astropy.table import Table\n    import numpy as np\n    arr = np.arange(15).reshape(5, 3)\n    t = Table(arr, names=('a', 'b', 'c'), meta={'keywords': {'key1': 'val1'}})\n    t['a'][:] = [1, -2, 3, -4, 5]  # Set all values of column 'a'\n    t['a'][2] = 30                 # Set row 2 of column 'a'\n    t[1] = (8, 9, 10)              # Set all values of row 1\n    t[1]['b'] = -9                 # Set column 'b' of row 1\n    t[0:3]['c'] = 100              # Set column 'c' of rows 0, 1, 2\n    return t\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 346,
        "prompt_en": "Sure, here is the translation for the second sample:\n\nEnglish: Create an astronomical table with three columns named 'a', 'b', and 'c', where the values of columns 'a', 'b', and 'c' are [1, 2], [3, 4], and [5, 6] respectively. Then, replace all values in column 'a' that are greater than 3 with the number 3, and return the modified table.",
        "prompt_zh": "创建一个含有三列（命名为'a'、'b'和'c'）的天文表，其中列'a'、'b'、'c'的值分别是[1, 2]、[3, 4]、[5, 6]。然后，将表中列'a'中所有大于3的值替换为3，最后返回修改后的表。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.table import Table\n    import numpy as np\n    t = Table([[1, 2], [3, 4], [5, 6]], names=('a', 'b', 'c'))\n    t['a'][np.where(t['a'] > 3)] = 3.\n    return t\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 347,
        "prompt_en": "Create an Astropy table with four columns named 'a', 'b', 'c', and 'd'. Columns 'a' and 'd' should contain integer data with values [1, 4, 5, 6] and [100, 200, 300, 400] respectively; column 'b' should contain floating-point data with values [2.0, 5.0, 7.0, 8.0]; column 'c' should contain string data with values ['x', 'y', 'z', 'w']. Add column 'd' as the third column.",
        "prompt_zh": "创建一个Astropy表格，包含四列，分别命名为'a', 'b', 'c', 'd'。列'a'和列'd'是整数类型的数据，分别有[1, 4, 5, 6]和[100, 200, 300, 400]；列'b'是浮点数类型的数据，有[2.0, 5.0, 7.0, 8.0]；列'c'是字符串类型的数据，有['x', 'y', 'z', 'w']。将列'd'添加为第三列。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.table import Table\n    t = Table()\n    t['a'] = [1, 4, 5, 6]\n    t['b'] = [2.0, 5.0, 7.0, 8.0]\n    t['c'] = ['x', 'y', 'z', 'w']\n    t.add_column([100, 200, 300, 400], name='d', index=2)\n    return t\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 348,
        "prompt_en": "Create an Astropy Table containing two columns: the first column named 'a' with integer values [1, 4, 5, 6] and the second column named 'b' with float values [2.0, 5.0, 7.0, 8.0]. Then, remove both columns from the table and return the empty table object.",
        "prompt_zh": "创建一个包含两列的Astropy Table，第一列名为'a'，包含整数值[1, 4, 5, 6]，第二列名为'b'，包含浮点数值[2.0, 5.0, 7.0, 8.0]。然后从表格中移除这两列，并返回空的表格对象。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.table import Table\n    t = Table()\n    t['a'] = [1, 4, 5, 6]\n    t['b'] = [2.0, 5.0, 7.0, 8.0]\n    t.remove_columns(['a', 'b'])\n    return t\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 349,
        "prompt_en": "Compare two astronomical tables, return records uniquely identified by object name and observation date that are present in the first table but not in the second table. The data for the first table is:\n\n```\nname    obs_date    mag_b  mag_v\nM31     2012-01-02  17.0   16.0\nM82     2012-10-29  16.2   15.2\nM101    2012-10-31  15.1   15.5\n```\n\nThe data for the second table is:\n\n```\nname    obs_date    logLx\nNGC3516 2011-11-11  42.1\nM31     1999-01-05  43.1\nM82     2012-10-29  45.0\n```\n\nRead the data using the 'ascii' format and use 'name' and 'obs_date' as the key fields to perform the comparison.",
        "prompt_zh": "对比两个天文表格数据，返回第一个表格中有而第二个表格中没有的，基于天体名称和观测日期唯一识别的记录。第一个表格数据是：\n\n```\nname    obs_date    mag_b  mag_v\nM31     2012-01-02  17.0   16.0\nM82     2012-10-29  16.2   15.2\nM101    2012-10-31  15.1   15.5\n```\n\n第二个表格数据是：\n\n```\nname    obs_date    logLx\nNGC3516 2011-11-11  42.1\nM31     1999-01-05  43.1\nM82     2012-10-29  45.0\n```\n\n要求使用'ascii'格式读取数据，并使用'name'和'obs_date'作为关键字段进行对比。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.table import Table, setdiff\n  cat_1 = Table.read(\"\"\"name    obs_date    mag_b  mag_v\n                       M31     2012-01-02  17.0   16.0\n                       M82     2012-10-29  16.2   15.2\n                       M101    2012-10-31  15.1   15.5\"\"\", format='ascii')\n  cat_2 = Table.read(\"\"\"   name    obs_date    logLx\n                       NGC3516 2011-11-11  42.1\n                       M31     1999-01-05  43.1\n                       M82     2012-10-29  45.0\"\"\", format='ascii')\n  sdiff = setdiff(cat_1, cat_2, keys=['name', 'obs_date'])\n  return sdiff\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 350,
        "prompt_en": "Read two astronomical tables, the first table is: \"\"\"name    obs_date    mag_b  mag_v\nM31     2012-01-02  17.0   16.0\nM82     2012-10-29  16.2   15.2\nM101    2012-10-31  15.1   15.5\"\"\", and the second table is \"\"\"name    obs_date    logLx\nNGC3516 2011-11-11  42.1\nM31     1999-01-05  43.1\nM82     2012-10-29  45.0\"\"\". Use the 'ascii' format to read the data, then merge the two tables based on the object names, retaining only the object information that exists in both tables. Return the merged table.",
        "prompt_zh": "读取两个天文表格数据，第一个表格数据是：\"\"\"name    obs_date    mag_b  mag_v\n                      M31     2012-01-02  17.0   16.0\n                      M82     2012-10-29  16.2   15.2\n                      M101    2012-10-31  15.1   15.5\"\"\"，第二个表格数据是\"\"\"   name    obs_date    logLx\n                      NGC3516 2011-11-11  42.1\n                      M31     1999-01-05  43.1\n                      M82     2012-10-29  45.0\"\"\"，要求使用'ascii'格式读取数据，然后按照天体名称合并这两个表格，仅保留共同存在于两个表中的天体信息，返回合并的表格。",
        "canonical_solution": "def canonical_solution():\n  from astropy.table import Table, join\n  optical = Table.read(\"\"\"name    obs_date    mag_b  mag_v\n                      M31     2012-01-02  17.0   16.0\n                      M82     2012-10-29  16.2   15.2\n                      M101    2012-10-31  15.1   15.5\"\"\", format='ascii')\n  xray = Table.read(\"\"\"   name    obs_date    logLx\n                      NGC3516 2011-11-11  42.1\n                      M31     1999-01-05  43.1\n                      M82     2012-10-29  45.0\"\"\", format='ascii')\n  opt_xray = join(optical, xray, join_type='inner', keys='name')\n  return opt_xray\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 351,
        "prompt_en": "Transform the coordinates '02h31m49.09s', '+89d15m50.8s' from the FK5 epoch of J1970 to the FK5 epoch of J2000.",
        "prompt_zh": "将坐标'02h31m49.09s', '+89d15m50.8s'从J1970的FK5历元转换到J2000的FK5历元。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.time import Time\n  from astropy.coordinates import SkyCoord\n  from astropy.coordinates import FK5\n  fk5c = SkyCoord('02h31m49.09s', '+89d15m50.8s', frame=FK5(equinox=Time('J1970')))\n  fk5_2000 = FK5(equinox=Time(2000, format='jyear'))\n  return fk5c.transform_to(fk5_2000)\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 352,
        "prompt_en": "Format the specified time string `'2010-01-01 00:00:00'` into the form `'YYYY-MM-DD HH:MM:SS'` and return the result.",
        "prompt_zh": "将指定的时间字符串 `'2010-01-01 00:00:00'` 格式化为 `'YYYY-MM-DD HH:MM:SS'` 的形式，并返回结果。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.time import Time\n  # Create a Time object and format output using strftime\n  t = Time('2010-01-01 00:00:00')\n  return t.strftime('%Y-%m-%d %H:%M:%S')\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 353,
        "prompt_en": "Convert the ISO format of two time points '1999-01-01T00:00:00.123456789' and '2010-01-01T00:00:00' to Modified Julian Date (MJD) format and return the result as a long integer value.",
        "prompt_zh": "将'1999-01-01T00:00:00.123456789'和'2010-01-01T00:00:00'两个时间点的ISO格式转换为修正儒略日期（MJD）格式，并以长整型数值返回结果。\n",
        "canonical_solution": "from astropy.time import Time\nimport numpy as np\ndef canonical_solution():\n    times = Time(['1999-01-01T00:00:00.123456789', '2010-01-01T00:00:00'], format='isot', scale='utc')\n    return times.to_value('mjd', 'long')\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 354,
        "prompt_en": "Calculate the total number of seconds between midnight on January 1, 2010, and midnight on February 1, 2010.",
        "prompt_zh": "计算自2010年1月1日午夜至2010年2月1日午夜之间的总秒数。\n",
        "canonical_solution": "from astropy.time import Time\ndef canonical_solution():\n    t1 = Time('2010-01-01 00:00:00')\n    t2 = Time('2010-02-01 00:00:00')\n    return (t2 - t1).sec\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查两个浮点数是否近似相等\n    return np.isclose(data1, data2, atol=1e-8)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 355,
        "prompt_en": "Convert the list of ISO time strings ['1999-01-01T00:00:00.123456789', '2010-01-01T00:00:00'] to the Julian Date representation in the UTC time scale.",
        "prompt_zh": "将列表中的ISO时间字符串['1999-01-01T00:00:00.123456789', '2010-01-01T00:00:00']，转换为UTC时区的儒略日表示形式。\n",
        "canonical_solution": "from astropy.time import Time\nimport numpy as np\ndef canonical_solution():\n    times = ['1999-01-01T00:00:00.123456789', '2010-01-01T00:00:00']\n    t = Time(times, format='isot', scale='utc')\n    return t.jd\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 356,
        "prompt_en": "Calculate the date 5 days after \"2020-01-01\" and return the ISO standard formatted string representation of that date.",
        "prompt_zh": "计算从\"2020-01-01\"开始后5天的日期，并返回该日期的ISO标准格式字符串表示。\n",
        "canonical_solution": "from astropy.time import Time\nimport astropy.units as u\ndef canonical_solution():\n    t = Time(\"2020-01-01\") + 5 * u.day\n    return t.iso\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 357,
        "prompt_en": "Create a continuous time series starting at Julian Date 2455197.5, spanning 10 days, with a total of 5 time points. Then, convert this time series into Modified Julian Date (MJD) format, and return the converted MJD time array.",
        "prompt_zh": "创建一个连续的时间序列，开始于儒略日2455197.5，持续10天，总共5个时间点。然后将这个时间序列转换为修正儒略日(MJD)格式，并返回转换后的MJD时间数组。\n",
        "canonical_solution": "from astropy.time import Time\nimport numpy as np\ndef canonical_solution():\n    t = Time(np.linspace(2455197.5, 2455197.5 + 10, 5), format='jd')\n    mjd_times = t.mjd\n    return mjd_times\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 358,
        "prompt_en": "Add 3 hours to the specified time '2010-01-01 00:00:00' and return the new time as a string in ISO format.",
        "prompt_zh": "添加3小时到指定的时间'2010-01-01 00:00:00'并返回新时间的ISO格式字符串表示。\n",
        "canonical_solution": "from astropy.time import Time, TimeDelta\nimport astropy.units as u\ndef canonical_solution():\n    t1 = Time('2010-01-01 00:00:00')\n    t2 = t1 + TimeDelta(3 * u.hour)\n    return t2.iso\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 359,
        "prompt_en": "Format the given time '2010-01-01 00:00:00' into a formatted string, displaying as 'Hour:Minute:Second Day Month(abbreviated) Year'. Return the formatted string.",
        "prompt_zh": "将给定的时间'2010-01-01 00:00:00'转换为格式化的字符串形式，显示为'小时:分钟:秒 日 月(三字母缩写) 年'。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.time import Time\n    \n    t = Time('2010-01-01 00:00:00')\n    t_strftime = t.strftime('%H:%M:%S %d %b %Y')\n    return t_strftime\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 360,
        "prompt_en": "Convert the string '23:59:60 30 June 2015' into an Astropy Time object using the format '%H:%M:%S %d %B %Y'.",
        "prompt_zh": "将字符串'23:59:60 30 June 2015'按照格式'%H:%M:%S %d %B %Y'转换为Astropy Time对象。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.time import Time\n    \n    t = Time.strptime('23:59:60 30 June 2015', '%H:%M:%S %d %B %Y')\n    return t\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 361,
        "prompt_en": "Create two time series: Time Series A starts at 2016-03-22 12:30:31 with flux data values recorded every 3 seconds as [1, 4, 5, 3, 2] mJy, and Time Series B starts at 2016-03-22 12:50:31 with flux data values recorded every 3 seconds as [4, 3, 1, 2, 3] mJy. Then, vertically stack the two time series into a new time series and return it.",
        "prompt_zh": "创建两个时间序列，时间序列A从2016年3月22日12:30:31开始，每隔3秒记录流量数据值为[1, 4, 5, 3, 2] mJy，时间序列B从2016年3月22日12:50:31开始，每隔3秒记录流量数据值为[4, 3, 1, 2, 3] mJy。然后将两个时间序列垂直堆叠成一个新的时间序列并返回。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.table import vstack\n    from astropy import units as u\n    from astropy.timeseries import TimeSeries\n    ts_a = TimeSeries(time_start='2016-03-22T12:30:31',\n                      time_delta=3 * u.s,\n                      data={'flux': [1, 4, 5, 3, 2] * u.mJy})\n    ts_b = TimeSeries(time_start='2016-03-22T12:50:31',\n                      time_delta=3 * u.s,\n                      data={'flux': [4, 3, 1, 2, 3] * u.mJy})\n    ts_ab = vstack([ts_a, ts_b])\n    return ts_ab\n\n\n",
        "test_code": [
            "def test_code(data1, data2):\n  # 比较两个\n  table_pred = data1.to_pandas()\n  table_ground = data2.to_pandas()\n  # 检查列名和顺序\n  table_pred_dict = table_pred.to_dict()\n  data_pred = {}\n  for column in  table_pred_dict.keys():\n    for row in table_pred_dict[column].keys():\n      if row not in data_pred.keys():\n        data_pred[row] = []\n      data_pred[row].append({column:table_pred_dict[column][row]})\n\n  table_ground_dict = table_ground.to_dict()\n  data_ground = {}\n  for column in  table_ground_dict.keys():\n    for row in table_ground_dict[column].keys():\n      if row not in data_ground.keys():\n        data_ground[row] = []\n      data_ground[row].append({column:table_ground_dict[column][row]})\n            \n  for data in data_ground:\n    if data not in data_pred:\n      return False\n\n  for data in data_pred:\n    if data not in data_ground:\n      return False\n  return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 362,
        "prompt_en": "Create a time series starting from March 22, 2016, 12:30:31, recording 'flux' values every 3 seconds as [1., 4., 5., 3., 2.]. Then, sort the time series in ascending order according to the 'flux' values and return the sorted time series object.",
        "prompt_zh": "创建一个从2016年3月22日12:30:31开始的时间序列，记录每3秒的'flux'值为[1., 4., 5., 3., 2.]。然后根据'flux'值对时间序列进行升序排序，并返回排序后的时间序列对象。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.timeseries import TimeSeries\n    from astropy import units as u\n    ts = TimeSeries(time_start='2016-03-22T12:30:31',\n                    time_delta=3 * u.s,\n                    data={'flux': [1., 4., 5., 3., 2.]})\n    ts.sort('flux')\n    return ts\n\n\n",
        "test_code": [
            "def test_code(data1, data2):\n  # 比较两个\n  table_pred = data1.to_pandas()\n  table_ground = data2.to_pandas()\n  # 检查列名和顺序\n  table_pred_dict = table_pred.to_dict()\n  data_pred = {}\n  for column in  table_pred_dict.keys():\n    for row in table_pred_dict[column].keys():\n      if row not in data_pred.keys():\n        data_pred[row] = []\n      data_pred[row].append({column:table_pred_dict[column][row]})\n\n  table_ground_dict = table_ground.to_dict()\n  data_ground = {}\n  for column in  table_ground_dict.keys():\n    for row in table_ground_dict[column].keys():\n      if row not in data_ground.keys():\n        data_ground[row] = []\n      data_ground[row].append({column:table_ground_dict[column][row]})\n            \n  for data in data_ground:\n    if data not in data_pred:\n      return False\n\n  for data in data_pred:\n    if data not in data_ground:\n      return False\n  return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 363,
        "prompt_en": "Create a time series with a start time of March 22, 2016, at 12:30:31 PM, where each time interval (time bin) is 3 seconds long. There are a total of 5 such time intervals. Return the center time point of each time interval in this time series.",
        "prompt_zh": "创建一个时间序列，设置起始时间为2016年3月22日12:30:31，每个时间段（时间槽）为3秒，并且总共包含5个这样的时间段。返回这个时间序列中每个时间段的中心时间点。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.timeseries import BinnedTimeSeries\n  from astropy import units as u\n\n  bts = BinnedTimeSeries(time_bin_start='2016-03-22T12:30:31',\n                         time_bin_size=3 * u.s, n_bins=5)\n  return bts.time_bin_center\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 364,
        "prompt_en": "Create a BinnedTimeSeries object starting at March 22, 2016, 12:30:31, with each time bin size set to 3 seconds and a total of 5 time bins. Return the start times of all time bins in this time series.",
        "prompt_zh": "创建一个开始于2016年3月22日12:30:31的BinnedTimeSeries对象，设置每个时间区间的大小为3秒，并且定义总共5个时间区间。返回这个时间序列中所有时间区间的起始时间。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n    from astropy.timeseries import BinnedTimeSeries\n    bts = BinnedTimeSeries(time_bin_start='2016-03-22T12:30:31',\n                        time_bin_size=3 * u.s, n_bins=5)\n    return bts.time_bin_start\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 365,
        "prompt_en": "Create a time series starting from March 22, 2016, at 12:30:31, with a recording interval of 3 seconds. This time series includes two sets of data: one named 'flux' for flux data and the other named 'temp' for temperature data. The unit for the flux data is Jansky (Jy), with values [1.0, 4.0, 5.0, 3.0, 2.0], and the unit for the temperature data is Kelvin (K), with values [40.0, 41.0, 39.0, 24.0, 20.0]. Return the first flux data point and the third temperature data point in the time series.",
        "prompt_zh": "创建一个从2016年3月22日12:30:31开始的时间序列，记录间隔为3秒。该时间序列包括两组数据，分别是名称为'flux'的流量数据和名称为'temp'的温度数据，流量数据的单位为Jansky (Jy)，值为[1.0, 4.0, 5.0, 3.0, 2.0]，温度数据的单位为Kelvin (K)，值为[40.0, 41.0, 39.0, 24.0, 20.0]。返回时间序列中的第一个流量数据点和第三个温度数据点。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy import units as u\n  from astropy.timeseries import TimeSeries\n  ts = TimeSeries(time_start='2016-03-22T12:30:31',\n                  time_delta=3 * u.s,\n                  data={'flux': [1., 4., 5., 3., 2.] * u.Jy,\n                        'temp': [40., 41., 39., 24., 20.] * u.K},\n                  names=('flux', 'temp'))\n  return ts[0]['flux'], ts['temp'][2]\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit",
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 366,
        "prompt_en": "Create a binned time series starting from March 22, 2016, at 12:30:31, with each time bin having a size of 3 seconds, and specify a total of 5 such time bins. Return the start time, center time, and end time for each time bin in the series.",
        "prompt_zh": "创建一个从2016年3月22日12:30:31开始的分箱时间序列，每个时间箱的大小为3秒，并指定共有5个这样的时间箱。返回序列中每个时间箱的起始时间、中心时间和结束时间。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.timeseries import BinnedTimeSeries\n  from astropy import units as u\n  bts = BinnedTimeSeries(time_bin_start='2016-03-22T12:30:31',\n                         time_bin_size=3 * u.s, n_bins=5)\n  return bts.time_bin_start, bts.time_bin_center, bts.time_bin_end\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n",
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n",
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 367,
        "prompt_en": "Create a time series object that starts from March 22, 2016, at 12:30:31, recording data at intervals of 3 seconds. The object includes two data columns named 'flux' and 'temp'. The 'flux' column contains measurements of [1.0, 4.0, 5.0, 3.0, 2.0] in Jy, and the 'temp' column contains measurements of [40.0, 41.0, 39.0, 24.0, 20.0] in K. Finally, return the first two data points of this time series object.",
        "prompt_zh": "创建一个时间序列对象，该对象从2016年3月22日12:30:31开始，以3秒为间隔记录数据，并包含两组数据列分别名为'flux'和'temp'，其中'flux'含有[1.0, 4.0, 5.0, 3.0, 2.0] Jy的测量值，而'temp'含有[40.0, 41.0, 39.0, 24.0, 20.0] K的测量值。最后返回这个时间序列对象的前两个数据点。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy import units as u\n  from astropy.timeseries import TimeSeries\n  ts = TimeSeries(time_start='2016-03-22T12:30:31',\n                  time_delta=3 * u.s,\n                  data={'flux': [1., 4., 5., 3., 2.] * u.Jy,\n                        'temp': [40., 41., 39., 24., 20.] * u.K},\n                  names=('flux', 'temp'))\n  return ts[0:2]\n\n\n",
        "test_code": [
            "def test_code(data1, data2):\n  # 比较两个\n  table_pred = data1.to_pandas()\n  table_ground = data2.to_pandas()\n  # 检查列名和顺序\n  table_pred_dict = table_pred.to_dict()\n  data_pred = {}\n  for column in  table_pred_dict.keys():\n    for row in table_pred_dict[column].keys():\n      if row not in data_pred.keys():\n        data_pred[row] = []\n      data_pred[row].append({column:table_pred_dict[column][row]})\n\n  table_ground_dict = table_ground.to_dict()\n  data_ground = {}\n  for column in  table_ground_dict.keys():\n    for row in table_ground_dict[column].keys():\n      if row not in data_ground.keys():\n        data_ground[row] = []\n      data_ground[row].append({column:table_ground_dict[column][row]})\n            \n  for data in data_ground:\n    if data not in data_pred:\n      return False\n\n  for data in data_pred:\n    if data not in data_ground:\n      return False\n  return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 368,
        "prompt_en": "Create a time series starting at 12:30:31 on March 22, 2016, recording data every 3 seconds, for a total of 5 records. The data includes flux values named 'flux' as [1., 4., 5., 3., 2.] with the unit Jansky (Jy), and temperature values named 'temp' as [40., 41., 39., 24., 20.] with the unit Kelvin (K). Return the flux data from this time series object.",
        "prompt_zh": "创建一个以2016年3月22日12点30分31秒开始的时间序列，每3秒记录一次数据，共记录5次。数据包括名为'flux'的流量值[1., 4., 5., 3., 2.]，单位为焦耳(Jansky, Jy)，和名为'temp'的温度值[40., 41., 39., 24., 20.]，单位为开尔文(K)。返回这个时间序列对象中流量值的数据。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n    from astropy.timeseries import TimeSeries\n    ts = TimeSeries(time_start='2016-03-22T12:30:31',\n        time_delta=3 * u.s,\n        data={'flux': [1., 4., 5., 3., 2.] * u.Jy,\n            'temp': [40., 41., 39., 24., 20.] * u.K},\n        names=('flux', 'temp'))\n    return ts['flux']\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 369,
        "prompt_en": "Create a time series object that starts on March 22, 2016, at 12:30:31, with each time interval being 3 seconds, and comprises a total of 5 such time intervals. Return the size of the time interval for this time series object.",
        "prompt_zh": "创建一个时间序列对象，该时间序列从2016年3月22日12:30:31开始，每个时间间隔为3秒，共包含5个此类时间间隔。返回这个时间序列对象的时间间隔大小。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.timeseries import BinnedTimeSeries\n    from astropy import units as u\n    bts = BinnedTimeSeries(time_bin_start='2016-03-22T12:30:31', time_bin_size=3 * u.s, n_bins=5)\n    return bts.time_bin_size\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 370,
        "prompt_en": "Load the Kepler time series file named 'timeseries/kplr010666592-2009131110544_slc.fits' and return it as an Astropy TimeSeries object.",
        "prompt_zh": "加载名为'timeseries/kplr010666592-2009131110544_slc.fits'的Kepler时间序列文件，并将其作为Astropy TimeSeries对象返回。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.utils.data import get_pkg_data_filename\n  from astropy.timeseries import TimeSeries\n  filename = get_pkg_data_filename('timeseries/kplr010666592-2009131110544_slc.fits')\n  ts = TimeSeries.read(filename, format='kepler.fits')\n  return ts\n\n\n",
        "test_code": [
            "def test_code(data1, data2):\n  # 比较两个\n  table_pred = data1.to_pandas()\n  table_ground = data2.to_pandas()\n  # 检查列名和顺序\n  table_pred_dict = table_pred.to_dict()\n  data_pred = {}\n  for column in  table_pred_dict.keys():\n    for row in table_pred_dict[column].keys():\n      if row not in data_pred.keys():\n        data_pred[row] = []\n      data_pred[row].append({column:table_pred_dict[column][row]})\n\n  table_ground_dict = table_ground.to_dict()\n  data_ground = {}\n  for column in  table_ground_dict.keys():\n    for row in table_ground_dict[column].keys():\n      if row not in data_ground.keys():\n        data_ground[row] = []\n      data_ground[row].append({column:table_ground_dict[column][row]})\n            \n  for data in data_ground:\n    if data not in data_pred:\n      return False\n\n  for data in data_pred:\n    if data not in data_ground:\n      return False\n  return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 371,
        "prompt_en": "Create a time series object with a start time of March 22, 2016, at 12:30:31. The time interval is every 3 seconds, and it contains 5 data points.",
        "prompt_zh": "创建一个时间序列对象，起始时间为2016年3月22日12:30:31，时间间隔为每3秒，包含5个数据点。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy import units as u\n  from astropy.timeseries import TimeSeries\n  ts1 = TimeSeries(time_start='2016-03-22T12:30:31',\n                   time_delta=3 * u.s,\n                   n_samples=5)\n  return ts1\n\n\n",
        "test_code": [
            "def test_code(data1, data2):\n  # 比较两个\n  table_pred = data1.to_pandas()\n  table_ground = data2.to_pandas()\n  # 检查列名和顺序\n  table_pred_dict = table_pred.to_dict()\n  data_pred = {}\n  for column in  table_pred_dict.keys():\n    for row in table_pred_dict[column].keys():\n      if row not in data_pred.keys():\n        data_pred[row] = []\n      data_pred[row].append({column:table_pred_dict[column][row]})\n\n  table_ground_dict = table_ground.to_dict()\n  data_ground = {}\n  for column in  table_ground_dict.keys():\n    for row in table_ground_dict[column].keys():\n      if row not in data_ground.keys():\n        data_ground[row] = []\n      data_ground[row].append({column:table_ground_dict[column][row]})\n            \n  for data in data_ground:\n    if data not in data_pred:\n      return False\n\n  for data in data_pred:\n    if data not in data_ground:\n      return False\n  return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 372,
        "prompt_en": "Create a TimeSeries object and set it to have three specific time points: '2016-03-22T12:30:31', '2016-03-22T12:30:38', and '2016-03-22T12:34:40'. Finally, return this TimeSeries object.",
        "prompt_zh": "创建一个TimeSeries对象，并设置它具有三个特定的时间点：'2016-03-22T12:30:31'，'2016-03-22T12:30:38'，和'2016-03-22T12:34:40'。最后返回这个TimeSeries对象。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.timeseries import TimeSeries\n  ts2 = TimeSeries(time=['2016-03-22T12:30:31',\n                         '2016-03-22T12:30:38',\n                         '2016-03-22T12:34:40'])\n  return ts2\n\n\n",
        "test_code": [
            "def test_code(data1, data2):\n  # 比较两个\n  table_pred = data1.to_pandas()\n  table_ground = data2.to_pandas()\n  # 检查列名和顺序\n  table_pred_dict = table_pred.to_dict()\n  data_pred = {}\n  for column in  table_pred_dict.keys():\n    for row in table_pred_dict[column].keys():\n      if row not in data_pred.keys():\n        data_pred[row] = []\n      data_pred[row].append({column:table_pred_dict[column][row]})\n\n  table_ground_dict = table_ground.to_dict()\n  data_ground = {}\n  for column in  table_ground_dict.keys():\n    for row in table_ground_dict[column].keys():\n      if row not in data_ground.keys():\n        data_ground[row] = []\n      data_ground[row].append({column:table_ground_dict[column][row]})\n            \n  for data in data_ground:\n    if data not in data_pred:\n      return False\n\n  for data in data_pred:\n    if data not in data_ground:\n      return False\n  return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 373,
        "prompt_en": "Create a time series starting from March 22, 2016, 12:30:31, with each time bin having a size of 3 seconds, and a total of 10 such bins. Return this time series object.",
        "prompt_zh": "创建一个从2016年3月22日12:30:31开始的时间序列，每个时间bin的大小为3秒，共有10个这样的bins，并返回这个时间序列对象。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy import units as u\n  from astropy.timeseries import BinnedTimeSeries\n  ts3 = BinnedTimeSeries(time_bin_start='2016-03-22T12:30:31',\n                         time_bin_size=3 * u.s, n_bins=10)\n  return ts3\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if str(type(data1[colname]))==\"<class 'astropy.units.quantity.Quantity'>\":\n            if not np.allclose(data1[colname].value, data2[colname].value,equal_nan=True, atol=1e-8) or not data1[colname].unit == data2[colname].unit:\n                return False\n        else:\n            if not np.all(data1[colname] == data2[colname]):\n                return False\n\n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 374,
        "prompt_en": "Create a BinnedTimeSeries object with a start time of '2016-03-22T12:30:31', and time bin sizes of 3 seconds, 3 seconds, 2 seconds, and 3 seconds, respectively.",
        "prompt_zh": "创建一个BinnedTimeSeries对象，开始时间为'2016-03-22T12:30:31'，且时间分箱的大小依次为3秒、3秒、2秒、3秒。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy import units as u\n  from astropy.timeseries import BinnedTimeSeries\n  ts4 = BinnedTimeSeries(time_bin_start='2016-03-22T12:30:31',\n                         time_bin_size=[3, 3, 2, 3] * u.s)\n  return ts4\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if str(type(data1[colname]))==\"<class 'astropy.units.quantity.Quantity'>\":\n            if not np.allclose(data1[colname].value, data2[colname].value,equal_nan=True, atol=1e-8) or not data1[colname].unit == data2[colname].unit:\n                return False\n        else:\n            if not np.all(data1[colname] == data2[colname]):\n                return False\n\n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 375,
        "prompt_en": "Create a binned time series with start time points as ['2016-03-22T12:30:31', '2016-03-22T12:30:34', '2016-03-22T12:30:37', '2016-03-22T12:30:39'], and a uniform end time point for all time segments as '2016-03-22T12:30:42'.",
        "prompt_zh": "创建一个分箱的时间序列，起始时间点为['2016-03-22T12:30:31', '2016-03-22T12:30:34', '2016-03-22T12:30:37', '2016-03-22T12:30:39']，所有时间段的结束时间点统一为'2016-03-22T12:30:42'。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.timeseries import BinnedTimeSeries\n  ts5 = BinnedTimeSeries(time_bin_start=['2016-03-22T12:30:31',\n                                         '2016-03-22T12:30:34',\n                                         '2016-03-22T12:30:37',\n                                         '2016-03-22T12:30:39'],\n                         time_bin_end='2016-03-22T12:30:42')\n  return ts5\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if str(type(data1[colname]))==\"<class 'astropy.units.quantity.Quantity'>\":\n            if not np.allclose(data1[colname].value, data2[colname].value,equal_nan=True, atol=1e-8) or not data1[colname].unit == data2[colname].unit:\n                return False\n        else:\n            if not np.all(data1[colname] == data2[colname]):\n                return False\n\n    return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 376,
        "prompt_en": "Use Astropy to perform a Lomb-Scargle period analysis. Generate a time array with a length of 100 days, with luminosity measurements for each day being randomly normally distributed values. Calculate the power spectral density (PSD) of its Fourier transform. Return the frequency and power spectral density arrays obtained from the analysis.",
        "prompt_zh": "使用Astropy进行Lomb-Scargle周期分析，生成一个长度为100天的时间数组，对应于每一天的光度测量值是随机的正态分布值，并计算其傅里叶变换的功率谱密度(psd)。返回分析得到的频率和功率谱密度数组。\n",
        "canonical_solution": "def canonical_solution():\n    import numpy as np\n    from astropy.timeseries import LombScargle\n    import astropy.units as u\n    t = np.arange(100) * u.day\n    y_mags = np.random.standard_normal(100) * u.mag\n    frequency, PSD_fourier = LombScargle(t, y_mags, normalization='psd').autopower()\n    return frequency, PSD_fourier\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit",
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 377,
        "prompt_en": "Create a time series with timestamps starting from March 22, 2016, at 12:30:31, with a time interval of 3 seconds, consisting of a total of 5 time points. In this time series, add a data column named 'flux' with values [1., -2., 5., -1., 4.], and apply a mask to all negative values in the column. Finally, return the complete time series object.",
        "prompt_zh": "创建一个带有时间戳的时间序列，其开始时间为2016年3月22日12:30:31，时间点间隔为3秒钟，总共有5个时间点。在这个时间序列中添加了一个名为'flux'的数据列，值依次为[1., -2., 5., -1., 4.]，并将列中所有负值进行掩码处理。最后返回完整的时间序列对象。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n    from astropy.timeseries import TimeSeries\n    ts = TimeSeries(time_start='2016-03-22T12:30:31', time_delta=3 * u.s, n_samples=5, masked=True)\n    ts['flux'] = [1., -2., 5., -1., 4.]\n    ts['flux'].mask = ts['flux'] < 0\n    return ts\n\n\n",
        "test_code": [
            "def test_code(data1, data2):\n  # 比较两个\n  table_pred = data1.to_pandas()\n  table_ground = data2.to_pandas()\n  # 检查列名和顺序\n  table_pred_dict = table_pred.to_dict()\n  data_pred = {}\n  for column in  table_pred_dict.keys():\n    for row in table_pred_dict[column].keys():\n      if row not in data_pred.keys():\n        data_pred[row] = []\n      data_pred[row].append({column:table_pred_dict[column][row]})\n\n  table_ground_dict = table_ground.to_dict()\n  data_ground = {}\n  for column in  table_ground_dict.keys():\n    for row in table_ground_dict[column].keys():\n      if row not in data_ground.keys():\n        data_ground[row] = []\n      data_ground[row].append({column:table_ground_dict[column][row]})\n            \n  for data in data_ground:\n    if data not in data_pred:\n      return False\n\n  for data in data_pred:\n    if data not in data_ground:\n      return False\n  return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 378,
        "prompt_en": "Create a time series starting at '2016-03-22T12:30:31' with a time interval of 3 seconds, and set the 'flux' data column in the time series to the values [1.0, 3.0, 4.0, 2.0, 4.0]. Then, output the time points in this time series converted to Modified Julian Date (MJD) format.",
        "prompt_zh": "创建一个以'2016-03-22T12:30:31'为起始时间、以3秒为间隔的时间序列，并将时间序列中的'flux'数据列设置为[1.0, 3.0, 4.0, 2.0, 4.0]的值。然后输出这个时间序列中的时间点，转换为修正儒略日（MJD）格式。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n    from astropy.timeseries import TimeSeries\n    ts = TimeSeries(time_start='2016-03-22T12:30:31', time_delta=3 * u.s, data={'flux': [1., 3., 4., 2., 4.]})\n    return ts.time.mjd\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 379,
        "prompt_en": "Create a time series starting from 2016-03-22T12:30:31, recording a data point every 3 seconds. The data and the sequence are represented by the 'flux' key, containing the values [1., 3., 4., 2., 4.]. Return the time points in the time series in International Atomic Time (TAI) format.",
        "prompt_zh": "创建一个从2016年3月22日12:30:31开始的时间序列，每隔3秒记录一个数据点，包含的数据和序列用'flux'键表示，并包含值[1., 3., 4., 2., 4.]。返回该时间序列中时间点的国际原子时（TAI）格式。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n    from astropy.timeseries import TimeSeries\n    ts = TimeSeries(time_start='2016-03-22T12:30:31', time_delta=3 * u.s, data={'flux': [1., 3., 4., 2., 4.]})\n    return ts.time.tai\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 380,
        "prompt_en": "Create a time series starting from 2016-03-22T12:30:31, recording a data point every 3 seconds, and include a 'flux' data column with values [1.0, 3.0, 4.0, 2.0, 4.0]. Set the time display format to ISO standard time format, and return this time series object.",
        "prompt_zh": "创建一个时间序列从2016年3月22日12:30:31开始，每隔3秒记录一个数据点，并包含'flux'数据列，其值为[1.0, 3.0, 4.0, 2.0, 4.0]。设置时间显示格式为ISO标准时间格式，并返回这个时间序列对象。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n    from astropy.timeseries import TimeSeries\n    ts = TimeSeries(time_start='2016-03-22T12:30:31', time_delta=3 * u.s, data={'flux': [1., 3., 4., 2., 4.]})\n    ts.time.format = 'isot'\n    return ts\n\n\n",
        "test_code": [
            "def test_code(data1, data2):\n  # 比较两个\n  table_pred = data1.to_pandas()\n  table_ground = data2.to_pandas()\n  # 检查列名和顺序\n  table_pred_dict = table_pred.to_dict()\n  data_pred = {}\n  for column in  table_pred_dict.keys():\n    for row in table_pred_dict[column].keys():\n      if row not in data_pred.keys():\n        data_pred[row] = []\n      data_pred[row].append({column:table_pred_dict[column][row]})\n\n  table_ground_dict = table_ground.to_dict()\n  data_ground = {}\n  for column in  table_ground_dict.keys():\n    for row in table_ground_dict[column].keys():\n      if row not in data_ground.keys():\n        data_ground[row] = []\n      data_ground[row].append({column:table_ground_dict[column][row]})\n            \n  for data in data_ground:\n    if data not in data_pred:\n      return False\n\n  for data in data_pred:\n    if data not in data_ground:\n      return False\n  return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 381,
        "prompt_en": "Create a time series with a start time of '2016-03-22T12:30:31' and a time interval of 3 seconds, including a column of data named 'flux' with values [1., 3., 4., 2., 4.]. Set the time format of the time series to Unix timestamp format and return the time series object.",
        "prompt_zh": "创建一个时间序列，其起始时间为'2016-03-22T12:30:31'，时间间隔为3秒，并包含一列名为'flux'的数据，其值为[1., 3., 4., 2., 4.]。将时间序列的时间格式设置为Unix时间戳格式，并返回这个时间序列对象。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n    from astropy.timeseries import TimeSeries\n    ts = TimeSeries(time_start='2016-03-22T12:30:31', time_delta=3 * u.s, data={'flux': [1., 3., 4., 2., 4.]})\n    ts.time.format = 'unix'\n    return ts\n\n\n",
        "test_code": [
            "def test_code(data1, data2):\n  # 比较两个\n  table_pred = data1.to_pandas()\n  table_ground = data2.to_pandas()\n  # 检查列名和顺序\n  table_pred_dict = table_pred.to_dict()\n  data_pred = {}\n  for column in  table_pred_dict.keys():\n    for row in table_pred_dict[column].keys():\n      if row not in data_pred.keys():\n        data_pred[row] = []\n      data_pred[row].append({column:table_pred_dict[column][row]})\n\n  table_ground_dict = table_ground.to_dict()\n  data_ground = {}\n  for column in  table_ground_dict.keys():\n    for row in table_ground_dict[column].keys():\n      if row not in data_ground.keys():\n        data_ground[row] = []\n      data_ground[row].append({column:table_ground_dict[column][row]})\n            \n  for data in data_ground:\n    if data not in data_pred:\n      return False\n\n  for data in data_pred:\n    if data not in data_ground:\n      return False\n  return True"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 382,
        "prompt_en": "Calculate and return the mean and standard deviation of an uncertainty distribution object generated using a Poisson distribution. The data points are obtained through random sampling, with the distribution's event rate being [1, 5, 30, 400] counts. The sample size is 1000, and each sample contains 4 events.",
        "prompt_zh": "计算并返回使用泊松分布生成的不确定性分布对象的平均值和标准偏差，数据点是随机抽样得到的，分布的事件发生率为[1, 5, 30, 400]次计数，样本大小为1000，每个样本包含4个事件。\n",
        "canonical_solution": "def canonical_solution():\n    import numpy as np\n    from astropy import units as u\n    from astropy import uncertainty as unc\n    rng = np.random.default_rng(123456)  # ensures \"random\" numbers match examples below\n    dq = rng.poisson([1, 5, 30, 400], (1000, 4)).T * u.ct  # note the transpose, required to get the sampling on the *last* axis\n    distr = unc.Distribution(dq)\n    return distr.pdf_mean(), distr.pdf_std()\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit",
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 383,
        "prompt_en": "Calculate the sum of two sets of normally distributed random numbers, each containing 10,000 samples. The first set has a mean of 1 kiloparsec and a standard deviation of 30 parsecs, while the second set has a mean of 2 kiloparsecs and a standard deviation of 40 parsecs. Return the mean of this sum and its standard deviation in parsecs.",
        "prompt_zh": "计算两组各10000个样本的正态分布随机数的和，其中第一组的均值为1千帕赛克，标准差为30秒差距，第二组的均值为2千帕赛克，标准差为40秒差距，并返回这个和的平均值及其以秒差距为单位的标准差。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n    from astropy import uncertainty as unc\n    a = unc.normal(1*u.kpc, std=30*u.pc, n_samples=10000)\n    b = unc.normal(2*u.kpc, std=40*u.pc, n_samples=10000)\n    c = a + b\n    mean_c = c.pdf_mean()\n    std_c = c.pdf_std().to(u.pc)\n    return mean_c, std_c\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit",
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 384,
        "prompt_en": "Create a uniform distribution with four center values (1, 5, 30, 400) kpc, each with widths of 10, 20, 10, 55 parsecs, and generate 1000 samples. Calculate the mean and standard deviation of this uniform distribution, and then return these two results.",
        "prompt_zh": "创建包含四个中心值（1, 5, 30, 400）kpc的均匀分布，分布各自有10, 20, 10, 55 parsec的宽度，并生成1000个样本。计算这个均匀分布的平均值和标准偏差，然后返回这两个结果。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n    from astropy import uncertainty as unc\n    center = [1, 5, 30, 400]\n    uwidth = [10, 20, 10, 55]*u.pc\n    distr = unc.uniform(center=center*u.kpc, width=uwidth, n_samples=1000)\n    distr_mean = distr.pdf_mean()\n    distr_std = distr.pdf_std()\n    return distr_mean, distr_std\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit",
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 385,
        "prompt_en": "Create two independent normal distribution uncertainty variables. The first variable has a mean of 1 kiloparsec and a standard deviation of 30 parsecs, and the second variable has a mean of 2 kiloparsecs and a standard deviation of 40 parsecs. Each variable contains 10,000 samples. Then, add these two uncertainty variables together and return the mean and standard deviation of the probability density function of the new variable (expressed in parsecs).",
        "prompt_zh": "创建两个独立的正态分布不确定性变量，第一个变量的均值为1千秒差距，标准偏差为30秒差距，第二个变量的均值为2千秒差距，标准偏差为40秒差距，每个变量的样本数为10000。然后，将这两个不确定性变量相加，并返回新变量的概率密度函数的均值和标准偏差（以秒差距为单位）。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy import units as u\n  from astropy import uncertainty as unc\n  a = unc.normal(1*u.kpc, std=30*u.pc, n_samples=10000)\n  b = unc.normal(2*u.kpc, std=40*u.pc, n_samples=10000)\n  c = a + b\n  return c.pdf_mean(), c.pdf_std().to(u.pc)\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit",
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 386,
        "prompt_en": "Using the astropy library, create four sets of Poisson distributions consisting of 1000 sample values each. The expected values of each set are 1, 5, 30, and 400 counts (ct), respectively. Then, calculate and return the mean, standard deviation, variance, and median for these four sets of Poisson distributions.",
        "prompt_zh": "使用astropy库创建一个由1000个样本值组成的4组泊松分布，每组泊松分布的期望值分别为1，5，30和400计数（ct）。然后计算这四组泊松分布所对应的平均值、标准差、方差和中位数。\n",
        "canonical_solution": "def canonical_solution():\n  import numpy as np\n  from astropy import units as u\n  from astropy import uncertainty as unc\n  rng = np.random.default_rng(123456)\n  pq = rng.poisson([1, 5, 30, 400], (1000, 4)).T * u.ct\n  distr = unc.Distribution(pq)\n  return distr.pdf_mean(), distr.pdf_std(), distr.pdf_var(), distr.pdf_median()\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit",
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit",
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit",
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 387,
        "prompt_en": "Create an Astropy unit object representing the cube root of meters (m) and return the list of exponents of this object.",
        "prompt_zh": "创建一个代表米（m）立方根单位的Astropy单位对象，并返回该对象的指数列表。\n",
        "canonical_solution": "def canonical_solution():\n    from fractions import Fraction\n    from astropy import units as u\n    x = u.m ** Fraction(1, 3)\n    return x.powers\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 比较列表长度和元素内容\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 388,
        "prompt_en": "Create a physical quantity represented in units of erg per square centimeter per second with a value of 52.0.",
        "prompt_zh": "创建一个物理量表示单位为每平方厘米每秒的埃尔格，并且其值为52.0。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n    fluxunit = u.erg / (u.cm ** 2 * u.s)\n    flux = 52.0 * fluxunit\n    return flux\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 389,
        "prompt_en": "Create a new physical quantity unit named Franklin, defined as the square root of grams multiplied by the three-halves power of centimeters, and divided by seconds.",
        "prompt_zh": "创建一个新的物理量单位，命名为 Franklin，其定义为克的1/2次方乘以厘米的3/2次方，再除以秒。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n    from fractions import Fraction\n    Franklin = u.g ** Fraction(1, 2) * u.cm ** Fraction(3, 2) * u.s ** -1\n    return Franklin\n\n\n",
        "test_code": [
            "\ndef test_code(unit1, unit2):\n    # 直接比较两个单位对象是否相等\n    return unit1 == unit2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 390,
        "prompt_en": "Create a unit representing 13 days and name it 'bakers_fortnight'. Then, create a quantity representing 10 'bakers_fortnight' and return this quantity.",
        "prompt_zh": "创建一个单位表示13天，并命名为'bakers_fortnight'。然后，创建一个表示10个'bakers_fortnight'的量，并返回这个量。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n    bakers_fortnight = u.def_unit('bakers_fortnight', 13 * u.day)\n    quantity_bakers_fortnight = 10. * bakers_fortnight\n    return quantity_bakers_fortnight\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 391,
        "prompt_en": "Define a new unit named 'kmph', which is equivalent to kilometers per hour, and add this new unit to the list of recognized units. Then, identify all equivalent units of meters per second and return these units.",
        "prompt_zh": "定义一个名为'kmph'的新单位，将其等同于千米每小时，并将此新单位添加到可识别的单位列表中。然后，找出米每秒的所有等效单位，并将这些单位返回。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n    kmph = u.def_unit('kmph', u.km / u.h)\n    u.add_enabled_units([kmph])\n    equivalent_units = (u.m / u.s).find_equivalent_units()\n    return equivalent_units\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 392,
        "prompt_en": "Attempt to convert the speed unit from centimeters per second to kilometers, and handle any errors that occur due to incompatible units.",
        "prompt_zh": "尝试将速度单位从厘米每秒转换为千米，并处理任何由于不兼容单位而发生的错误。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n    try:\n        # Attempt to convert from 'cm / s' to 'km'\n        cms = u.cm / u.s\n        result = cms.to(u.km)\n    except u.UnitsError as e:\n        # Handle the error if units are not compatible\n        result = str(e)\n    return result\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 393,
        "prompt_en": "Convert 3.26 parsecs (pc) to meters (m).",
        "prompt_zh": "将3.26秒差距(pc)转换为米(m)。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n    return u.pc.to(u.m, 3.26)\n\n\n",
        "test_code": [
            "\nimport math\n\ndef test_code(data1, data2):\n    # 设置绝对误差容许值\n    abs_tol = 1e-8\n    # 使用math.isclose来比较两个浮点数是否在误差范围内相等\n    return math.isclose(data1, data2, abs_tol=abs_tol)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 394,
        "prompt_en": "Convert the list of time [1, 2, 5, 10.1] hours into the corresponding seconds.",
        "prompt_zh": "将时间列表[1, 2, 5, 10.1]小时转换为对应的秒数。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n    return u.h.to(u.s, [1, 2, 5, 10.1])\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 395,
        "prompt_en": "Get the centimeter-gram-second (cgs) unit representation corresponding to the pressure unit Pascal (Pa).",
        "prompt_zh": "获取压强单位帕斯卡（Pa）对应的厘米-克-秒（cgs）制单位表示。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n    unit_cgs = u.Pa.cgs\n    return unit_cgs\n\n\n",
        "test_code": [
            "\ndef test_code(unit1, unit2):\n    # 直接比较两个单位对象是否相等\n    return unit1 == unit2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 396,
        "prompt_en": "Retrieve all equivalent unit combinations for the reciprocal of seconds.",
        "prompt_zh": "获取每秒倒数单位的所有等效单位组合。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n    inverse_second_composition = (u.s ** -1).compose()\n    return inverse_second_composition\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 比较列表长度和元素内容\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 397,
        "prompt_en": "Use the units module from Astropy to process and return all possible underlying representations of composite units composed of candela (cd), steradian (sr), volt (V), and second (s).",
        "prompt_zh": "通过Astropy的单位模块处理并返回由烛光(cd)，球面度(sr)，伏特(V)和秒(s)组成的复合单位的所有可能的基础单位表示。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n    complex_units = (u.cd * u.sr * u.V * u.s).compose()\n    return complex_units\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 比较列表长度和元素内容\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 398,
        "prompt_en": "Decompose the Rydberg unit into its base units and return a list where each item is a representation of a base unit raised to its respective power. For example, if the decomposed base units are meter and second, the list should look like this: [meter^power, second^power].",
        "prompt_zh": "分解里德伯单位为其基本单位并返回一个列表，列表中的每一项是一个基本单位的幂次表示。例如，如果分解后的基本单位是米和秒，列表应该像这样：[米^幂次, 秒^幂次]。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy import units as u\n  Ry = u.Ry.decompose()\n  return [unit**power for unit, power in zip(Ry.bases, Ry.powers)]\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 比较列表长度和元素内容\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 399,
        "prompt_en": "Decompose the energy unit Rydberg (Ry) into a combination of the base units meter (m) and Newton (N) and return the decomposed result.",
        "prompt_zh": "将能量的单位里德伯(Ry)分解为基础单位米(m)和牛顿(N)的组合，并返回分解后的结果。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy import units as u\n  return u.Ry.decompose(bases=[u.m, u.N])\n\n\n",
        "test_code": [
            "\ndef test_code(unit1, unit2):\n    # 直接比较两个单位对象是否相等\n    return unit1 == unit2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 400,
        "prompt_en": "Decompose the Rydberg unit into base units, and then return the list of possible unit combinations.",
        "prompt_zh": "解构Rydberg单位为基础单位，然后返回可能的单位组合列表。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy import units as u\n  x = u.Ry.decompose()\n  return x.compose()\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 比较列表长度和元素内容\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 401,
        "prompt_en": "Convert the photon flux of 1.5 Jansky into the number of photons per square centimeter per second per hertz, with a reference wavelength of 3500 Angstroms. Return the result.",
        "prompt_zh": "将1.5贾斯基（Jansky）单位的光通量转换为每平方厘米每秒每赫兹的光子数，参考波长为3500埃。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n    quantity_photon_flux = (1.5 * u.Jy).to(u.photon / u.cm**2 / u.s / u.Hz, equivalencies=u.spectral_density(3500 * u.AA))\n    return quantity_photon_flux\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 402,
        "prompt_en": "Translate the astronomical angle of 0.8 arcseconds into the corresponding distance in parsecs.",
        "prompt_zh": "将天文角度0.8角秒转换为对应的秒差距单位距离。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n    angle = 0.8 * u.arcsec\n    return angle.to(u.parsec, equivalencies=u.parallax())\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 403,
        "prompt_en": "Convert the angle unit to a dimensionless pure numerical value.",
        "prompt_zh": "将角度单位转换为无单位的纯数值。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n    angle = u.degree.to('', equivalencies=u.dimensionless_angles())\n    return angle\n\n\n",
        "test_code": [
            "\nimport math\n\ndef test_code(data1, data2):\n    # 设置绝对误差容许值\n    abs_tol = 1e-8\n    # 使用math.isclose来比较两个浮点数是否在误差范围内相等\n    return math.isclose(data1, data2, abs_tol=abs_tol)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 404,
        "prompt_en": "Calculate the Doppler velocity of a signal with a frequency of 116 GHz relative to the rest frequency of the CO gas transition (115.27120 GHz), and convert the result to kilometers per second.",
        "prompt_zh": "计算频率为116 GHz的信号相对于CO气体跃迁静止频率（115.27120 GHz）的多普勒速度，并将结果转换为公里每秒的单位。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n    from astropy.constants import si\n    restfreq = 115.27120 * u.GHz  # rest frequency of 12 CO 1-0 in GHz\n    freq_to_vel = u.doppler_radio(restfreq)\n    velocity = (116e9 * u.Hz).to(u.km / u.s, equivalencies=freq_to_vel)\n    return velocity\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 405,
        "prompt_en": "Convert the volume unit of one gallon to the weight unit of pounds using a custom equivalency where 1 liter is equivalent to 1000 grams.",
        "prompt_zh": "将一加仑的体积单位转换成磅的重量单位，使用自定义的等效性，其中1升等同于1000克。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n    from astropy.units import imperial\n    gallon_to_pound = imperial.gallon.to(imperial.pound, 1, equivalencies=[\n        (u.l, u.g, lambda x: 1000.0 * x, lambda x: x / 1000.0)\n    ])\n    return gallon_to_pound\n\n\n",
        "test_code": [
            "\nimport math\n\ndef test_code(data1, data2):\n    # 设置绝对误差容许值\n    abs_tol = 1e-8\n    # 使用math.isclose来比较两个浮点数是否在误差范围内相等\n    return math.isclose(data1, data2, abs_tol=abs_tol)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 406,
        "prompt_en": "Create a unit \"Angstroem\" represented in \"FITS\" format. Issue a warning when encountering an unrecognized unit, then convert this unit to a string form.",
        "prompt_zh": "创建一个以\"FITS\"格式表示的单位\"Angstroem\"，并在遇到无法识别的单位时发出警告，然后将这个单位转换为字符串形式。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n    unrecognized_unit = u.Unit(\"Angstroem\", format=\"fits\", parse_strict=\"warn\")\n    return unrecognized_unit.to_string()\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 407,
        "prompt_en": "Create a `Quantity` object representing a speed with a value of 3 meters per second.",
        "prompt_zh": "创建一个表示速度，其值为3米每秒的Quantity对象。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy import units as u\n  q = u.Quantity(\"3m/s\")\n  return q\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 408,
        "prompt_en": "Create a physical quantity object representing 10.5 kilometers and format this object into a string with unit representation.",
        "prompt_zh": "创建一个代表10.5公里的物理量对象，并将这个对象格式化为一个带单位表示的字符串。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy import units as u\n  q = 10.5 * u.km\n  formatted_string = f\"{q}\"\n  return formatted_string\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 409,
        "prompt_en": "Translate the astronomical quantity 1.2478e12 pc/Myr into a LaTeX formatted string with four decimal places of precision. Return the formatted string.",
        "prompt_zh": "将天文单位量1.2478e12 pc/Myr转换成一个LaTeX格式的字符串，并保留四位小数精度。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy import units as u\n  q = 1.2478e12 * u.pc/u.Myr\n  formatted_string = q.to_string(format=\"latex\", precision=4)\n  return formatted_string\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 410,
        "prompt_en": "Create an array containing 10 elements with values increasing from 0 to 1 (including 0 and 1), with each value representing the length unit meters. Format the values of the array into strings as one decimal place with the unit 'm' appended and return the formatted strings.",
        "prompt_zh": "创建一个包含10个元素的数组，其中的数值从0增加到1（包括0和1），每个数值表示成长度单位米，将该数组的数值以一位小数的格式和单位m一起格式化为字符串后返回。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy import units as u\n  import numpy as np\n  q = np.linspace(0, 1, 10) * u.m\n  formatted_string = f\"{np.array_str(q.value, precision=1)} {q.unit}\"\n  return formatted_string\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 411,
        "prompt_en": "Create a physical quantity object with a value of 42.0 and a unit of meters.",
        "prompt_zh": "创建一个数值为42.0，单位为米的物理量对象。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n    q = 42.0 * u.meter\n    return q\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 412,
        "prompt_en": "Create an array consisting of the numbers 1.0, 2.0, 3.0, and annotate the units of these values as meters.",
        "prompt_zh": "创建一个由数值1.0, 2.0, 3.0组成的数组，并标明这些数值的单位是米。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n    q = [1., 2., 3.] * u.m\n    return q\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 413,
        "prompt_en": "Create a unit object with a numerical value of 1.0 that is dimensionless and scale-less.",
        "prompt_zh": "创建一个数值为1.0并且是无量纲无标度的单位对象。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n    q = 1.0 * u.dimensionless_unscaled\n    return q\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 414,
        "prompt_en": "Calculate the gravitational acceleration on the surface of the Sun, convert its value to logarithmic units (base 10), and express the result in units of centimeters per second squared.",
        "prompt_zh": "计算太阳表面的重力加速度并将其值转换为对数单位制（以10为底），结果使用厘米/秒平方单位表示。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n    from astropy.constants import G, M_sun, R_sun\n    return u.Dex((G * M_sun / R_sun**2).cgs)\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 415,
        "prompt_en": "Create a physical quantity with a value of 42.0 and a unit of meters, and return both the value and unit of this quantity.",
        "prompt_zh": "创建一个物理量，数值为42.0，单位为米，并返回这个量的数值和单位。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy import units as u\n  q = 42.0 * u.meter\n  return q.value, q.unit\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查两个浮点数是否近似相等\n    return np.isclose(data1, data2, atol=1e-8)\n\n",
            "\ndef test_code(data1, data2):\n    # 检查值是否相等\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 416,
        "prompt_en": "Convert the speed of 15.1 meters per 32 seconds into its fundamental unit representation.",
        "prompt_zh": "将速度15.1米除以32秒，并且分解为基本单位表示。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy import units as u\n  speed = 15.1 * u.meter / (32.0 * u.second)\n  return speed.decompose()\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 417,
        "prompt_en": "Create a dimensionless numerical value with a value of 1.0, and return its unit representation.",
        "prompt_zh": "创建一个数值为1.0的无量纲数值，并返回其单位表示。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy import units as u\n  q = 1.0 * u.dimensionless_unscaled\n  return q.unit\n\n\n",
        "test_code": [
            "\ndef test_code(unit1, unit2):\n    # 直接比较两个单位对象是否相等\n    return unit1 == unit2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 418,
        "prompt_en": " Calculate the velocity with a distance of 15.1 meters and a time of 32.0 seconds, and format the computed result as a floating-point number precise to three decimal places.",
        "prompt_zh": "计算速度，其中距离为15.1米，时间为32.0秒，并将计算结果格式化为精确到小数点后三位的浮点数。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy import units as u\n  q = 15.1 * u.meter / (32.0 * u.second)\n  return f\"{q:0.03f}\"\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 419,
        "prompt_en": "Convert the speed from 15.1 meters per second to kilometers per hour.",
        "prompt_zh": "将速度从15.1米/秒转换为公里/小时。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy import units as u\n  q = 15.1 * u.meter / (32.0 * u.second)\n  return q.to(u.km / u.hour)\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 420,
        "prompt_en": "Convert the speed of 42.0 cm/s to miles per hour and return the result.",
        "prompt_zh": "将速度42.0厘米/秒转换为英里/小时并返回结果。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy import units as u\n  from astropy.units import imperial\n  q = 42.0 * u.cm / u.s\n  mph = imperial.mile / u.hour\n  return q.to(mph)\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 421,
        "prompt_en": "Convert distance from 1 arcsecond to kilometers.",
        "prompt_zh": "将距离从1秒差距转换为公里。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy import units as u\n  q = 1.0 * u.parsec\n  return q.to(u.km)\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 422,
        "prompt_en": "Convert the light wavelength of 1000 nanometers to its corresponding frequency in hertz (Hz).",
        "prompt_zh": "将1000纳米的光波长转换为相应的频率表示，单位为赫兹（Hz）。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy import units as u\n  q = (1000 * u.nm).to(u.Hz, equivalencies=u.spectral())\n  return q\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 423,
        "prompt_en": "Create a physical quantity object with a value of 42.0 and a unit of meters. Then extract and return the unit and value of the physical quantity object.",
        "prompt_zh": "创建一个值是42.0的物理量对象，单位为米。然后提取并返回这个物理量对象的单位和数值。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n  \n    # 创建一个Quantity对象\n    quantity = 42.0 * u.meter\n  \n    # 返回提取的单位和数值\n    unit = quantity.unit\n    value = quantity.value\n  \n    return unit, value\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 检查值是否相等\n    return data1 == data2\n\n",
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查两个浮点数是否近似相等\n    return np.isclose(data1, data2, atol=1e-8)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 424,
        "prompt_en": "Convert the distance of 1.0 parsec to kilometers and return the numerical part of the converted value.",
        "prompt_zh": "将距离1.0 parsec转换为千米，返回转换后的数值部分。",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n\n    # 创建一个parsec单位的Quantity对象\n    distance = 1.0 * u.parsec\n\n    # 将单位转换为千米\n    distance_km = distance.to(u.km)\n\n    # 返回转换后的距离值\n    return distance_km.value\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查两个浮点数是否近似相等\n    return np.isclose(data1, data2, atol=1e-8)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 425,
        "prompt_en": "Convert the surface gravity given in logarithmic form of 5 cm/s² to non-logarithmic units in m/s².",
        "prompt_zh": "将以对数形式给出的表面重力5 cm/s²转换成非对数的单位米/秒²。\n",
        "canonical_solution": "def canonical_solution():\n    import astropy.units as u\n    logg = u.Dex(5. * u.cm / u.s**2)\n    return logg.to(u.m / u.s**2)\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 426,
        "prompt_en": "Calculate the photometric brightness values of celestial objects under the influence of atmospheric extinction, given the count rates as [3000., 100., 15.] counts per 1000 seconds, the atmospheric extinction as 0.12 magnitudes, and assuming an observation zenith distance of 45 degrees.",
        "prompt_zh": "计算在大气消光影响下的天体测量亮度值，给定计数率为[3000., 100., 15.] counts/1000秒，大气消光为0.12星等，并假设观测时的天顶距为45度。\n",
        "canonical_solution": "def canonical_solution():\n    import astropy.units as u, numpy as np\n    tint = 1000.*u.s\n    cr_b = ([3000., 100., 15.] * u.ct) / tint\n    b_i = u.Magnitude(cr_b)\n    atm_ext_b = 0.12 * u.mag\n    secz = 1./np.cos(45 * u.deg)\n    b_i0 = b_i - atm_ext_b * secz\n    return b_i0\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 427,
        "prompt_en": "Convert the luminosity value of 17.0 STmag to the unit of ABmag at a wavelength of 5500 Angstroms.",
        "prompt_zh": "将光度值17.0 STmag转换为在波长5500埃条件下的ABmag单位。\n",
        "canonical_solution": "def canonical_solution():\n    import astropy.units as u\n    flam = (17. * u.STmag).to(u.ABmag, u.spectral_density(5500.*u.AA))\n    return flam\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 428,
        "prompt_en": "Create a Magnitude object representing a luminosity of 10 counts per second.",
        "prompt_zh": "创建一个表征每秒10计数的光度Magnitude对象。\n",
        "canonical_solution": "def canonical_solution():\n  import astropy.units as u\n  import astropy.constants as c\n  mag = u.Magnitude(10 * u.ct / u.s)\n  return mag\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 429,
        "prompt_en": "Create an array containing 7 equally spaced values ranging from 2 to 5, each assigned with the unit \"dex(cm/s^2)\".",
        "prompt_zh": "创建一个包含7个等间距数值的数组，范围从2到5，每个数值都赋予单位“dex(cm/s^2)”。\n",
        "canonical_solution": "def canonical_solution():\n  import numpy as np\n  import astropy.units as u\n  dex_values = np.linspace(2., 5., 7) * u.Unit(\"dex(cm/s2)\")\n  return dex_values\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 430,
        "prompt_en": "Calculate the numerical value of the logarithmic gravity acceleration, represent gravitational acceleration in cm/s^2 using 5 orders of magnitude, and return its numerical value and corresponding physical units.",
        "prompt_zh": "计算对数重力加速度的数值，使用5个对数单位对重力加速度cm/s^2进行表示，并返回它的数值和对应的物理单位。\n",
        "canonical_solution": "def canonical_solution():\n  import astropy.units as u\n  logg = 5. * u.dex(u.cm / u.s**2)\n  logg_value = logg.value\n  logg_physical = logg.physical\n  return logg_value, logg_physical\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查两个浮点数是否近似相等\n    return np.isclose(data1, data2, atol=1e-8)\n\n",
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 431,
        "prompt_en": "Calculate the stellar magnitude for the blue band luminosity of [3000, 100, 15] counts and the visible light band luminosity of [4000, 90, 25] counts over a time interval of 1000 seconds.",
        "prompt_zh": "计算1000秒时间间隔内蓝色波段的光度为[3000, 100, 15]计数和可见光波段的光度为[4000, 90, 25]计数的星等。\n",
        "canonical_solution": "def canonical_solution():\n  import astropy.units as u\n  import numpy as np\n  tint = 1000.*u.s\n  cr_b = ([3000., 100., 15.] * u.ct) / tint\n  cr_v = ([4000., 90., 25.] * u.ct) / tint\n  b_i = u.Magnitude(cr_b)\n  v_i = u.Magnitude(cr_v)\n  return b_i, v_i\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n",
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 432,
        "prompt_en": "Based on the provided difference in color index between B-band and V-band (-0.2 mag) and the E(B-V) value of 0.31234684 mag, calculate the interstellar extinction value A(V) in the V-band using the standard astronomical extinction ratio Rv (3.1).",
        "prompt_zh": "基于提供的B波段与V波段颜色指数的差值（-0.2mag），和E(B-V)值为0.31234684mag，使用天体测量标准消光比率Rv（3.1）计算V波段的星际消光值A(V)。\n",
        "canonical_solution": "def canonical_solution():\n  import astropy.units as u\n  B_V0 = -0.2 * u.mag\n  EB_V = (0.31234684 * u.mag) - B_V0\n  R_V = 3.1\n  A_V = R_V * EB_V\n  return A_V\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 433,
        "prompt_en": "Convert the magnitude value of 17.2 in the standard photometric star magnitude (STmag) for a wavelength of 5500Å into the corresponding spectral energy flux unit (in erg/s/cm²/Å).",
        "prompt_zh": "将波长为5500Å的光量级数值17.2标准特征星等（STmag）转换为相应的光谱能流单位（单位为erg/s/cm²/Å）。\n",
        "canonical_solution": "def canonical_solution():\n  import astropy.units as u\n  lam = 5500 * u.AA  # Angstroms\n  B_mag_ST = u.Magnitude(17.2 * u.STmag)\n  erg_per_s_cm2_AA = 3.63078055e-09 * (u.erg/u.s/u.cm**2/u.AA)\n  flam = B_mag_ST.to(u.erg/u.s/u.cm**2/u.AA, equivalencies=u.spectral_density(lam))\n  return flam\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 434,
        "prompt_en": "Create a luminosity object representing a magnitude of -10.",
        "prompt_zh": "创建一个表示星等为-10的亮度对象。\n",
        "canonical_solution": "def canonical_solution():\n    import astropy.units as u\n    mag = u.Magnitude(-10.)\n    return mag\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 435,
        "prompt_en": "Calculate the surface gravity represented on a logarithmic scale (5 dex [cm/s^2]) and convert it to a value expressed in standard units ([m/s^2]).",
        "prompt_zh": "计算以对数尺度表示的表面重力（5 dex(厘米/秒^2)）并将其转换为以常规单位（米/秒^2）表示的数值。\n",
        "canonical_solution": "def canonical_solution():\n  import astropy.units as u\n  logg = 5. * u.dex(u.cm / u.s**2)\n  return logg.to(u.m / u.s**2)\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 436,
        "prompt_en": "Calculate and return the intrinsic luminosity magnitude of the celestial object in the B-band, assuming the observed magnitude is -1.19280314 mag(ct/s), the atmospheric extinction coefficient is 0.12 mag, and the observation angle is 45 degrees.",
        "prompt_zh": "计算并返回天体在B波段的固有光通量星等，假设观测到的星等为-1.19280314 mag(ct/s)，大气消光系数为0.12 mag，观测角度为45度。\n",
        "canonical_solution": "def canonical_solution():\n  import astropy.units as u, numpy as np\n  atm_ext_b = 0.12 * u.mag\n  secz = 1./np.cos(45 * u.deg)\n  b_i = u.Magnitude(-1.19280314 * u.mag(u.ct / u.s))\n  b_i0 = b_i - atm_ext_b * secz\n  return b_i0\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 437,
        "prompt_en": "Calculate the squared value of a physical quantity with units of length divided by seconds, and return the result in units of acceleration.",
        "prompt_zh": "计算长度的物理量平方与秒的比值，返回结果为加速度的单位。\n",
        "canonical_solution": "def canonical_solution():\n  import astropy.units as u\n  length = u.get_physical_type('length')\n  time = u.get_physical_type('time')\n  result = length ** 2 / u.s\n  return result\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 使用 == 运算符来比较两个 PhysicalType 实例是否等价\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 438,
        "prompt_en": "Retrieve the physical type information corresponding to the unit type 'speed' using the Astropy library.",
        "prompt_zh": "使用Astropy库获取与单位类型'speed'对应的物理类型信息。\n",
        "canonical_solution": "def canonical_solution():\n    import astropy.units as u\n    speed_physical_type = u.get_physical_type('speed')\n    return speed_physical_type\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 使用 == 运算符来比较两个 PhysicalType 实例是否等价\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 439,
        "prompt_en": "Query and return the physical type represented by the unit \"meter\".",
        "prompt_zh": "查询并返回“米”这个单位表示的物理类型。\n",
        "canonical_solution": "def canonical_solution():\n    import astropy.units as u\n    unit_physical_type = u.get_physical_type(u.meter)\n    return unit_physical_type\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 使用 == 运算符来比较两个 PhysicalType 实例是否等价\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 440,
        "prompt_en": "Query and return the type of physical quantity represented by a value of one barn multiplied by one megaparsec (Mpc).",
        "prompt_zh": "查询并返回单位为1个barn乘以1个兆秒差距（Mpc）的物理量类型。\n",
        "canonical_solution": "def canonical_solution():\n    import astropy.units as u\n    quantity_physical_type = u.get_physical_type(1 * u.barn * u.Mpc)\n    return quantity_physical_type\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 使用 == 运算符来比较两个 PhysicalType 实例是否等价\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 441,
        "prompt_en": "Inquire about the default physical type associated with the number 42 in the Astropy unit system.",
        "prompt_zh": "查询数字42在Astropy单位系统中默认对应的物理类型。\n",
        "canonical_solution": "def canonical_solution():\n    import astropy.units as u\n    number_physical_type = u.get_physical_type(42)\n    return number_physical_type\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 使用 == 运算符来比较两个 PhysicalType 实例是否等价\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 442,
        "prompt_en": "Retrieve the physical type corresponding to Coulomb units and return the representation of this type.",
        "prompt_zh": "获取库仑单位对应的物理类型，并返回这个类型表示。\n",
        "canonical_solution": "def canonical_solution():\n    import astropy.units as u\n    physical_type = u.coulomb.physical_type\n    return physical_type\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 使用 == 运算符来比较两个 PhysicalType 实例是否等价\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 443,
        "prompt_en": "Check if the unit 'meter per second squared' (m/s^2) belongs to the physical type 'acceleration'.",
        "prompt_zh": "检查单位'meter per second squared'（米/秒^2）是否属于物理类型'acceleration'（加速度）。\n",
        "canonical_solution": "def canonical_solution():\n    import astropy.units as u\n    acceleration = u.get_physical_type(u.m / u.s ** 2)\n    return acceleration == 'acceleration'\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 444,
        "prompt_en": "Retrieve and return the physical type units associated with \"pressure\".",
        "prompt_zh": "获取并返回与“压力”关联的物理类型单位。\n",
        "canonical_solution": "def canonical_solution():\n    import astropy.units as u\n    pressure_physical_types = u.get_physical_type('pressure')\n    return pressure_physical_types\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 使用 == 运算符来比较两个 PhysicalType 实例是否等价\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 445,
        "prompt_en": "List all the physical type names corresponding to the energy unit joule.",
        "prompt_zh": "列出所有与能量单位焦耳相对应的物理类型名称。\n",
        "canonical_solution": "def canonical_solution():\n    import astropy.units as u\n    energy_names = [name for name in u.J.physical_type]\n    return energy_names\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 比较列表长度和元素内容\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 446,
        "prompt_en": "Check if the joule unit corresponds to the physical type of energy in the Astropy unit system, and return the comparison result.",
        "prompt_zh": "检查在Astropy单位系统中焦耳单位是否对应于能量的物理类型，并返回比较结果。\n",
        "canonical_solution": "def canonical_solution():\n    import astropy.units as u\n    is_energy_physical_type = 'energy' == u.J.physical_type\n    return is_energy_physical_type\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 447,
        "prompt_en": "Retrieve the physical type representing \"length\", and compute its square to obtain the physical type representing \"area\". Return the physical type of this area.",
        "prompt_zh": "获取代表“长度”物理量的物理类型，并计算它的平方以得到代表“面积”物理量的物理类型。返回这个面积的物理类型。\n",
        "canonical_solution": "def canonical_solution():\n    import astropy.units as u\n    length_physical_type = u.get_physical_type('length')\n    time_physical_type = u.get_physical_type('time')\n    area_physical_type = length_physical_type ** 2\n    return area_physical_type\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 使用 == 运算符来比较两个 PhysicalType 实例是否等价\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 448,
        "prompt_en": "Add the two distances, 1100.1 meters and 13.5 kilometers, and return the result.",
        "prompt_zh": "将1100.1米和13.5千米这两个距离相加，并返回结果。\n",
        "canonical_solution": "def canonical_solution():\n  import astropy.units as u\n  q = 1100.1 * u.m + 13.5 * u.km\n  return q\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 449,
        "prompt_en": "Create a list containing time quantities of 60 seconds and 1 minute, convert all the time quantities in the list to units of minutes, and then return the results after conversion.",
        "prompt_zh": "创建一个列表，包含时长为60秒和1分钟的量，并将这个列表中的所有时间量转换成以分钟为单位的量，然后返回转换后的结果。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy import units as u\n  qlst = [60 * u.s, 1 * u.min]\n  return u.Quantity(qlst, u.min)\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 450,
        "prompt_en": "Convert the velocity value of 2.4 meters per second to the International System of Units and return the conversion result.",
        "prompt_zh": "将速度值2.4米/秒转换为国际标准单位，并返回转换结果。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy import units as u\n  q = 2.4 * u.m / u.s\n  return q.si\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 451,
        "prompt_en": "Convert the speed of 2.3 meters per second to kilometers per hour.",
        "prompt_zh": "将速度2.3 米/秒转换为千米/小时。\n",
        "canonical_solution": "def canonical_solution():\n  import astropy.units as u\n  q = 2.3 * u.m / u.s\n  return q.to(u.km / u.h)\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 452,
        "prompt_en": "Create a physical quantity representing speed with a value of 2.4 meters per second, and convert the speed to centimeters per second in the CGS unit system.",
        "prompt_zh": "创建一个表示速度的物理量，值为2.4米每秒，并将该速度转换为CGS单位制下的厘米每秒。\n",
        "canonical_solution": "def canonical_solution():\n  import astropy.units as u\n  q = 2.4 * u.m / u.s\n  return q.cgs\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 453,
        "prompt_en": "Add together 11 seconds and 30 seconds, and return the total time as a result.",
        "prompt_zh": "将11秒和30秒相加，并返回结果的总时间。\n",
        "canonical_solution": "def canonical_solution():\n  import astropy.units as u\n  q = 11 * u.s + 30 * u.s\n  return q\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 454,
        "prompt_en": "Create a quantity representing speed with a value of 15 meters per second.",
        "prompt_zh": "创建一个表示速度的量，值为15米每秒。\n",
        "canonical_solution": "def canonical_solution():\n    import astropy.units as u\n    speed = 15 * u.meter / u.second\n    return speed\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 455,
        "prompt_en": "Create a frequency object with a value of 1.25 and a unit of per second, and return this object.",
        "prompt_zh": "创建一个频率对象，数值为1.25，单位为每秒，并返回这个对象。\n",
        "canonical_solution": "def canonical_solution():\n    import astropy.units as u\n    frequency = 1.25 / u.second\n    return frequency\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 456,
        "prompt_en": "Create an array of length units with values of 1 meter, 2 meters, and 3 meters, and return this array.",
        "prompt_zh": "创建一个长度单位数组，数值为1米、2米和3米，并返回这个数组。\n",
        "canonical_solution": "def canonical_solution():\n    import astropy.units as u\n    length = [1, 2, 3] * u.meter\n    return length\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 457,
        "prompt_en": "Create a one-dimensional array with the elements consisting of 1 meter, 2 meters, and 3 meters, and return the array with units included.",
        "prompt_zh": "创建一个一维数组，元素包括1米、2米和3米，并返回这个带单位的数组。\n",
        "canonical_solution": "def canonical_solution():\n    import numpy as np\n    import astropy.units as u\n    length = np.array([1, 2, 3]) * u.meter\n    return length\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 458,
        "prompt_en": "Create a Quantity object representing a length of 42 meters.",
        "prompt_zh": "创建一个表示长度为42米的Quantity对象。\n",
        "canonical_solution": "from astropy import units as u\ndef canonical_solution():\n    # 创建具有指定单位的Quantity对象\n    q = u.Quantity(42, unit=\"meter\")\n    return q\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 459,
        "prompt_en": "Compare the arrays with values [1.0, 2.0] meters and [1.01, 2.01] meters to see if their differences are within a tolerance of 0.02 meters.",
        "prompt_zh": "比较两个数值为[1.0, 2.0]米和[1.01, 2.01]米的数组，看它们的差异是否在0.02米的容差内。\n",
        "canonical_solution": "from astropy import units as u\nimport numpy as np\ndef canonical_solution():\n    # 创建两个具有单位的数组并比较它们是否接近\n    a_array = u.Quantity([1.0, 2.0], u.meter)\n    b_array = u.Quantity([1.01, 2.01], u.meter)\n    return np.allclose(a_array, b_array, atol=0.02*u.meter)\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 460,
        "prompt_en": "Convert the speed from 60 miles per hour to kilometers per hour.",
        "prompt_zh": "将速度从60英里每小时转换为公里每小时。\n",
        "canonical_solution": "from astropy.units import imperial\nfrom astropy import units as u\ndef canonical_solution():\n    # 在imperial单位系统下创建速度量并转换为公制单位\n    speed_mph = u.Quantity(60, imperial.mile/u.hour)\n    speed_kmh = speed_mph.to(u.km/u.hour)\n    return speed_kmh\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 461,
        "prompt_en": "Find and return all equivalent units to grams (g) in the astropy library.",
        "prompt_zh": "找出并返回克（g）这个质量单位在astropy库中的所有等效单位。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy import units as u\n  equivalent_units = u.g.find_equivalent_units()\n  return equivalent_units\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 462,
        "prompt_en": "Create and return a dimensionless unit by dividing the unit \"meter\" by itself.",
        "prompt_zh": "创建并返回一个无量纲的单位，通过将单位“米”除以其自身得到。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy import units as u\n  dimensionless = u.m / u.m\n  return dimensionless\n\n\n",
        "test_code": [
            "\ndef test_code(unit1, unit2):\n    # 直接比较两个单位对象是否相等\n    return unit1 == unit2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 463,
        "prompt_en": "Calculate and return the dimensionless form of the conversion ratio between kilometers and meters.",
        "prompt_zh": "计算并返回公里与米之间换算比例的无量纲形式。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy import units as u\n  dimensionless_scaled = (u.km / u.m).decompose()\n  return dimensionless_scaled\n\n\n",
        "test_code": [
            "\ndef test_code(unit1, unit2):\n    # 直接比较两个单位对象是否相等\n    return unit1 == unit2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 464,
        "prompt_en": "Check if the conversion result of units kilometers divided by meters is dimensionless.",
        "prompt_zh": "检查单位公里除以米的转换结果是否是无量纲的（dimensionless）。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy import units as u\n  is_dimensionless = (u.km / u.m).physical_type == 'dimensionless'\n  return is_dimensionless\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 465,
        "prompt_en": "Create an Astropy Quantity object with a value of 2 and a unit of kilometers, and return this object.",
        "prompt_zh": "创建一个带有单位千米（公里）的Astropy数量对象，其值为2，并返回这个对象。\n",
        "canonical_solution": "def canonical_solution():\n    import typing as T\n    import astropy.units as u\n    from astropy.units import Quantity\n    # Type annotation for a Quantity object with a unit of kilometers\n    x: Quantity = 2 * u.km\n    return x\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 466,
        "prompt_en": "Read the contents of the file named \"coordinates/sites-un-ascii\" from the built-in package and return it as a string.",
        "prompt_zh": "读取内置数据包中名为\"coordinates/sites-un-ascii\"的文件内容，并将其作为字符串返回。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.utils.data import get_pkg_data_contents\n    return get_pkg_data_contents(\"coordinates/sites-un-ascii\")\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 467,
        "prompt_en": "Create a masked array containing the data [1.0, 2.0, 3.0] with the corresponding mask set to [False, False, True]. Then, compute and return the sum of the unmasked data points.",
        "prompt_zh": "创建一个包含数据[1.0, 2.0, 3.0]的掩蔽数组，并设置相对应的掩码为[False, False, True]，然后计算并返回未被掩蔽数据点的总和。\n",
        "canonical_solution": "def canonical_solution():\n  import numpy as np\n  from astropy.utils.masked import Masked\n  ma = Masked([1., 2., 3.], mask=[False, False, True])\n  return ma.sum()\n\n\n",
        "test_code": [
            "def test_code(data1, data2):\n  return data1.tolist()==data2.tolist()"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 468,
        "prompt_en": "Create a masked array with values [1., 2., 3.] and a corresponding mask [False, False, True], with the unit in meters. For the masked elements, use -75 centimeters as the fill value and return the processed array.",
        "prompt_zh": "创建一个被掩码的数组，其中包括值[1., 2., 3.]和相应的掩码[False, False, True]，单位为米。对于被掩码的元素，用-75厘米作为填充值，并返回处理后的数组。\n",
        "canonical_solution": "def canonical_solution():\n  import numpy as np\n  from astropy import units as u\n  from astropy.utils.masked import Masked\n  mq = Masked([1., 2., 3.], mask=[False, False, True]) * u.m\n  return mq.filled(fill_value=-75*u.cm)\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    return np.allclose(data1.value, data2.value, atol=1e-8) and data1.unit == data2.unit"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 469,
        "prompt_en": "For the two-dimensional array `[[0., 1.], [2., 3.]]`, treat the elements marked as True in the corresponding mask `[[False, True], [False, False]]` as invalid data to be ignored, and perform the summation for each row of the array. Return the sum result for each row.",
        "prompt_zh": "将二维数组`[[0., 1.], [2., 3.]]`中被相应掩码`[[False, True], [False, False]]`标记为True的元素视为无效数据进行忽略，并对这个数组在每一行内进行求和计算，返回每行的求和结果。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.utils.masked import Masked\n    ma = Masked([[0., 1.], [2., 3.]], mask=[[False, True], [False, False]])\n    result = ma.sum(axis=-1)\n    return result\n\n\n",
        "test_code": [
            "def test_code(data1, data2):\n  return data1.tolist()==data2.tolist()"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 470,
        "prompt_en": "Create a 2x2 array with a mask, where the array values are [[0., 1.], [2., 3.]], and the mask of the array is [[False, True], [False, False]], indicating that the second element of the first row is masked. Calculate and return the mean value along each row, ignoring the masked elements.",
        "prompt_zh": "创建一个带有掩码的2x2数组，其中数组值为[[0., 1.], [2., 3.]]，数组的掩码为[[False, True], [False, False]]，表示第一行第二个元素被掩码。计算并返回沿着每行的平均值，忽略掩码的元素。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.utils.masked import Masked\n    ma = Masked([[0., 1.], [2., 3.]], mask=[[False, True], [False, False]])\n    result = ma.mean(-1)\n    return result\n\n\n",
        "test_code": [
            "def test_code(data1, data2):\n  return data1.tolist()==data2.tolist()"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 471,
        "prompt_en": "Convert the celestial coordinates with right ascension of 10.68458 degrees and declination of 41.26917 degrees into string representations in three formats: decimal, degree-minute-second (dms), and hour-minute-second plus degree-minute-second (hmsdms).",
        "prompt_zh": "将赤经10.68458度、赤纬41.26917度的天体坐标转换为十进制、度分秒(dms)和时分秒+度分秒(hmsdms)三种格式的字符串表示。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.coordinates import SkyCoord\n    from astropy import units as u\n    c = SkyCoord(ra=10.68458*u.degree, dec=41.26917*u.degree, frame='icrs')\n    return c.to_string('decimal'), c.to_string('dms'), c.to_string('hmsdms')\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n",
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n",
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 472,
        "prompt_en": "Apply a square root stretch to the array [1, 3, 4, 5, 6] and limit the scaling to the 90% percentile interval of the data. Return the transformed array values.",
        "prompt_zh": "对数组[1, 3, 4, 5, 6]应用平方根拉伸并将色阶限制在数据的90%百分位数间隔内，返回变换后的数组值。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.visualization import SqrtStretch, PercentileInterval\n    transform = SqrtStretch() + PercentileInterval(90.)\n    transformed_values = transform([1, 3, 4, 5, 6])\n    return transformed_values\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 473,
        "prompt_en": "Apply a square root stretch transformation to the array `[0., 0.25, 0.5, 0.75, 1.]` and return the transformed result.",
        "prompt_zh": "对数组 `[0., 0.25, 0.5, 0.75, 1.]` 进行平方根拉伸变换，并返回变换后的结果。\n",
        "canonical_solution": "def canonical_solution():\n  from astropy.visualization import SqrtStretch\n  \n  # Create a SquareRootStretch object\n  stretch = SqrtStretch()\n  \n  # Stretch the values using the object\n  stretched_values = stretch([0., 0.25, 0.5, 0.75, 1.])\n  \n  return stretched_values\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 474,
        "prompt_en": "Create a 2D World Coordinate System (WCS) model with the following parameters: reference pixel coordinates are [-234.75, 8.3393], the spatial increment per pixel is [-0.066667, 0.066667] degrees, the world coordinates of the reference pixel are [0, -90] degrees, the coordinate types are [\"RA---AIR\", \"DEC--AIR\"], and set the projection plane parameters to [(2, 1, 45.0)]. Then, convert the pixel coordinates [[0, 0], [24, 38], [45, 98]] to the corresponding world coordinates.",
        "prompt_zh": "创建一个2D世界坐标系统（WCS）模型，并使用以下参数：参考像素坐标为[-234.75, 8.3393]，每个像素对应的空间增量为[-0.066667, 0.066667]度，参考像素的世界坐标为[0, -90]度，坐标类型为[\"RA---AIR\", \"DEC--AIR\"]，并且设置投影平面参数为[(2, 1, 45.0)]。然后将像素坐标[[0, 0], [24, 38], [45, 98]]转换为对应的世界坐标。\n",
        "canonical_solution": "def canonical_solution():\n    import numpy as np\n    from astropy import wcs\n    w = wcs.WCS(naxis=2)\n    w.wcs.crpix = [-234.75, 8.3393]\n    w.wcs.cdelt = np.array([-0.066667, 0.066667])\n    w.wcs.crval = [0, -90]\n    w.wcs.ctype = [\"RA---AIR\", \"DEC--AIR\"]\n    w.wcs.set_pv([(2, 1, 45.0)])\n    pixcrd = np.array([[0, 0], [24, 38], [45, 98]], dtype=np.float64)\n    world = w.wcs_pix2world(pixcrd, 0)\n    return world\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 475,
        "prompt_en": "Create a 2-dimensional WCS (World Coordinate System) object for astronomical image data. Set the reference pixel coordinates to [-234.75, 8.3393], with the world coordinate increment per pixel set to [-0.066667, 0.066667] (indicating westward and southward increase). Set the reference pixel's world coordinates to [0, -90], and set the coordinate types to Right Ascension and Declination (\"RA---AIR\", \"DEC--AIR\"). Define the projection parameters. After completing these steps, convert the coordinate system to a FITS header and return it.",
        "prompt_zh": "在天文图像数据中创建一个2维的WCS世界坐标系统对象。参照像素的坐标设置为[-234.75, 8.3393]，世界坐标每个像素的差值为[-0.066667, 0.066667]（表示西向和南向的增长），参照像素的世界坐标设置为[0, -90]，坐标类型设置为赤经和赤纬（\"RA---AIR\", \"DEC--AIR\"），并设定投影面参数。完成后，转换这个坐标系统为一个FITS头部信息并返回。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import wcs\n    w = wcs.WCS(naxis=2)\n    w.wcs.crpix = [-234.75, 8.3393]\n    w.wcs.cdelt = [-0.066667, 0.066667]\n    w.wcs.crval = [0, -90]\n    w.wcs.ctype = [\"RA---AIR\", \"DEC--AIR\"]\n    w.wcs.set_pv([(2, 1, 45.0)])\n    header = w.to_header()\n    return header\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 476,
        "prompt_en": "Open a FITS file named 'data/j94f05bgq_flt.fits'. Use the header information from the second Header Data Unit (HDU) of this file to create a World Coordinate System (WCS) object. Convert the pixel position (30, 40) into the corresponding celestial coordinates using this WCS object. Finally, return the celestial coordinate position.",
        "prompt_zh": "打开一个名为'data/j94f05bgq_flt.fits'的FITS文件，用该文件的第二个头部数据单元（HDU）中的头部信息创建一个世界坐标系（WCS）对象，并且将像素位置(30, 40)转换为对应的天体坐标位置。最后返回这个天体位置坐标。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy.io import fits\n    from astropy.wcs import WCS\n    from astropy.utils.data import get_pkg_data_filename\n    fn = get_pkg_data_filename('data/j94f05bgq_flt.fits', package='astropy.wcs.tests')\n    f = fits.open(fn)\n    w = WCS(f[1].header)\n    sky = w.pixel_to_world(30, 40)\n    f.close()\n    return sky\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 477,
        "prompt_en": "Translate the pixel coordinates (30, 40) from the header information of the second HDU in the FITS file 'data/j94f05bgq_flt.fits' to celestial coordinates and return these coordinates.",
        "prompt_zh": "将FITS文件'data/j94f05bgq_flt.fits'中，第二个HDU的头信息对应的像素坐标(30, 40)转换为天球坐标，并返回这些坐标。\n",
        "canonical_solution": "def canonical_solution():\n    from astropy import wcs\n    from astropy.io import fits\n    from astropy.utils.data import get_pkg_data_filename\n    # Open an example FITS file with WCS information\n    fn = get_pkg_data_filename('data/j94f05bgq_flt.fits', package='astropy.wcs.tests')\n    f = fits.open(fn)\n    wcsobj = wcs.WCS(f[1].header)\n    f.close()\n    # Perform the core WCS transformation from pixel to world coordinates\n    lon, lat = wcsobj.wcs_pix2world(30, 40, 0)\n    # Return the world coordinates\n    return lon, lat\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n",
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astropy"
    },
    {
        "test_id": 0,
        "prompt_en": "Query the ALMA (Atacama Large Millimeter/submillimeter Array) archive for data related to the celestial object \"M83\". The ALMA archive URL is set to 'https://almascience.eso.org'. Return all column names from the observation records.",
        "prompt_zh": "查询ALMA(Atacama Large Millimeter/submillimeter Array)档案库中与天体对象\"M83\"相关的数据，ALMA档案库url地址为'https://almascience.eso.org'，并返回观测记录中的所有列名。",
        "canonical_solution": "def canonical_solution():\n  from astroquery.alma import Alma\n  from astropy import coordinates\n  from astropy import units as u\n  alma = Alma()\n  alma.archive_url = 'https://almascience.eso.org'  # 设置archive_url以适应测试环境\n  m83_data = alma.query_object('M83')\n  return m83_data.colnames\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 比较列表长度和元素内容\n    return data1 == data2\n\n"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 1,
        "prompt_en": "Query and return a list of all available data collections in the Canadian Astronomy Data Centre (CADC).",
        "prompt_zh": "查询并返回加拿大天文数据中心（CADC）中可用的所有数据集合列表。\n",
        "canonical_solution": "def canonical_solution():\n    from astroquery.cadc import Cadc\n    cadc = Cadc()\n    collections = cadc.get_collections()\n    return collections\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    # 检查两个字典的键是否完全相同\n    if data1.keys() != data2.keys():\n        return False\n\n    # 检查每个键对应的值是否相同\n    for key in data1:\n        # 可以这里添加递归比较的逻辑，如果值是复杂的数据结构\n        if not np.all(data1[key] == data2[key]):\n            return False\n    \n    # 如果所有检查都通过，则认为两个字典一致\n    return True\n\n"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 2,
        "prompt_en": "Retrieve and return the description of all dataset collections stored in the Canadian Astronomy Data Centre (CADC) in a dictionary format, where the keys are the collection names and the values are their descriptions.",
        "prompt_zh": "检索并以字典格式返回加拿大天文数据中心（CADC）存储的所有数据集集合的描述信息，键为集合名称，值为其描述。",
        "canonical_solution": "def canonical_solution():\n    from astroquery.cadc import Cadc\n    cadc = Cadc()\n    collections = cadc.get_collections()\n    collection_descriptions = {k: v['Description'] for k, v in collections.items()}\n    return collection_descriptions\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    # 检查两个字典的键是否完全相同\n    if data1.keys() != data2.keys():\n        return False\n\n    # 检查每个键对应的值是否相同\n    for key in data1:\n        # 可以这里添加递归比较的逻辑，如果值是复杂的数据结构\n        if not np.all(data1[key] == data2[key]):\n            return False\n    \n    # 如果所有检查都通过，则认为两个字典一致\n    return True\n\n"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 3,
        "prompt_en": "Query astronomical observation data for a specific sky region, and retrieve download links for all relevant data within the Canada-France-Hawaii Telescope (CFHT) collection. The sky region coordinates are '08h45m07.5s +54d18m00s'.",
        "prompt_zh": "查询特定天区的天文观测数据，并获取加拿大法国夏威夷望远镜（CFHT）集合中所有相关数据的下载链接，天区坐标为'08h45m07.5s +54d18m00s'。\n",
        "canonical_solution": "def canonical_solution():\n    from astroquery.cadc import Cadc\n    cadc = Cadc()\n    result = cadc.query_region('08h45m07.5s +54d18m00s', collection='CFHT')\n    urls = cadc.get_data_urls(result)\n    return urls\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 比较列表长度和元素内容\n    return data1 == data2\n\n"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 4,
        "prompt_en": "Query the celestial observation catalog centered at NGC 7232 within a radius of 30 arcminutes. Use the CASDA interface to retrieve the observation data, and return the first 5 records in the result including observation ID (obs_publisher_did), right ascension (s_ra), declination (s_dec), and observation release date (obs_release_date).",
        "prompt_zh": "查询以NGC 7232为中心，半径30弧分范围内的天体观测目录。使用CASDA接口获取观测数据，并返回结果中包含的观测ID（obs_publisher_did）、赤经（s_ra）、赤纬（s_dec）及观测发布日期（obs_release_date）的前5条记录。",
        "canonical_solution": "def canonical_solution():\n  from astroquery.casda import Casda\n  from astropy.coordinates import SkyCoord\n  from astropy import units as u\n  centre = SkyCoord.from_name('NGC 7232')\n  result_table = Casda.query_region(centre, radius=30*u.arcmin)\n  return result_table['obs_publisher_did','s_ra', 's_dec', 'obs_release_date'][:5]\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 5,
        "prompt_en": "Query the observational data in the CASDA database for the region centered on NGC 7232 with a radius of 30 arcminutes. Filter for information that has already been publicly released. Select the columns 'obs_publisher_did' (Observation ID), 's_ra' (Right Ascension), 's_dec' (Declination), and 'obs_release_date' (Release Date) from the filtered results, and return the information for the first 5 rows.",
        "prompt_zh": "在CASDA数据库中查询以NGC 7232为中心的半径为30弧分的区域的观测数据，并筛选出已经公开发布的信息。从筛选出的结果中选取'obs_publisher_did'（观测ID）, 's_ra'（赤经）, 's_dec'（赤纬）, 'obs_release_date'（发布日期）这四列，并返回前5行的信息。\n",
        "canonical_solution": "def canonical_solution():\n    from astroquery.casda import Casda\n    from astropy.coordinates import SkyCoord\n    from astropy import units as u\n    centre = SkyCoord.from_name('NGC 7232')\n    result_table = Casda.query_region(centre, radius=30*u.arcmin)\n    public_results = Casda.filter_out_unreleased(result_table)\n    return public_results['obs_publisher_did','s_ra', 's_dec', 'obs_release_date'][:5]\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 6,
        "prompt_en": "Download the observational dataset from the European Space Agency's Infrared Space Observatory with data ID '80000203'. Set the retrieval type to 'OBSERVATION' and select the product level as 'DEFAULT_DATA_SET'. Save the data as a tar file named \"80000203.tar\". Display the list of filenames contained within this tar file.",
        "prompt_zh": "下载欧洲空间局红外空间天文台的观测数据集，数据ID为'80000203'，检索类型为'OBSERVATION'，选择产品层级为'DEFAULT_DATA_SET'，将数据以tar文件形式保存为\"80000203.tar\"。展示该tar文件中包含的文件名列表。",
        "canonical_solution": "def canonical_solution():\n  from astroquery.esa.iso import ISO\n  import tarfile\n  ISO.download_data('80000203', retrieval_type=\"OBSERVATION\",\n                    product_level=\"DEFAULT_DATA_SET\",\n                    filename=\"80000203.tar\", verbose=True)\n  tar = tarfile.open(\"80000203.tar\")\n  file_list = tar.getnames()\n  tar.close()\n  return file_list\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 比较列表长度和元素内容\n    return data1 == data2\n\n"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 7,
        "prompt_en": "List the names of all tables in the databases queryable by the James Webb Space Telescope.",
        "prompt_zh": "列出詹姆斯·韦伯空间望远镜可查询的数据库中所有表格的名称。\n",
        "canonical_solution": "def canonical_solution():\n  from astroquery.esa.jwst import Jwst\n  jwst_tables = Jwst.load_tables(only_names=True)\n  tables_names = [table.name for table in jwst_tables]\n  return tables_names\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 比较列表长度和元素内容\n    return data1 == data2\n\n"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 8,
        "prompt_en": "Query the James Webb Space Telescope (JWST) database for observational data centered at the coordinates with a right ascension of 53 degrees and declination of -27 degrees in the ICRS coordinate system, and search within a region 5 degrees wide and 5 degrees high.",
        "prompt_zh": "查询詹姆斯·韦伯太空望远镜（JWST）数据库中，位于 ICRS 坐标系下，赤经为 53 度，赤纬为 -27 度的坐标，并且以此坐标为中心，搜索宽度为 5 度，高度为 5 度范围内的观测数据。",
        "canonical_solution": "def canonical_solution():\n    import astropy.units as u\n    from astropy.coordinates import SkyCoord\n    from astroquery.esa.jwst import Jwst\n    coord = SkyCoord(ra=53, dec=-27, unit=(u.degree, u.degree), frame='icrs')\n    width = u.Quantity(5, u.deg)\n    height = u.Quantity(5, u.deg)\n    result = Jwst.query_region(coordinate=coord, width=width, height=height)\n    return result\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 9,
        "prompt_en": "Search for the celestial object named 'M1' in the European Space Agency's JWST database, using 'ALL' as the target resolver, with a search radius of 5 degrees, and return the query results.",
        "prompt_zh": "使用欧洲空间局的JWST数据库查询名称为'M1'的天体目标，使用'ALL'作为目标解析器，搜索范围半径为5度，并返回查询结果。\n",
        "canonical_solution": "def canonical_solution():\n    from astroquery.esa.jwst import Jwst\n    import astropy.units as u\n    target_name = 'M1'\n    target_resolver = 'ALL'\n    radius = u.Quantity(5, u.deg)\n    result = Jwst.query_target(target_name=target_name, target_resolver=target_resolver, radius=radius)\n    return result\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 10,
        "prompt_en": "Retrieve the list of all product filenames with the observation ID 'jw01063107001_02101_00013_nrca3' from the James Webb Space Telescope data archive, and return the list of these filenames.",
        "prompt_zh": "获取James Webb Space Telescope数据归档中观测ID为'jw01063107001_02101_00013_nrca3'的所有产品文件名，并返回这些文件名的列表。\n",
        "canonical_solution": "def canonical_solution():\n    from astroquery.esa.jwst import Jwst\n    product_list = Jwst.get_product_list(observation_id='jw01063107001_02101_00013_nrca3')\n    filenames = [product['filename'] for product in product_list]\n    return filenames\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 比较列表长度和元素内容\n    return data1 == data2\n\n"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 11,
        "prompt_en": "Download the PPS-level data with observation ID '0505720401' from XMM-Newton, requesting the file format be PDF, using 'detector M1', and save the file as 'result0505720401.tar'.",
        "prompt_zh": "下载XMM-Newton的观测ID为'0505720401'的PPS级别数据，要求文件格式为PDF、使用'探测器M1'，并将文件保存为'result0505720401.tar'。\n",
        "canonical_solution": "def canonical_solution():\n  from astroquery.esa.xmm_newton import XMMNewton\n  return XMMNewton.download_data('0505720401', level=\"PPS\", extension=\"PDF\", instname=\"M1\", filename=\"result0505720401.tar\")\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    return data1 is None and data2 is None\n\n"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 12,
        "prompt_en": "Retrieve the thumbnail image of the observation with ID '0505720401' using XMM-Newton astronomical satellite data query.",
        "prompt_zh": "使用XMM-Newton天文卫星数据查询，获取观测ID为'0505720401'的观测缩略图。\n",
        "canonical_solution": "def canonical_solution():\n  from astroquery.esa.xmm_newton import XMMNewton\n  return XMMNewton.get_postcard('0505720401')\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 13,
        "prompt_en": "Query the first 10 records from the public observation database of the XMM-Newton telescope, and save the query results as a CSV file named 'results10.csv'.",
        "prompt_zh": "查询XMM-Newton望远镜公共观测数据库中的前10条记录，并将查询结果保存为CSV格式的文件，文件名为'results10.csv'。\n",
        "canonical_solution": "def canonical_solution():\n  from astroquery.esa.xmm_newton import XMMNewton\n  return XMMNewton.query_xsa_tap(\"select top 10 * from v_public_observations\", output_format='csv', output_file='results10.csv')\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 14,
        "prompt_en": "Retrieve the list of queryable database tables for the European Space Agency's XMM-Newton telescope.",
        "prompt_zh": "获取欧洲空间局XMM-Newton望远镜可查询的数据库表格列表。\n",
        "canonical_solution": "def canonical_solution():\n  from astroquery.esa.xmm_newton import XMMNewton\n  return XMMNewton.get_tables()\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 比较列表长度和元素内容\n    return data1 == data2\n\n"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 15,
        "prompt_en": "Retrieve all column information from the 'xsa.v_all_observations' table in the XMM-Newton X-ray Observatory database.",
        "prompt_zh": "从XMM-Newton X射线天文台数据库中检索'xsa.v_all_observations'表的所有列信息。\n",
        "canonical_solution": "def canonical_solution():\n  from astroquery.esa.xmm_newton import XMMNewton\n  return XMMNewton.get_columns('xsa.v_all_observations')\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 比较列表长度和元素内容\n    return data1 == data2\n\n"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 16,
        "prompt_en": "List and retrieve all available observation catalogs in the ESASky region of the European Space Agency.",
        "prompt_zh": "列出并获取欧洲空间局天空区ESASky中可用的所有观测目录列表。\n",
        "canonical_solution": "def canonical_solution():\n    from astroquery.esasky import ESASky\n    catalog_list = ESASky.list_catalogs()\n    return catalog_list\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 比较列表长度和元素内容\n    return data1 == data2\n\n"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 17,
        "prompt_en": "List and return all available sky map names in the European Space Agency Sky Survey (ESASky).",
        "prompt_zh": "列出并返回欧洲空间局天空调查(ESASky)中所有可用的天空地图名称。\n",
        "canonical_solution": "def canonical_solution():\n    from astroquery.esasky import ESASky\n    maps_list = ESASky.list_maps()\n    return maps_list\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 比较列表长度和元素内容\n    return data1 == data2\n\n"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 18,
        "prompt_en": "Retrieve and return the list of all spectral data currently available through the European Space Agency's SKY service.",
        "prompt_zh": "获取并返回欧洲空间局SKY服务当前可用的所有光谱数据列表。\n",
        "canonical_solution": "def canonical_solution():\n    from astroquery.esasky import ESASky\n    spectra_list = ESASky.list_spectra()\n    return spectra_list\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 比较列表长度和元素内容\n    return data1 == data2\n\n"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 19,
        "prompt_en": "List all solar system objects that can be queried through the European Space Agency's Sky Region Service.",
        "prompt_zh": "列出所有可以通过欧洲空间局天空区域服务查询到的太阳系对象。\n",
        "canonical_solution": "def canonical_solution():\n    from astroquery.esasky import ESASky\n    sso_list = ESASky.list_sso()\n    return sso_list\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 比较列表长度和元素内容\n    return data1 == data2\n\n"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 20,
        "prompt_en": "Query the HSC (High Sensitivity Camera) catalog information for the object located at position \"M51\" (the Whirlpool Galaxy), and return the query results.",
        "prompt_zh": "查询位于\"M51\"位置（旋涡星系）的HSC（High Sensitivity Camera）天体目录信息，并返回查询结果。\n",
        "canonical_solution": "def canonical_solution():\n    from astroquery.esasky import ESASky\n    result = ESASky.query_object_catalogs(position=\"M51\", catalogs=\"HSC\")\n    return result\n\n\n",
        "test_code": [
            "import numpy as np\nfrom astropy.table import Table\n\ndef is_same_table(table_pred,table_ground):\n    table_pred = table_pred.to_pandas()\n    table_ground = table_ground.to_pandas()\n    table_pred_dict = table_pred.to_dict()\n    data_pred = {}\n    for column in  table_pred_dict.keys():\n        for row in table_pred_dict[column].keys():\n            if row not in data_pred.keys():\n                data_pred[row] = []\n            data_pred[row].append({column:table_pred_dict[column][row]})\n\n    table_ground_dict = table_ground.to_dict()\n    data_ground = {}\n    for column in  table_ground_dict.keys():\n        for row in table_ground_dict[column].keys():\n            if row not in data_ground.keys():\n                data_ground[row] = []\n            data_ground[row].append({column:table_ground_dict[column][row]})\n            \n    for data in data_ground:\n        if data not in data_pred:\n            return False\n\n    for data in data_pred:\n        if data not in data_ground:\n            return False\n    return True\n\ndef test_code(data1,data2):\n    if data1.keys()!=data2.keys():\n        return False\n    for key in data1.keys():\n        if not is_same_table(data1[key],data2[key]):\n            print(key)\n            return False\n    return True"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 21,
        "prompt_en": "Query the astronomical image data from the Hubble Space Telescope ultraviolet mission with observation IDs \"lbsk03vbq\" and \"ieag90010\" using the European Space Agency's Sky (ESASky) service, and return the results.",
        "prompt_zh": "使用欧洲空间局天空（ESASky）的服务查询哈勃空间望远镜紫外线任务中观测ID为\"lbsk03vbq\"和\"ieag90010\"的天文图像数据，并返回结果。\n",
        "canonical_solution": "def canonical_solution():\n    from astroquery.esasky import ESASky\n    maps = ESASky.query_ids_maps(observation_ids=[\"lbsk03vbq\", \"ieag90010\"], missions=\"HST-UV\")\n    return maps\n\n\n",
        "test_code": [
            "import numpy as np\nfrom astropy.table import Table\n\ndef is_same_table(table_pred,table_ground):\n    table_pred = table_pred.to_pandas()\n    table_ground = table_ground.to_pandas()\n    table_pred_dict = table_pred.to_dict()\n    data_pred = {}\n    for column in  table_pred_dict.keys():\n        for row in table_pred_dict[column].keys():\n            if row not in data_pred.keys():\n                data_pred[row] = []\n            data_pred[row].append({column:table_pred_dict[column][row]})\n\n    table_ground_dict = table_ground.to_dict()\n    data_ground = {}\n    for column in  table_ground_dict.keys():\n        for row in table_ground_dict[column].keys():\n            if row not in data_ground.keys():\n                data_ground[row] = []\n            data_ground[row].append({column:table_ground_dict[column][row]})\n            \n    for data in data_ground:\n        if data not in data_pred:\n            return False\n\n    for data in data_pred:\n        if data not in data_ground:\n            return False\n    return True\n\ndef test_code(data1,data2):\n    if data1.keys()!=data2.keys():\n        return False\n    for key in data1.keys():\n        if not is_same_table(data1[key],data2[key]):\n            print(key)\n            return False\n    return True"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 22,
        "prompt_en": "List all available instruments of the European Southern Observatory (ESO).",
        "prompt_zh": "列出欧洲南方天文台(ESO)的所有可用仪器。\n",
        "canonical_solution": "def canonical_solution():\n    from astroquery.eso import Eso\n    eso = Eso()\n    instruments_list = eso.list_instruments()\n    return instruments_list\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 比较列表长度和元素内容\n    return data1 == data2\n\n"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 23,
        "prompt_en": "Query and return the usage help information for the MIDI (MID-infrared Interferometric instrument) instrument at the European Southern Observatory (ESO).",
        "prompt_zh": "查询并返回欧洲南方天文台(ESO)中MIDI（MID-infrared Interferometric instrument）仪器的使用帮助信息。\n",
        "canonical_solution": "def canonical_solution():\n    from astroquery.eso import Eso\n    eso = Eso()\n    help_text = eso.query_instrument('midi', help=True)\n    return help_text\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    return data1 is None and data2 is None\n\n"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 24,
        "prompt_en": "Query the orbital period of the exoplanet 'HAT-P-11 b' and return the information.",
        "prompt_zh": "查询'HAT-P-11 b'这颗系外行星的轨道周期，并返回该信息。\n",
        "canonical_solution": "def canonical_solution():\n  from astroquery.exoplanet_orbit_database import ExoplanetOrbitDatabase\n  hatp11b = ExoplanetOrbitDatabase.query_planet('HAT-P-11 b')\n  return hatp11b['PER']\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接使用 == 运算符来比较两个字典\n    return data1 == data2\n\n"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 25,
        "prompt_en": "Retrieve the radius information of the exoplanet named \"HAT-P-11 b\" and return that information.",
        "prompt_zh": "查询名为\"HAT-P-11 b\"的太阳系外行星的半径信息，并返回该信息。\n",
        "canonical_solution": "def canonical_solution():\n  from astroquery.exoplanet_orbit_database import ExoplanetOrbitDatabase\n  hatp11b = ExoplanetOrbitDatabase.query_planet('HAT-P-11 b')\n  return hatp11b['R']\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接使用 == 运算符来比较两个字典\n    return data1 == data2\n\n"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 26,
        "prompt_en": "Query the orbital information of the exoplanet named 'HAT-P-11 b' and return its sky coordinates.",
        "prompt_zh": "查询名称为'HAT-P-11 b'的系外行星轨道信息，并返回其天空坐标。\n",
        "canonical_solution": "def canonical_solution():\n  from astroquery.exoplanet_orbit_database import ExoplanetOrbitDatabase\n  hatp11b = ExoplanetOrbitDatabase.query_planet('HAT-P-11 b')\n  return hatp11b['sky_coord']\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 27,
        "prompt_en": "Query the relevant data for the exoplanet named 'HAT-P-11 b', extract and return its orbital period, radius, and sky coordinates.",
        "prompt_zh": "查询名为'HAT-P-11 b'的系外行星的相关数据，提取并返回其轨道周期、半径和天空坐标。\n",
        "canonical_solution": "def canonical_solution():\n  from astroquery.exoplanet_orbit_database import ExoplanetOrbitDatabase\n  hatp11b = ExoplanetOrbitDatabase.query_planet('HAT-P-11 b')\n  return hatp11b['PER'], hatp11b['R'], hatp11b['sky_coord']\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接使用 == 运算符来比较两个字典\n    return data1 == data2\n\n",
            "\ndef test_code(data1, data2):\n    # 直接使用 == 运算符来比较两个字典\n    return data1 == data2\n\n",
            "\nimport numpy as np\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return np.all(data1 == data2)\n\n"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 28,
        "prompt_en": "Set the main table used for Gaia archive queries to the \"gaia_source\" table from the second data release (Data Release 2) of Gaia, and return the set table name.",
        "prompt_zh": "设置Gaia库查询使用的主表为Gaia数据发布第二版（Data Release 2）的\"gaia_source\"表，并返回所设置的表名。\n",
        "canonical_solution": "def canonical_solution():\n    from astroquery.gaia import Gaia\n    Gaia.MAIN_GAIA_TABLE = \"gaiadr2.gaia_source\"  # Select Data Release 2\n    return Gaia.MAIN_GAIA_TABLE\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 29,
        "prompt_en": "Set the main source table in the Gaia library of astroquery to the default main source table for Gaia Data Release 3 (gaiadr3) and return the name of the table.",
        "prompt_zh": "设置astroquery中Gaia库的主源表为默认的Gaia数据发布3（gaiadr3）的主源表，并返回该表的名称。",
        "canonical_solution": "def canonical_solution():\n    from astroquery.gaia import Gaia\n    Gaia.MAIN_GAIA_TABLE = \"gaiadr3.gaia_source\"  # Reselect Data Release 3, default\n    return Gaia.MAIN_GAIA_TABLE\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 直接比较两个字符串\n    return data1 == data2\n\n"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 30,
        "prompt_en": "Query the first 100 records from the `gaiadr3.gaia_source` table in the Gaia Data Release 3 (DR3) database. Extract the fields including solution_id, ref_epoch, ra_dec_corr, astrometric_n_obs_al, matched_transits, duplicated_source, and phot_variable_flag, ordered by `source_id`. Finally, return only the data column for right ascension and declination correlation correction (`ra_dec_corr`).",
        "prompt_zh": "查询 Gaia 数据发布 3 (DR3) 数据库 `gaiadr3.gaia_source` 表中的前 100 条记录，提取字段包括solution_id、ref_epoch、ra_dec_corr、astrometric_n_obs_al、matched_transits、duplicated_source、phot_variable_flag，并按 `source_id` 排序。最终，仅返回视向速度与位置角误差修正 (`ra_dec_corr`) 的数据列。",
        "canonical_solution": "def canonical_solution():\n    from astroquery.gaia import Gaia\n    job = Gaia.launch_job(\"select top 100 \"\n                          \"solution_id,ref_epoch,ra_dec_corr,astrometric_n_obs_al, \"\n                          \"matched_transits,duplicated_source,phot_variable_flag \"\n                          \"from gaiadr3.gaia_source order by source_id\")\n    r = job.get_results()\n    return r['ra_dec_corr']\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1,data2):\n    return np.allclose(data1, data2, atol=1e-8)"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 31,
        "prompt_en": "Query the top 100 records from the Gaia DR3 catalog. The selected fields include: solution_id, ref_epoch, ra_dec_corr, astrometric_n_obs_al, matched_transits, duplicated_source, phot_variable_flag. Sort the results in ascending order by source_id, and return the data in table format.",
        "prompt_zh": "查询Gaia DR3星表中的前100条记录，选择的字段包括：solution_id,ref_epoch,ra_dec_corr,astrometric_n_obs_al,matched_transits,duplicated_source,phot_variable_flag。结果按照source_id升序排序，并返回表格格式的数据。",
        "canonical_solution": "def canonical_solution():\n  from astroquery.gaia import Gaia\n  job = Gaia.launch_job(\"select top 100 \"\n                        \"solution_id,ref_epoch,ra_dec_corr,astrometric_n_obs_al, \"\n                        \"matched_transits,duplicated_source,phot_variable_flag \"\n                        \"from gaiadr3.gaia_source order by source_id\")\n  return job.get_results()\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 32,
        "prompt_en": "Execute an asynchronous query to access the Gaia database. Select the top 100 records from the Gaia DR3 source data table, extracting the designation, right ascension (ra), and declination (dec) information for each record. The results are ordered by `source_id`. Return the result set of the query.",
        "prompt_zh": "执行一个异步查询以访问Gaia数据库。从Gaia DR3的源数据表中选择前100个记录，提取每个记录的设计名称（designation）、赤经（ra）和赤纬（dec）信息。结果按照 `source_id` 排序。返回查询结果集。",
        "canonical_solution": "def canonical_solution():\n  from astroquery.gaia import Gaia\n  job = Gaia.launch_job_async(\"select top 100 designation,ra,dec \"\n                              \"from gaiadr3.gaia_source order by source_id\")\n  r = job.get_results()\n  return r\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 33,
        "prompt_en": "Load and return a list of all available table names from the Gaia archive.",
        "prompt_zh": "加载并返回Gaia档案中所有可用表格名称的列表。",
        "canonical_solution": "def canonical_solution():\n    from astroquery.gaia import Gaia\n    \n    tables = Gaia.load_tables(only_names=True)\n    result = []\n    for table in tables:\n        result.append(table.get_qualified_name())\n    return result\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 比较列表长度和元素内容\n    return data1 == data2\n\n"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 34,
        "prompt_en": "Query the HEASARC database for data records of the celestial object named '3c273' in the 'rosmaster' mission, and display the first three rows of the result with a maximum width of 120 characters.",
        "prompt_zh": "查询HEASARC数据库中名为'3c273'的天体对象在'rosmaster'任务中的数据记录，并以120字符的最大宽度格式展示结果的前三行。",
        "canonical_solution": "def canonical_solution():\n    from astroquery.heasarc import Heasarc\n    heasarc = Heasarc()\n    mission = 'rosmaster'\n    object_name = '3c273'\n    table = heasarc.query_object(object_name, mission=mission)\n    return table[:3].pprint(max_width=120)\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    return data1 is None and data2 is None\n\n"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 35,
        "prompt_en": "Using the HEASARC astroquery interface, query the rosmaster database to find data within a 1-degree radius of the ICRS coordinates '12h29m06.70s +02d03m08.7s'. Print the first three entries of the query result with a maximum width of 120 characters.",
        "prompt_zh": "使用 HEASARC astroquery 接口查询 rosmaster 数据库，查找位于ICRS坐标'12h29m06.70s +02d03m08.7s'一度半径范围内的数据，然后以最大宽度120打印出查询结果的前三条数据。",
        "canonical_solution": "def canonical_solution():\n    from astroquery.heasarc import Heasarc\n    from astropy.coordinates import SkyCoord\n    heasarc = Heasarc()\n    mission = 'rosmaster'\n    coords = SkyCoord('12h29m06.70s +02d03m08.7s', frame='icrs')\n    table = heasarc.query_region(coords, mission=mission, radius='1 degree')\n    return table[:3].pprint(max_width=120)\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    return data1 is None and data2 is None\n\n"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 36,
        "prompt_en": "Query data for the astronomical object '3C273' from the HEASARC database using the 'rosmaster' task, and retrieve information for the fields 'EXPOSURE' (exposure time), 'RA' (right ascension), and 'DEC' (declination). Print the first three records of the query results.",
        "prompt_zh": "从HEASARC数据库中查询天文对象'3c273'的数据，使用'rosmaster'任务，并且获取'EXPOSURE'（曝光时间），'RA'（赤经），'DEC'（赤纬）字段的信息，打印查询结果的前三条记录。\n",
        "canonical_solution": "def canonical_solution():\n    from astroquery.heasarc import Heasarc\n    heasarc = Heasarc()\n    table = heasarc.query_object('3c273', mission='rosmaster', fields='EXPOSURE,RA,DEC')\n    return table[:3].pprint()\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    return data1 is None and data2 is None\n\n"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 37,
        "prompt_en": "Query the HEASARC database for the astronomical object named '3c273' using data from the 'rosmaster' mission, with a search radius of 120 arcminutes. Print the first three rows of the retrieved data table.",
        "prompt_zh": "从HEASARC数据库中查询名为'3c273'的天体对象，在'rosmaster'任务中的数据，搜索半径为120弧分，并打印查询到的数据表格的前三行。",
        "canonical_solution": "def canonical_solution():\n    from astroquery.heasarc import Heasarc\n    heasarc = Heasarc()\n    table = heasarc.query_object('3c273', mission='rosmaster', radius='120 arcmin')\n    return table[:3].pprint()\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    return data1 is None and data2 is None\n\n"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 38,
        "prompt_en": "Query the HEASARC database for information on the astronomical object '3c273' with the mission 'rosmaster'. Sort the results by exposure time 'EXPOSURE'. Print and return the first three rows of the query results.",
        "prompt_zh": "从HEASARC数据库中查询天体对象'3c273'在任务'mission'为'rosmaster'中的信息，并按照曝光时间'EXPOSURE'进行排序，打印并返回查询结果的前三行。",
        "canonical_solution": "def canonical_solution():\n    from astroquery.heasarc import Heasarc\n    heasarc = Heasarc()\n    table = heasarc.query_object('3c273', mission='rosmaster', sortvar='EXPOSURE')\n    return table[:3].pprint()\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    return data1 is None and data2 is None\n\n"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 39,
        "prompt_en": "Query the HEASARC for data on the celestial object named '3c273' in the 'rosmaster' mission and return the first three data records.",
        "prompt_zh": "从HEASARC查询名为'3c273'的天体对象在'rosmaster'任务中的数据，并返回前三条数据记录。\n",
        "canonical_solution": "def canonical_solution():\n  from astroquery.heasarc import Heasarc\n  heasarc = Heasarc()\n  mission = 'rosmaster'\n  object_name = '3c273'\n  table = heasarc.query_object(object_name, mission=mission)\n  return table[:3]\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 40,
        "prompt_en": "Query the HEASARC database for a region centered at ICRS coordinates 12h29m06.70s, +02d03m08.7s, with a radius of 1 degree. The data should be from the 'rosmaster' mission. Return the first three entries of the query results.",
        "prompt_zh": "在HEASARC数据库中查询以ICRS坐标12时29分06.70秒、+02度03分08.7秒为中心、半径为1度的区域，并返回查询结果的前三条数据。查询的数据来自'rosmaster'任务。",
        "canonical_solution": "def canonical_solution():\n  from astroquery.heasarc import Heasarc\n  from astropy.coordinates import SkyCoord\n  heasarc = Heasarc()\n  mission = 'rosmaster'\n  coords = SkyCoord('12h29m06.70s +02d03m08.7s', frame='icrs')\n  table = heasarc.query_region(coords, mission=mission, radius='1 degree')\n  return table[:3]\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 41,
        "prompt_en": "Use Heasarc to query 'rosmaster' mission data related to the celestial object '3c273', specifically including the fields of exposure time (EXPOSURE), right ascension (RA), and declination (DEC). Return the information of the first three records.",
        "prompt_zh": "使用Heasarc查询与天体对象'3c273'相关的'rosmaster'任务数据，具体要包含曝光时间(EXPOSURE)、赤经(RA)和赤纬(DEC)字段，并返回前三条记录的信息。\n",
        "canonical_solution": "def canonical_solution():\n  from astroquery.heasarc import Heasarc\n  heasarc = Heasarc()\n  table = heasarc.query_object(object_name='3c273', mission='rosmaster', fields='EXPOSURE,RA,DEC')\n  return table[:3]\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 42,
        "prompt_en": "Use astroquery.hips2fits to query the HiPS image dataset requesting an image with a width of 1000 pixels, height of 500 pixels, right ascension at 0 degrees, declination at 20 degrees, and a field of view angle of 80 degrees. Apply an AIT projection, set the image format to jpg, the minimum cut to 0.5%, the maximum cut to 99.5%, and the color map to viridis.",
        "prompt_zh": "使用astroquery.hips2fits查询HiPS图像数据集，请求一个宽度为1000像素、高度为500像素、右赤经为0度、赤纬为20度、视场角度为80度的图像，使用AIT投影，并设置图像格式为jpg、最小剪切为0.5%、最大剪切为99.5%和颜色映射为viridis。\n",
        "canonical_solution": "def canonical_solution():\n    from astroquery.hips2fits import hips2fits\n    import astropy.units as u\n    from astropy.coordinates import Longitude, Latitude, Angle\n    hips = 'CDS/P/DSS2/red'\n    result = hips2fits.query(\n        hips=hips,\n        width=1000,\n        height=500,\n        ra=Longitude(0 * u.deg),\n        dec=Latitude(20 * u.deg),\n        fov=Angle(80 * u.deg),\n        projection=\"AIT\",\n        get_query_payload=False,\n        format='jpg',\n        min_cut=0.5,\n        max_cut=99.5,\n        cmap='viridis',\n    )\n    return result\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 43,
        "prompt_en": "Query the HiPS service `CDS/P/DSS2/red` to obtain an astronomical image with the coordinate system being Galactic coordinates in Mollweide projection. The image specifications are: width of 2000 pixels, height of 1000 pixels, centered at (0.0, 0.0) degrees, and a pixel scale of 0.18 degrees. Set the image format to JPG, colormap to viridis, and brightness contrast range between 0.5% and 99.5%.",
        "prompt_zh": "查询HiPS服务`CDS/P/DSS2/red`以获取坐标系为银道坐标系统（Mollweide投影）的天体图像，图像规格为宽2000像素、高1000像素、中心位于（0.0, 0.0）度、像素尺度为0.18度，并设置图像格式为JPG，色图为viridis，亮度对比度范围在0.5%到99.5%之间。",
        "canonical_solution": "def canonical_solution():\n    from astroquery.hips2fits import hips2fits\n    import matplotlib.pyplot as plt\n    from astropy import wcs as astropy_wcs\n    w = astropy_wcs.WCS(header={\n        'NAXIS1': 2000,\n        'NAXIS2': 1000,\n        'WCSAXES': 2,\n        'CRPIX1': 1000.0,\n        'CRPIX2': 500.0,\n        'CDELT1': -0.18,\n        'CDELT2': 0.18,\n        'CUNIT1': 'deg',\n        'CUNIT2': 'deg',\n        'CTYPE1': 'GLON-MOL',\n        'CTYPE2': 'GLAT-MOL',\n        'CRVAL1': 0.0,\n        'CRVAL2': 0.0,\n    })\n    hips = 'CDS/P/DSS2/red'\n    result = hips2fits.query_with_wcs(\n        hips=hips,\n        wcs=w,\n        get_query_payload=False,\n        format='jpg',\n        min_cut=0.5,\n        max_cut=99.5,\n        cmap='viridis',\n    )\n    return result\n\n\n",
        "test_code": [
            "\nimport numpy as np\n\ndef test_code(data1, data2):\n    # 检查形状是否相同\n    if data1.shape != data2.shape:\n        return False\n    # 检查内容是否相同\n    # 使用 np.allclose 而不是 np.array_equal 来处理可能的浮点误差\n    return np.allclose(data1, data2, atol=1e-8, equal_nan=True)\n\n"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 44,
        "prompt_en": "Query the HITRAN database for spectral line information of the substance with molecule number 1 (water molecule H2O) and isotopologue number 1, within the wavenumber range of 0 to 10 1/cm. Return the results.",
        "prompt_zh": "从HITRAN数据库中查询分子编号为1（水分子H2O）和同位素编号为1的物质，在波数0到10 1/cm之间的光谱线信息，并返回。",
        "canonical_solution": "def canonical_solution():\n    from astropy import units as u\n    from astroquery.hitran import Hitran\n    tbl = Hitran.query_lines(molecule_number=1,\n                             isotopologue_number=1,\n                             min_frequency=0. / u.cm,\n                             max_frequency=10. / u.cm)\n    return tbl\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 45,
        "prompt_en": "Using the Hitran database, query the line list for the first molecule and the first isotopologue within the frequency range of 3400 cm⁻¹ to 4100 cm⁻¹. Return the results.",
        "prompt_zh": "使用Hitran数据库查询第一个分子和第一个同位素在每厘米3400至每厘米4100频率范围内的线列表，并返回结果。",
        "canonical_solution": "def canonical_solution():\n  from astropy import units as u\n  from astroquery.hitran import Hitran\n  tbl = Hitran.query_lines(molecule_number=1,\n                           isotopologue_number=1,\n                           min_frequency=3400 / u.cm,\n                           max_frequency=4100 / u.cm)\n  return tbl\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 46,
        "prompt_en": "Connect to the GAIA data TAP service (URL: `https://gea.esac.esa.int/tap-server/tap`) and retrieve all column names from the 'gaiadr1.gaia_source' table.",
        "prompt_zh": "连接到GAIA数据TAP服务（URL为`https://gea.esac.esa.int/tap-server/tap`），并获取'gaiadr1.gaia_source'表的所有列名。",
        "canonical_solution": "def canonical_solution():\n    from astroquery.utils.tap.core import TapPlus\n    gaia = TapPlus(url=\"https://gea.esac.esa.int/tap-server/tap\")\n    table = gaia.load_table('gaiadr1.gaia_source')\n    columns = [column.name for column in table.columns]\n    return columns\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 比较列表长度和元素内容\n    return data1 == data2\n\n"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 47,
        "prompt_en": "Connect to Gaia's TAP service with the URL `https://gea.esac.esa.int/tap-server/tap` and list the names of all available data tables.",
        "prompt_zh": "连接到Gaia的TAP服务（URL为`https://gea.esac.esa.int/tap-server/tap`），并列出所有可用的数据表的名称。",
        "canonical_solution": "def canonical_solution():\n    from astroquery.utils.tap.core import TapPlus\n    gaia = TapPlus(url=\"https://gea.esac.esa.int/tap-server/tap\")\n    tables = gaia.load_tables(only_names=True)\n    table_names = [table.get_qualified_name() for table in tables]\n    return table_names\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 比较列表长度和元素内容\n    return data1 == data2\n\n"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 48,
        "prompt_en": "Connect to the TAP service of the Gaia Archive with the URL `https://gea.esac.esa.int/tap-server/tap`. Load the data table `gaiadr1.gaia_source`. Extract all column names and descriptions from this table, with each pair of name and description as a tuple. Return a list where each element is a tuple in the format (column name, column description).",
        "prompt_zh": "连接到Gaia Archive的TAP服务（URL为`https://gea.esac.esa.int/tap-server/tap`），加载数据表`gaiadr1.gaia_source`。提取该表的所有列名称和描述，每对名称和描述作为一个元组，返回一个列表，其每个元素是一个格式为(列名称, 列描述)的元组。",
        "canonical_solution": "def canonical_solution():\n    from astroquery.utils.tap.core import TapPlus\n    gaia = TapPlus(url=\"https://gea.esac.esa.int/tap-server/tap\")\n    table = gaia.load_table('gaiadr1.gaia_source')\n    column_info = [(column.name, column.description) for column in table.columns]\n    return column_info\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 比较列表长度和元素内容\n    return data1 == data2\n\n"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 49,
        "prompt_en": "Use the Gaia TAP service with the URL `https://gea.esac.esa.int/tap-server/tap` to query the first 100 records from the Gaia DR1 catalog. Retrieve the fields 'solution_id', 'ref_epoch', 'ra_dec_corr', 'astrometric_n_obs_al', 'matched_observations', 'duplicated_source', and 'phot_variable_flag'. The query results should be sorted by the 'source_id' field. Finally, return the contents of the 'solution_id' column.",
        "prompt_zh": "使用Gaia TAP服务（URL为`https://gea.esac.esa.int/tap-server/tap`）来查询Gaia DR1星表的前100条记录。检索的字段包括'solution_id', 'ref_epoch', 'ra_dec_corr', 'astrometric_n_obs_al', 'matched_observations', 'duplicated_source', 和'phot_variable_flag'。查询结果按'source_id'字段进行排序。最终返回'solution_id'列的内容。",
        "canonical_solution": "def canonical_solution():\n    from astroquery.utils.tap.core import TapPlus\n    gaia = TapPlus(url=\"https://gea.esac.esa.int/tap-server/tap\")\n    job = gaia.launch_job(\"select top 100 solution_id,ref_epoch,ra_dec_corr,astrometric_n_obs_al,matched_observations,duplicated_source,phot_variable_flag \\\n                          from gaiadr1.gaia_source order by source_id\")\n    r = job.get_results()\n    return r['solution_id']\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1,data2):\n    return np.allclose(data1, data2, atol=1e-8)"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 50,
        "prompt_en": "Asynchronously retrieve the first 100 rows of data from the `gaia_source` table in Gaia Data Release 1, sorting by `source_id`. Return the values of the `solution_id` field in the query results.",
        "prompt_zh": "从Gaia数据发布1的`gaia_source`表中异步检索前100行数据，并按照`source_id`进行排序，返回查询结果中的`solution_id`字段值。\n",
        "canonical_solution": "def canonical_solution():\n    from astroquery.utils.tap.core import TapPlus\n    gaia = TapPlus(url=\"https://gea.esac.esa.int/tap-server/tap\")\n    job = gaia.launch_job_async(\"select top 100 * from gaiadr1.gaia_source order by source_id\")\n    r = job.get_results()\n    return r['solution_id']\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1,data2):\n    return np.allclose(data1, data2, atol=1e-8)"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 51,
        "prompt_en": "Query the Vizier database for the 'J/ApJ/706/83' and 'J/ApJS/191/232' astronomical catalogs and return a complete list of all records.",
        "prompt_zh": "查询Vizier数据库中'J/ApJ/706/83'和'J/ApJS/191/232'这两个天文目录，并返回所有记录的完整列表。\n",
        "canonical_solution": "def canonical_solution():\n    from astroquery.vizier import Vizier\n    Vizier.ROW_LIMIT = -1\n    catalogs = Vizier.get_catalogs(['J/ApJ/706/83', 'J/ApJS/191/232'])\n    return catalogs\n\n\n",
        "test_code": [
            "import numpy as np\nfrom astropy.table import Table\n\ndef is_same_table(table_pred,table_ground):\n    table_pred = table_pred.to_pandas()\n    table_ground = table_ground.to_pandas()\n    table_pred_dict = table_pred.to_dict()\n    data_pred = {}\n    for column in  table_pred_dict.keys():\n        for row in table_pred_dict[column].keys():\n            if row not in data_pred.keys():\n                data_pred[row] = []\n            data_pred[row].append({column:table_pred_dict[column][row]})\n\n    table_ground_dict = table_ground.to_dict()\n    data_ground = {}\n    for column in  table_ground_dict.keys():\n        for row in table_ground_dict[column].keys():\n            if row not in data_ground.keys():\n                data_ground[row] = []\n            data_ground[row].append({column:table_ground_dict[column][row]})\n            \n    for data in data_ground:\n        if data not in data_pred:\n            return False\n\n    for data in data_pred:\n        if data not in data_ground:\n            return False\n    return True\n\ndef test_code(data1,data2):\n    if data1.keys()!=data2.keys():\n        return False\n    for key in data1.keys():\n        if not is_same_table(data1[key],data2[key]):\n            print(key)\n            return False\n    return True"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 52,
        "prompt_en": "Query the Vizier astronomical catalog VII/258/vv10, selecting all columns as well as right ascension and declination. Filter objects with magnitudes between 10.0 and 11.0, and return the first set of results from the query.",
        "prompt_zh": "查询Vizier天文目录VII/258/vv10，选择所有列以及赤经和赤纬，筛选星等介于10.0至11.0之间的对象，并返回查询结果中的第一组数据。",
        "canonical_solution": "def canonical_solution():\n    from astroquery.vizier import Vizier\n    agn = Vizier(catalog=\"VII/258/vv10\",\n                  columns=['*', '_RAJ2000', '_DEJ2000']).query_constraints(Vmag=\"10.0..11.0\")[0]\n    return agn\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 53,
        "prompt_en": "Query data about Sirius in the Vizier catalog service, and limit the maximum number of rows returned to 50.",
        "prompt_zh": "在Vizier目录服务中查询有关天狼星（sirius）的数据，并且限制返回结果的最大行数为50。\n",
        "canonical_solution": "def canonical_solution():\n    from astroquery.vizier import Vizier\n    Vizier.ROW_LIMIT = 50\n    result = Vizier.query_object(\"sirius\")\n    return result\n\n\n",
        "test_code": [
            "import numpy as np\nfrom astropy.table import Table\n\ndef is_same_table(table_pred,table_ground):\n    table_pred = table_pred.to_pandas()\n    table_ground = table_ground.to_pandas()\n    table_pred_dict = table_pred.to_dict()\n    data_pred = {}\n    for column in  table_pred_dict.keys():\n        for row in table_pred_dict[column].keys():\n            if row not in data_pred.keys():\n                data_pred[row] = []\n            data_pred[row].append({column:table_pred_dict[column][row]})\n\n    table_ground_dict = table_ground.to_dict()\n    data_ground = {}\n    for column in  table_ground_dict.keys():\n        for row in table_ground_dict[column].keys():\n            if row not in data_ground.keys():\n                data_ground[row] = []\n            data_ground[row].append({column:table_ground_dict[column][row]})\n            \n    for data in data_ground:\n        if data not in data_pred:\n            return False\n\n    for data in data_pred:\n        if data not in data_ground:\n            return False\n    return True\n\ndef test_code(data1,data2):\n    if data1.keys()!=data2.keys():\n        return False\n    for key in data1.keys():\n        if not is_same_table(data1[key],data2[key]):\n            print(key)\n            return False\n    return True"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 54,
        "prompt_en": "Query the Gaia DR2 (I/345/gaia2) catalog data for objects within 10 arcminutes of the center of celestial object M81, with Gmag less than 19, using Vizier.",
        "prompt_zh": "使用Vizier查询距离天体M81中心10弧分钟内，并且Gmag小于19的Gaia DR2（I/345/gaia2）星表数据。",
        "canonical_solution": "def canonical_solution():\n    from astroquery.vizier import Vizier\n    from astropy.coordinates import SkyCoord\n    import astropy.units as u\n    result = Vizier.query_region(SkyCoord.from_name('M81'),\n                                 radius=10*u.arcmin,\n                                 catalog='I/345/gaia2',\n                                 column_filters={'Gmag': '<19'})\n    return result\n\n\n",
        "test_code": [
            "import numpy as np\nfrom astropy.table import Table\n\ndef is_same_table(table_pred,table_ground):\n    table_pred = table_pred.to_pandas()\n    table_ground = table_ground.to_pandas()\n    table_pred_dict = table_pred.to_dict()\n    data_pred = {}\n    for column in  table_pred_dict.keys():\n        for row in table_pred_dict[column].keys():\n            if row not in data_pred.keys():\n                data_pred[row] = []\n            data_pred[row].append({column:table_pred_dict[column][row]})\n\n    table_ground_dict = table_ground.to_dict()\n    data_ground = {}\n    for column in  table_ground_dict.keys():\n        for row in table_ground_dict[column].keys():\n            if row not in data_ground.keys():\n                data_ground[row] = []\n            data_ground[row].append({column:table_ground_dict[column][row]})\n            \n    for data in data_ground:\n        if data not in data_pred:\n            return False\n\n    for data in data_pred:\n        if data not in data_ground:\n            return False\n    return True\n\ndef test_code(data1,data2):\n    if data1.keys()!=data2.keys():\n        return False\n    for key in data1.keys():\n        if not is_same_table(data1[key],data2[key]):\n            print(key)\n            return False\n    return True"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 55,
        "prompt_en": "Use Vizier to search for astronomical catalogs containing the keyword 'Kang W51', without limiting the number of rows, and download the data from these catalogs.",
        "prompt_zh": "使用Vizier搜索包含关键词'Kang W51'的天文目录，不限制行数，并下载这些目录的数据。",
        "canonical_solution": "def canonical_solution():\n  from astroquery.vizier import Vizier\n  catalog_list = Vizier.find_catalogs('Kang W51')\n  catalogs = Vizier.get_catalogs(catalog_list.keys())\n  return catalogs\n\n\n",
        "test_code": [
            "import numpy as np\nfrom astropy.table import Table\n\ndef is_same_table(table_pred,table_ground):\n    table_pred = table_pred.to_pandas()\n    table_ground = table_ground.to_pandas()\n    table_pred_dict = table_pred.to_dict()\n    data_pred = {}\n    for column in  table_pred_dict.keys():\n        for row in table_pred_dict[column].keys():\n            if row not in data_pred.keys():\n                data_pred[row] = []\n            data_pred[row].append({column:table_pred_dict[column][row]})\n\n    table_ground_dict = table_ground.to_dict()\n    data_ground = {}\n    for column in  table_ground_dict.keys():\n        for row in table_ground_dict[column].keys():\n            if row not in data_ground.keys():\n                data_ground[row] = []\n            data_ground[row].append({column:table_ground_dict[column][row]})\n            \n    for data in data_ground:\n        if data not in data_pred:\n            return False\n\n    for data in data_pred:\n        if data not in data_ground:\n            return False\n    return True\n\ndef test_code(data1,data2):\n    if data1.keys()!=data2.keys():\n        return False\n    for key in data1.keys():\n        if not is_same_table(data1[key],data2[key]):\n            print(key)\n            return False\n    return True"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 56,
        "prompt_en": "Use Vizier to query data of the celestial object HD 226868 in the NOMAD and UCAC catalogs. The returned data should include _RAJ2000, _DEJ2000, B-V, Vmag, and Plx. Filter the records to include only those with a V magnitude greater than 10, and limit the number of records to no more than 50. Apply the keywords 'optical' and 'xry' for filtering.",
        "prompt_zh": "使用Vizier查询HD 226868天体在NOMAD和UCAC两个目录中的数据，返回的数据应包括_RAJ2000、_DEJ2000、B-V、Vmag和Plx，对V星等大于10的记录进行过滤，且记录条数不超过50条，并应用‘optical’和‘xry’的关键词过滤。",
        "canonical_solution": "def canonical_solution():\n  from astroquery.vizier import Vizier\n  Vizier.ROW_LIMIT = 50  # 设定行限制为50\n  v = Vizier(columns=['_RAJ2000', '_DEJ2000','B-V', 'Vmag', 'Plx'],\n             column_filters={\"Vmag\":\">10\"}, keywords=[\"optical\", \"xry\"])\n  result = v.query_object(\"HD 226868\", catalog=[\"NOMAD\", \"UCAC\"])\n  return result\n\n\n",
        "test_code": [
            "import numpy as np\nfrom astropy.table import Table\n\ndef is_same_table(table_pred,table_ground):\n    table_pred = table_pred.to_pandas()\n    table_ground = table_ground.to_pandas()\n    table_pred_dict = table_pred.to_dict()\n    data_pred = {}\n    for column in  table_pred_dict.keys():\n        for row in table_pred_dict[column].keys():\n            if row not in data_pred.keys():\n                data_pred[row] = []\n            data_pred[row].append({column:table_pred_dict[column][row]})\n\n    table_ground_dict = table_ground.to_dict()\n    data_ground = {}\n    for column in  table_ground_dict.keys():\n        for row in table_ground_dict[column].keys():\n            if row not in data_ground.keys():\n                data_ground[row] = []\n            data_ground[row].append({column:table_ground_dict[column][row]})\n            \n    for data in data_ground:\n        if data not in data_pred:\n            return False\n\n    for data in data_pred:\n        if data not in data_ground:\n            return False\n    return True\n\ndef test_code(data1,data2):\n    if data1.keys()!=data2.keys():\n        return False\n    for key in data1.keys():\n        if not is_same_table(data1[key],data2[key]):\n            print(key)\n            return False\n    return True"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 57,
        "prompt_en": "Query the \"HD 226868\" region using the Vizier database with a search radius of 20 arcseconds. Return all available columns and the angular distance to the query target, and set the catalog to \"II/246\".",
        "prompt_zh": "使用Vizier数据库查询\"HD 226868\"区域，搜索半径为20秒角，并返回所有可用列以及与查询目标的角距离，目录设置为\"II/246\"。\n",
        "canonical_solution": "def canonical_solution():\n  from astroquery.vizier import Vizier\n  v = Vizier(columns=[\"*\", \"+_r\"], catalog=\"II/246\")\n  result = v.query_region(\"HD 226868\", radius=\"20s\")\n  return result\n\n\n",
        "test_code": [
            "import numpy as np\nfrom astropy.table import Table\n\ndef is_same_table(table_pred,table_ground):\n    table_pred = table_pred.to_pandas()\n    table_ground = table_ground.to_pandas()\n    table_pred_dict = table_pred.to_dict()\n    data_pred = {}\n    for column in  table_pred_dict.keys():\n        for row in table_pred_dict[column].keys():\n            if row not in data_pred.keys():\n                data_pred[row] = []\n            data_pred[row].append({column:table_pred_dict[column][row]})\n\n    table_ground_dict = table_ground.to_dict()\n    data_ground = {}\n    for column in  table_ground_dict.keys():\n        for row in table_ground_dict[column].keys():\n            if row not in data_ground.keys():\n                data_ground[row] = []\n            data_ground[row].append({column:table_ground_dict[column][row]})\n            \n    for data in data_ground:\n        if data not in data_pred:\n            return False\n\n    for data in data_pred:\n        if data not in data_ground:\n            return False\n    return True\n\ndef test_code(data1,data2):\n    if data1.keys()!=data2.keys():\n        return False\n    for key in data1.keys():\n        if not is_same_table(data1[key],data2[key]):\n            print(key)\n            return False\n    return True"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 58,
        "prompt_en": "Search for catalogs containing the keyword 'Kang W51' in the VizieR catalog service. For each catalog found, create a dictionary with the catalog ID as the key and its description as the value, and return the resulting dictionary.",
        "prompt_zh": "在VizieR星表服务中搜索包含'Kang W51'关键字的星表，对每个找到的星表，将其ID作为键、描述作为值，创建一个字典，并最终返回该字典。",
        "canonical_solution": "def canonical_solution():\n    from astroquery.vizier import Vizier\n    catalog_list = Vizier.find_catalogs('Kang W51')\n    result = {k: v.description for k, v in catalog_list.items()}\n    return result\n\n\n",
        "test_code": [
            "\nimport numpy as np\ndef test_code(data1, data2):\n    # 检查两个字典的键是否完全相同\n    if data1.keys() != data2.keys():\n        return False\n\n    # 检查每个键对应的值是否相同\n    for key in data1:\n        # 可以这里添加递归比较的逻辑，如果值是复杂的数据结构\n        if not np.all(data1[key] == data2[key]):\n            return False\n    \n    # 如果所有检查都通过，则认为两个字典一致\n    return True\n\n"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 59,
        "prompt_en": "Retrieve the complete astronomical catalog with the identifier 'J/ApJS/191/232' from the Vizier data service. Set the row limit to -1 to ensure the entire catalog is obtained.",
        "prompt_zh": "从Vizier数据服务获取编号为'J/ApJS/191/232'的完整天文目，限制。",
        "canonical_solution": "def canonical_solution():\n    from astroquery.vizier import Vizier\n    Vizier.ROW_LIMIT = -1  # 获取完整目录需要设置行数限制为-1\n    catalogs = Vizier.get_catalogs('J/ApJS/191/232')\n    return catalogs\n\n\n",
        "test_code": [
            "import numpy as np\nfrom astropy.table import Table\n\ndef is_same_table(table_pred,table_ground):\n    table_pred = table_pred.to_pandas()\n    table_ground = table_ground.to_pandas()\n    table_pred_dict = table_pred.to_dict()\n    data_pred = {}\n    for column in  table_pred_dict.keys():\n        for row in table_pred_dict[column].keys():\n            if row not in data_pred.keys():\n                data_pred[row] = []\n            data_pred[row].append({column:table_pred_dict[column][row]})\n\n    table_ground_dict = table_ground.to_dict()\n    data_ground = {}\n    for column in  table_ground_dict.keys():\n        for row in table_ground_dict[column].keys():\n            if row not in data_ground.keys():\n                data_ground[row] = []\n            data_ground[row].append({column:table_ground_dict[column][row]})\n            \n    for data in data_ground:\n        if data not in data_pred:\n            return False\n\n    for data in data_pred:\n        if data not in data_ground:\n            return False\n    return True\n\ndef test_code(data1,data2):\n    if data1.keys()!=data2.keys():\n        return False\n    for key in data1.keys():\n        if not is_same_table(data1[key],data2[key]):\n            print(key)\n            return False\n    return True"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 60,
        "prompt_en": "Query all available astronomical data about the star \"sirius\" from the Vizier database and return the query results.",
        "prompt_zh": "查询Vizier数据库中关于\"sirius\"星的所有可用天文数据，并返回查询结果。",
        "canonical_solution": "def canonical_solution():\n    from astroquery.vizier import Vizier\n    result = Vizier.query_object(\"sirius\")\n    return result\n\n\n",
        "test_code": [
            "import numpy as np\nfrom astropy.table import Table\n\ndef is_same_table(table_pred,table_ground):\n    table_pred = table_pred.to_pandas()\n    table_ground = table_ground.to_pandas()\n    table_pred_dict = table_pred.to_dict()\n    data_pred = {}\n    for column in  table_pred_dict.keys():\n        for row in table_pred_dict[column].keys():\n            if row not in data_pred.keys():\n                data_pred[row] = []\n            data_pred[row].append({column:table_pred_dict[column][row]})\n\n    table_ground_dict = table_ground.to_dict()\n    data_ground = {}\n    for column in  table_ground_dict.keys():\n        for row in table_ground_dict[column].keys():\n            if row not in data_ground.keys():\n                data_ground[row] = []\n            data_ground[row].append({column:table_ground_dict[column][row]})\n            \n    for data in data_ground:\n        if data not in data_pred:\n            return False\n\n    for data in data_pred:\n        if data not in data_ground:\n            return False\n    return True\n\ndef test_code(data1,data2):\n    if data1.keys()!=data2.keys():\n        return False\n    for key in data1.keys():\n        if not is_same_table(data1[key],data2[key]):\n            print(key)\n            return False\n    return True"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 61,
        "prompt_en": "Query objects within a radius of 0.1 degrees centered on \"3C 273\" in the \"GSC\" catalog using the Vizier service.",
        "prompt_zh": "使用Vizier服务查询半径为0.1度内，以“3C 273”为中心的区域，在“GSC”星表中的天体。\n",
        "canonical_solution": "def canonical_solution():\n    from astroquery.vizier import Vizier\n    from astropy.coordinates import Angle\n    result = Vizier.query_region(\"3C 273\", radius=Angle(0.1, \"deg\"), catalog='GSC')\n    return result\n\n\n",
        "test_code": [
            "import numpy as np\nfrom astropy.table import Table\n\ndef is_same_table(table_pred,table_ground):\n    table_pred = table_pred.to_pandas()\n    table_ground = table_ground.to_pandas()\n    table_pred_dict = table_pred.to_dict()\n    data_pred = {}\n    for column in  table_pred_dict.keys():\n        for row in table_pred_dict[column].keys():\n            if row not in data_pred.keys():\n                data_pred[row] = []\n            data_pred[row].append({column:table_pred_dict[column][row]})\n\n    table_ground_dict = table_ground.to_dict()\n    data_ground = {}\n    for column in  table_ground_dict.keys():\n        for row in table_ground_dict[column].keys():\n            if row not in data_ground.keys():\n                data_ground[row] = []\n            data_ground[row].append({column:table_ground_dict[column][row]})\n            \n    for data in data_ground:\n        if data not in data_pred:\n            return False\n\n    for data in data_pred:\n        if data not in data_ground:\n            return False\n    return True\n\ndef test_code(data1,data2):\n    if data1.keys()!=data2.keys():\n        return False\n    for key in data1.keys():\n        if not is_same_table(data1[key],data2[key]):\n            print(key)\n            return False\n    return True"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 62,
        "prompt_en": "Get the coordinates of the Andromeda Galaxy (M31), then perform a cone search centered on M31 with a radius of 0.1 degrees, and return the search results.",
        "prompt_zh": "获取仙女座星系（M31）的坐标，然后执行一个以M31为中心、半径为0.1度的圆锥搜索，返回搜索结果。",
        "canonical_solution": "from astropy.coordinates import SkyCoord\nfrom astroquery.vo_conesearch import ConeSearch\ndef canonical_solution():\n    c = SkyCoord.from_name('M31')\n    result = ConeSearch.query_region(c, '0.1 deg')\n    return result\n\n\n",
        "test_code": [
            "import numpy as np\ndef test_code(data1, data2):\n    # Check if the number of columns is the same\n    if len(data1.colnames) != len(data2.colnames):\n        return False\n    \n    # Check if the column names are the same\n    if data1.colnames != data2.colnames:\n        return False\n    \n    # Check if the number of rows is the same\n    if len(data1) != len(data2):\n        return False\n    \n    # Check if the data in each cell is the same\n    for colname in data1.colnames:\n        if not np.all(data1[colname] == data2[colname]):\n            return False\n    \n    return True"
        ],
        "data_source": "Astroquery"
    },
    {
        "test_id": 63,
        "prompt_en": "List all available Virtual Observatory Cone Search services catalogues.",
        "prompt_zh": "列出所有可用的Virtual Observatory圆锥搜索服务目录。\n",
        "canonical_solution": "from astroquery.vo_conesearch import conesearch\ndef canonical_solution():\n    catalogs = conesearch.list_catalogs()\n    return catalogs\n\n\n",
        "test_code": [
            "\ndef test_code(data1, data2):\n    # 比较列表长度和元素内容\n    return data1 == data2\n\n"
        ],
        "data_source": "Astroquery"
    }
]